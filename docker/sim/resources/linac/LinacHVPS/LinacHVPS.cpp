/*----- PROTECTED REGION ID(LinacHVPS.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        LinacHVPS.cpp
//
// description : C++ source for the LinacHVPS class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               LinacHVPS are implemented in this file.
//
// project :     Linac High Voltage Power Supply
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <tango.h>
#include <LinacHVPS.h>
#include <LinacHVPSClass.h>

/*----- PROTECTED REGION END -----*/	//	LinacHVPS.cpp

/**
 *  LinacHVPS class description:
 *    The high voltage power supply will provide high voltage
 *    to the modulators and to the the gun modulator of the linac.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  dev_state
//  Status        |  dev_status
//  On            |  on
//  Off           |  off
//  Reset         |  reset
//  HVZero        |  hvzero
//  SetHV         |  set_hv
//  SoftReset     |  soft_reset
//  SoftOn        |  soft_on
//  SoftOff       |  soft_off
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  HighVoltage  |  Tango::DevDouble	Scalar
//  HVDac        |  Tango::DevDouble	Scalar
//================================================================

namespace LinacHVPS_ns
{
/*----- PROTECTED REGION ID(LinacHVPS::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	LinacHVPS::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::LinacHVPS()
 *	Description : Constructors for a Tango device
 *                implementing the classLinacHVPS
 */
//--------------------------------------------------------
LinacHVPS::LinacHVPS(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(LinacHVPS::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::constructor_1
}
//--------------------------------------------------------
LinacHVPS::LinacHVPS(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(LinacHVPS::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::constructor_2
}
//--------------------------------------------------------
LinacHVPS::LinacHVPS(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(LinacHVPS::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void LinacHVPS::delete_device()
{
	DEBUG_STREAM << "LinacHVPS::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	//	Delete device's allocated object
	delete attr_HighVoltage_read;
	delete attr_HVDac_read;
#ifndef SIMU
	delete daresburyds;
	delete OnRelayds;
	delete OffRelayds;
	delete HVadcds;
	delete HVdacds;
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void LinacHVPS::init_device()
{
	DEBUG_STREAM << "LinacHVPS::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(LinacHVPS::init_device) ENABLED START -----*/
	
	//	Initialize device
	pulsewaittime.tv_sec = pulsetime / 1000;
	pulsewaittime.tv_nsec = (pulsetime%1000) * 1000000;
	n_state = Tango::ON;
	attr_HighVoltage_read = new Tango::DevDouble;
	attr_HVDac_read = new Tango::DevDouble;
#ifdef SIMU
	*attr_HighVoltage_read = 10.5;
	*attr_HVDac_read = 10.5;
	set_state(Tango::ON);
	thestate = Tango::ON;
#else
	thestate = Tango::UNKNOWN;
	// check if the resources are correctly defined 
	if(interlocks_list.size() == 0)
	{
		Tango::Except::throw_exception ((const char *)"PropertyNotDefined",(const char *)"interlocks_list property not defined",(const char *)"LinacHVPS::init_device");
		cout << "intlk_list size = 0" << endl;
	}
	if(strcmp(highVoltage_adc.c_str(),"NOT YET DEFINED") == 0)
		Tango::Except::throw_exception ((const char *)"PropertyNotDefined",(const char *)"highVoltage_adc property not defined",(const char *)"LinacHVPS::init_device");
	if(strcmp(highVoltage_dac.c_str(),"NOT YET DEFINED") == 0)
		Tango::Except::throw_exception ((const char *)"PropertyNotDefined",(const char *)"highVoltage_dac property not defined",(const char *)"LinacHVPS::init_device");
	if(strcmp(offrelay.c_str(),"NOT YET DEFINED") == 0)
		Tango::Except::throw_exception ((const char *)"PropertyNotDefined",(const char *)"offrelay property not defined",(const char *)"LinacHVPS::init_device");
	if(strcmp(onrelay.c_str(),"NOT YET DEFINED") == 0)
		Tango::Except::throw_exception ((const char *)"PropertyNotDefined",(const char *)"onrelay property not defined",(const char *)"LinacHVPS::init_device");
	if(stateonnum == -888)
		Tango::Except::throw_exception ((const char *)"PropertyNotDefined",(const char *)"stateonnum property not defined",(const char *)"LinacHVPS::init_device");
	if(statepermnum == -888)
		Tango::Except::throw_exception ((const char *)"PropertyNotDefined",(const char *)"statepermnum property not defined",(const char *)"LinacHVPS::init_device");

	daresburyds 	= new Tango::DeviceProxy(daresbury.c_str());
	OnRelayds		= new Tango::DeviceProxy(onrelay.c_str());
	OffRelayds		= new Tango::DeviceProxy(offrelay.c_str());
	HVadcds			= new Tango::DeviceProxy(highVoltage_adc.c_str());
	HVdacds			= new Tango::DeviceProxy(highVoltage_dac.c_str());
	// set transparency reconnection to true
	try{daresburyds->set_transparency_reconnection(true);}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
	try{OnRelayds->set_transparency_reconnection(true);}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
	try{OffRelayds->set_transparency_reconnection(true);}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
	try{HVadcds->set_transparency_reconnection(true);}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
	try{HVdacds->set_transparency_reconnection(true);}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
// initialise interlocks variable
	Tango::DevLong module,num;
	double numtmp;
	interlocks.clear();
	module = (Tango::DevLong) stateonnum;
	numtmp = stateonnum *10;
	num = (Tango::DevLong)numtmp % 10;
	module = module - 1;
	num = (num -1) * 2;
	interlocks.push_back(module);
	interlocks.push_back(num);
	module = (Tango::DevLong) statepermnum;
	numtmp = statepermnum *10;
	num = (Tango::DevLong)numtmp % 10;
	module = module - 1;
	num = (num -1) * 2;
	interlocks.push_back(module);
	interlocks.push_back(num);	
	for(unsigned int j=0;j<interlocks_list.size();j++)
	{
		module = (Tango::DevLong) interlocks_list[j];
		numtmp =  interlocks_list[j]*10;
		num = (Tango::DevLong)numtmp % 10;
		module = module - 1;
		num = (num -1) * 2;
		interlocks.push_back(module);
		interlocks.push_back(num);
	}
	// get interlocks descriptions
	Tango::DeviceData argin;
	try
	{
		argin << interlocks;
		Tango::DeviceData ans = daresburyds->command_inout("GetInterlockDescription",argin);
		ans >> intlk_desc;
		for(unsigned int i=0;i<intlk_desc.size();i++)
			DEBUG_STREAM << "intlk_desc[" << i << "] = " << intlk_desc[i] << endl;
	}
	catch(Tango::DevFailed &e)
	{
		ERROR_STREAM << "Could not get Interlocks Description. Is the Daresbury server well running?" << endl;
		throw;
	}
	// read set value on the dac device
	Tango::DevVarDoubleArray * setval;
	try
	{
		Tango::DeviceAttribute attval = HVdacds->read_attribute("Value");
		attval >> setval;
		attr_HighVoltage_write = (*setval)[1];
		delete setval;
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		return;
	}	
	// change set value according to dac device value set point
	Tango::MultiAttribute *attr_list;
	attr_list = get_device_attr();
	Tango::WAttribute	&attr_hv = attr_list->get_w_attr_by_name ("HighVoltage");
	try
	{
		attr_hv.set_write_value(attr_HighVoltage_write);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
	}
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::init_device
}

//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void LinacHVPS::get_device_property()
{
	/*----- PROTECTED REGION ID(LinacHVPS::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	daresbury	= "ELIN/INTLK/0";
	pulsetime = 1000;
	interlocks_list.clear();
	highVoltage_adc 	= "NOT YET DEFINED";
	highVoltage_dac 	= "NOT YET DEFINED";
	offrelay				= "NOT YET DEFINED";
	onrelay				= "NOT YET DEFINED";
	stateonnum			= -888; // not defined
	statepermnum		= -888; // not defined

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Daresbury"));
	dev_prop.push_back(Tango::DbDatum("HighVoltage_adc"));
	dev_prop.push_back(Tango::DbDatum("HighVoltage_dac"));
	dev_prop.push_back(Tango::DbDatum("Interlocks_list"));
	dev_prop.push_back(Tango::DbDatum("Offrelay"));
	dev_prop.push_back(Tango::DbDatum("Onrelay"));
	dev_prop.push_back(Tango::DbDatum("Pulsetime"));
	dev_prop.push_back(Tango::DbDatum("Stateonnum"));
	dev_prop.push_back(Tango::DbDatum("Statepermnum"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on LinacHVPSClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		LinacHVPSClass	*ds_class =
			(static_cast<LinacHVPSClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Daresbury from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  daresbury;
		else {
			//	Try to initialize Daresbury from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  daresbury;
		}
		//	And try to extract Daresbury value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  daresbury;

		//	Try to initialize HighVoltage_adc from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  highVoltage_adc;
		else {
			//	Try to initialize HighVoltage_adc from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  highVoltage_adc;
		}
		//	And try to extract HighVoltage_adc value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  highVoltage_adc;

		//	Try to initialize HighVoltage_dac from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  highVoltage_dac;
		else {
			//	Try to initialize HighVoltage_dac from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  highVoltage_dac;
		}
		//	And try to extract HighVoltage_dac value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  highVoltage_dac;

		//	Try to initialize Interlocks_list from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  interlocks_list;
		else {
			//	Try to initialize Interlocks_list from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  interlocks_list;
		}
		//	And try to extract Interlocks_list value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  interlocks_list;

		//	Try to initialize Offrelay from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  offrelay;
		else {
			//	Try to initialize Offrelay from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  offrelay;
		}
		//	And try to extract Offrelay value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  offrelay;

		//	Try to initialize Onrelay from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  onrelay;
		else {
			//	Try to initialize Onrelay from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  onrelay;
		}
		//	And try to extract Onrelay value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  onrelay;

		//	Try to initialize Pulsetime from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pulsetime;
		else {
			//	Try to initialize Pulsetime from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pulsetime;
		}
		//	And try to extract Pulsetime value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pulsetime;

		//	Try to initialize Stateonnum from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  stateonnum;
		else {
			//	Try to initialize Stateonnum from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  stateonnum;
		}
		//	And try to extract Stateonnum value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stateonnum;

		//	Try to initialize Statepermnum from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  statepermnum;
		else {
			//	Try to initialize Statepermnum from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  statepermnum;
		}
		//	And try to extract Statepermnum value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  statepermnum;

	}

	/*----- PROTECTED REGION ID(LinacHVPS::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	TangoSys_OMemStream o;
	for(unsigned int j=0 ; j<interlocks_list.size() ; j++)
	{
		if(j != (interlocks_list.size()-1))
			o << interlocks_list[j] << ",";
		else
			o << interlocks_list[j];
	}
	
	INFO_STREAM << "Daresbury        = " << daresbury 		<< endl;
	INFO_STREAM << "High Voltage ADC = " << highVoltage_adc << endl;
	INFO_STREAM << "High Voltage DAC = " << highVoltage_dac << endl;
	INFO_STREAM << "Interlocks list  = " << o.str()			<< endl;
	INFO_STREAM << "Offrelay         = " << offrelay		<< endl;
	INFO_STREAM << "Onrelay          = " << onrelay			<< endl;
	INFO_STREAM << "Pulsetime        = " << pulsetime		<< endl;
	INFO_STREAM << "Stateonnum       = " << stateonnum		<< endl;
	INFO_STREAM << "Statepermnum     = " << statepermnum	<< endl;

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void LinacHVPS::always_executed_hook()
{
	DEBUG_STREAM << "LinacHVPS::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void LinacHVPS::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "LinacHVPS::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	//	Add your own code here

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void LinacHVPS::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "LinacHVPS::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute HighVoltage related method
 *	Description: High Voltage read on the ADC.\nThe set point corresponds to the value which will be set \non the DAC during the ON sequence of the Linac.\nIf the Power Supply is already on, this set point will be \napplied directly on the DAC.\n
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LinacHVPS::read_HighVoltage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LinacHVPS::read_HighVoltage(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::read_HighVoltage) ENABLED START -----*/
	#ifndef SIMU
	try
	{
		Tango::DeviceAttribute HVAttr = HVadcds->read_attribute("Value");
		HVAttr >> *attr_HighVoltage_read;
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
#endif
	attr.set_value(attr_HighVoltage_read);
// #ifndef SIMU
// 	// read set value on the dac device
// 	Tango::DevVarDoubleArray * setval;
// 	try
// 	{
// 		Tango::DeviceAttribute attval = HVdacds->read_attribute("Value");
// 		attval >> setval;
// 		attr_HighVoltage_write = (*setval)[1];
// 		delete setval;
// 	}
// 	catch(Tango::DevFailed &e)
// 	{
// 		Tango::Except::print_exception(e);
// 		return;
// 	}	
// 	// change set value according to dac device value set point
// 	Tango::MultiAttribute *attr_list;
// 	attr_list = get_device_attr();
// 	Tango::WAttribute	&attr_hv = attr_list->get_w_attr_by_name ("HighVoltage");
// 	try
// 	{
// 		attr_hv.set_write_value(attr_HighVoltage_write);
// 	}
// 	catch(Tango::DevFailed &e)
// 	{
// 		Tango::Except::print_exception(e);
// 	}
//#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::read_HighVoltage
}
//--------------------------------------------------------
/**
 *	Write attribute HighVoltage related method
 *	Description: High Voltage read on the ADC.\nThe set point corresponds to the value which will be set \non the DAC during the ON sequence of the Linac.\nIf the Power Supply is already on, this set point will be \napplied directly on the DAC.\n
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LinacHVPS::write_HighVoltage(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LinacHVPS::write_HighVoltage(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(LinacHVPS::write_HighVoltage) ENABLED START -----*/
#ifdef SIMU
	*attr_HighVoltage_read = w_val;
#else
	// apply the setpoint of the HighVoltage Attribute on the HV DAC channel.
	Tango::DevDouble set_hv = w_val;
	Tango::DeviceAttribute hv_attr("Value",set_hv);
	try
	{
		HVdacds->write_attribute(hv_attr);
	}
	catch (Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::write_HighVoltage
}
//--------------------------------------------------------
/**
 *	Read attribute HVDac related method
 *	Description: High Voltage value set on the DAC.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void LinacHVPS::read_HVDac(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LinacHVPS::read_HVDac(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::read_HVDac) ENABLED START -----*/
	#ifndef SIMU
	try
	{
		Tango::DeviceAttribute HVAttr = HVdacds->read_attribute("Value");
		HVAttr >> *attr_HVDac_read;
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
#endif
	attr.set_value(attr_HVDac_read);

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::read_HVDac
}

//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void LinacHVPS::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(LinacHVPS::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command State related method
 *	Description: This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 *	@returns State Code
 */
//--------------------------------------------------------
Tango::DevState LinacHVPS::dev_state()
{
	DEBUG_STREAM << "LinacHVPS::State()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::dev_state) ENABLED START -----*/
	
	Tango::DevState	argout = Tango::UNKNOWN; // replace by your own algorithm
	//	Add your own code
	evalue_state();
	argout = DeviceImpl::dev_state();

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::dev_state
	set_state(argout);    // Give the state to Tango.
	if (argout!=Tango::ALARM)
		DeviceImpl::dev_state();
	return get_state();  // Return it after Tango management.
}
//--------------------------------------------------------
/**
 *	Command Status related method
 *	Description: This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 *	@returns Status description
 */
//--------------------------------------------------------
Tango::ConstDevString LinacHVPS::dev_status()
{
	DEBUG_STREAM << "LinacHVPS::Status()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::dev_status) ENABLED START -----*/
	
	string	status = "Device is OK";
	//	Add your own code
#ifndef SIMU
	dev_state();
	switch(thestate)
	{
	case Tango::UNKNOWN:
		thestatus = "Interlock status not readable !";
		break;
	case Tango::OFF:
		thestatus = intlk_desc[0];
		break;
	case Tango::ON:
		thestatus = "ON";
		break;
	case Tango::DISABLE:
		thestatus = "Can' t be switch on while : \n";
		for(unsigned int i=1; i<intlk_states.size() ; i++)
		{
			if(intlk_states[i] == 0)
			{
				thestatus += intlk_desc[i];
				thestatus += "\n";
			}
		}
		break;
	case Tango::FAULT:
		thestatus = "";
		for(unsigned int i=2; i<intlk_states.size() ; i++)
		{
			if(intlk_states[i] == 0)
			{
				thestatus += intlk_desc[i];
				thestatus += "\n";
			}
		}
		break;
	default:
		break;
	}
	set_status(thestatus.c_str());
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::dev_status
	set_status(status);               // Give the status to Tango.
	return DeviceImpl::dev_status();  // Return it.
}
//--------------------------------------------------------
/**
 *	Command On related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void LinacHVPS::on()
{
	DEBUG_STREAM << "LinacHVPS::On()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::on) ENABLED START -----*/
	
	//	Add your own code
	struct timespec waittime;
	struct timespec remtime;
	
	DEBUG_STREAM << "LinacHVPS::on(): entering... !" << endl;

	//	Add your own code to control device here
#ifdef SIMU
	set_state(Tango::ON);
	thestate = Tango::ON;
#else
	try{	dev_state(); }
	catch(Tango::DevFailed &e){Tango::Except::print_exception(e);}
	if(get_state() == Tango::DISABLE)
	{
		if(intlk_states[1] == 0)
		{
			TangoSys_OMemStream o;
			o << "Can' t be switch on while " << intlk_desc[1] << ends;
			Tango::Except::throw_exception(
			(const char *) "CommandNotAllowed",
			o.str(),
			(const char *) "LinacHVPS::on()");
		}
	}
	try
	{
		OnRelayds->command_inout("close");
	}
	catch(...)
	{
		ERROR_STREAM << "LinacHVPS::on():Error activating the pulsed relay (close command)" << onrelay.c_str() <<  endl;
		throw;
	}
	waittime = pulsewaittime;
	while ((nanosleep(&waittime,&remtime) == -1) && (errno == EINTR))
				waittime = remtime;
	try
	{
		OnRelayds->command_inout("open");
	}
	catch(...)
	{
		ERROR_STREAM << "LinacHVPS::on():Error activating the pulsed relay (open command)" << onrelay.c_str() <<  endl;
		throw;
	}
	n_state = Tango::ON;
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::on
}
//--------------------------------------------------------
/**
 *	Command Off related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void LinacHVPS::off()
{
	DEBUG_STREAM << "LinacHVPS::Off()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::off) ENABLED START -----*/
	
	//	Add your own code
	struct timespec waittime;
	struct timespec remtime;
	
	DEBUG_STREAM << "LinacHVPS::off(): entering... !" << endl;

	//	Add your own code to control device here
#ifdef SIMU
	set_state(Tango::OFF);
	thestate = Tango::OFF;
#else
	try
	{
		OffRelayds->command_inout("open");
	}
	catch(...)
	{
		ERROR_STREAM << "LinacHVPS::off():Error activating the pulsed relay (open command)" << offrelay.c_str() <<  endl;
		throw;
	}
	waittime = pulsewaittime;
	while ((nanosleep(&waittime,&remtime) == -1) && (errno == EINTR))
				waittime = remtime;
	try
	{
		OffRelayds->command_inout("close");
	}
	catch(...)
	{
		ERROR_STREAM << "LinacHVPS::off():Error activating the pulsed relay (close command)" << offrelay.c_str() <<  endl;
		throw;
	}
	n_state = Tango::OFF;
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::off
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void LinacHVPS::reset()
{
	DEBUG_STREAM << "LinacHVPS::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::reset) ENABLED START -----*/
	
	//	Add your own code
	#ifdef SIMU
	switch(get_state())
	{
		case Tango::FAULT:
			set_state(Tango::ON);
			thestate = Tango::ON;
			break;
		case Tango::ON:
			set_state(Tango::OFF);
			thestate = Tango::OFF;
			break;
		case Tango::OFF:
			set_state(Tango::DISABLE);
			thestate = Tango::DISABLE;
			break;
		case Tango::DISABLE:
			set_state(Tango::FAULT);
			thestate = Tango::FAULT;
			break;
		default:
			set_state(Tango::ON);
			thestate = Tango::ON;
	}
#else
// reset the Daresbury
	try
	{
		daresburyds->command_inout("Reset");
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
	n_state = Tango::OFF;
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::reset
}
//--------------------------------------------------------
/**
 *	Command HVZero related method
 *	Description: This command will set the High Voltage to 0 without losing the set point of
 *               the HighVoltage Attribute.
 *
 */
//--------------------------------------------------------
void LinacHVPS::hvzero()
{
	DEBUG_STREAM << "LinacHVPS::HVZero()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::hvzero) ENABLED START -----*/
	
	//	Add your own code
	#ifdef SIMU
	*attr_HighVoltage_read = 0.0;
	*attr_HVDac_read = 0.0;
#else
	// Set High Voltage to 0 :
	Tango::DevDouble set_hv = 0.0;
	Tango::DeviceAttribute hv_attr("Value",set_hv);
	try
	{
		HVdacds->write_attribute(hv_attr);
	}
	catch (Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::hvzero
}
//--------------------------------------------------------
/**
 *	Command SetHV related method
 *	Description: This command will apply the setpoint of the HighVoltage Attribute on the HV DAC channel.
 *
 */
//--------------------------------------------------------
void LinacHVPS::set_hv()
{
	DEBUG_STREAM << "LinacHVPS::SetHV()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::set_hv) ENABLED START -----*/
	
	//	Add your own code
	#ifdef SIMU
	*attr_HighVoltage_read = attr_HighVoltage_write;
	*attr_HVDac_read = attr_HighVoltage_write;
#else
	// apply the setpoint of the HighVoltage Attribute on the HV DAC channel.
	Tango::DevDouble set_hv = attr_HighVoltage_write;
	Tango::DeviceAttribute hv_attr("Value",set_hv);
	try
	{
		HVdacds->write_attribute(hv_attr);
	}
	catch (Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
#endif

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::set_hv
}
//--------------------------------------------------------
/**
 *	Command SoftReset related method
 *	Description: Reset without reset of the Daresbury.
 *
 */
//--------------------------------------------------------
void LinacHVPS::soft_reset()
{
	DEBUG_STREAM << "LinacHVPS::SoftReset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::soft_reset) ENABLED START -----*/
	
	//	Add your own code
	n_state = Tango::OFF;

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::soft_reset
}
//--------------------------------------------------------
/**
 *	Command SoftOn related method
 *	Description: Specify that we would like to reach On state.
 *               Do not execute Pulse command on the OnRelay.
 *
 */
//--------------------------------------------------------
void LinacHVPS::soft_on()
{
	DEBUG_STREAM << "LinacHVPS::SoftOn()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::soft_on) ENABLED START -----*/
	
	//	Add your own code
	#ifdef SIMU
	set_state(Tango::ON);
	thestate = Tango::ON;
#endif
	n_state = Tango::ON;

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::soft_on
}
//--------------------------------------------------------
/**
 *	Command SoftOff related method
 *	Description: Specify that we would like to reach OFF state.
 *               do not execute Pulse command on the OffRelay.
 *
 */
//--------------------------------------------------------
void LinacHVPS::soft_off()
{
	DEBUG_STREAM << "LinacHVPS::SoftOff()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(LinacHVPS::soft_off) ENABLED START -----*/
	
	//	Add your own code
	#ifdef SIMU
	set_state(Tango::OFF);
	thestate = Tango::OFF;
#endif
	n_state = Tango::OFF;

	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::soft_off
}
//--------------------------------------------------------
/**
 *	Method      : LinacHVPS::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void LinacHVPS::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(LinacHVPS::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	LinacHVPS::add_dynamic_commands
}

/*----- PROTECTED REGION ID(LinacHVPS::namespace_ending) ENABLED START -----*/

//	Additional Methods
/*
 * This function will read the interlocks attribute from the Daresbury device server
 * Description:evaluate the state of the device by reading the state of the
 * corresponding  Daresbury relay.
 * the state of the object is directly updated.
 */
void LinacHVPS::evalue_state()
{
	DEBUG_STREAM << "LinacHVPS::evalue_state(): entering... !" << endl;
#ifndef SIMU
	Tango::DeviceData argin;
	try
	{
		argin << interlocks;
		Tango::DeviceData ans = daresburyds->command_inout("GetInterlockState",argin);
		ans >> intlk_states;
	}
	catch(Tango::DevFailed &e)
	{
		set_state(Tango::UNKNOWN);
		thestate = Tango::UNKNOWN;
		Tango::Except::print_exception(e);
		return;
	}
	for(unsigned int i=0;i<intlk_states.size();i++)
		DEBUG_STREAM << "LinacHVPS: intlk_states[" << i << "] = " << intlk_states[i] << endl;

	if(intlk_states[0] == 1)
	{
		set_state(Tango::ON);
		thestate = Tango::ON;
		n_state = Tango::ON;
		return;
	}
	if(intlk_states[1] == 0)
	{
		set_state(Tango::DISABLE);
		thestate = Tango::DISABLE;
		n_state = Tango::OFF;
		return;
	}
	
	for(unsigned int i=2;i<intlk_states.size();i++)
	{
		if(intlk_states[i] == 0)
		{
			if(n_state == Tango::ON)
			{
				set_state(Tango::FAULT);
				thestate = Tango::FAULT;
			}
			else
			{
				set_state(Tango::DISABLE);
				thestate = Tango::DISABLE;
			}
			return;
		}
	}
	set_state(Tango::OFF);
	thestate = Tango::OFF;
	return;

#endif
}


/*----- PROTECTED REGION END -----*/	//	LinacHVPS::namespace_ending
} //	namespace
