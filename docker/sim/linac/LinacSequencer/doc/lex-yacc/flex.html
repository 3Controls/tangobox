<HTML>
<HEAD>
<!-- Created by texi2html 1.56k from flex.texi on 23 February 2001 -->

<TITLE>Flex - a scanner generator</TITLE>
</HEAD>
<BODY>
<H1>Flex, version 2.5</H1>
<H2>A fast scanner generator</H2>
<H2>Edition 2.5, March 1995</H2>
<ADDRESS>Vern Paxson</ADDRESS>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<UL>
<LI><A NAME="TOC1" HREF="flex.html#SEC1">Name</A>
<LI><A NAME="TOC2" HREF="flex.html#SEC2">Synopsis</A>
<LI><A NAME="TOC3" HREF="flex.html#SEC3">Overview</A>
<LI><A NAME="TOC4" HREF="flex.html#SEC4">Description</A>
<LI><A NAME="TOC5" HREF="flex.html#SEC5">Some simple examples</A>
<LI><A NAME="TOC6" HREF="flex.html#SEC6">Format of the input file</A>
<LI><A NAME="TOC7" HREF="flex.html#SEC7">Patterns</A>
<LI><A NAME="TOC8" HREF="flex.html#SEC8">How the input is matched</A>
<LI><A NAME="TOC9" HREF="flex.html#SEC9">Actions</A>
<LI><A NAME="TOC10" HREF="flex.html#SEC10">The generated scanner</A>
<LI><A NAME="TOC11" HREF="flex.html#SEC11">Start conditions</A>
<LI><A NAME="TOC12" HREF="flex.html#SEC12">Multiple input buffers</A>
<LI><A NAME="TOC13" HREF="flex.html#SEC13">End-of-file rules</A>
<LI><A NAME="TOC14" HREF="flex.html#SEC14">Miscellaneous macros</A>
<LI><A NAME="TOC15" HREF="flex.html#SEC15">Values available to the user</A>
<LI><A NAME="TOC16" HREF="flex.html#SEC16">Interfacing with <CODE>yacc</CODE></A>
<LI><A NAME="TOC17" HREF="flex.html#SEC17">Options</A>
<LI><A NAME="TOC18" HREF="flex.html#SEC18">Performance considerations</A>
<LI><A NAME="TOC19" HREF="flex.html#SEC19">Generating C++ scanners</A>
<LI><A NAME="TOC20" HREF="flex.html#SEC20">Incompatibilities with <CODE>lex</CODE> and POSIX</A>
<LI><A NAME="TOC21" HREF="flex.html#SEC21">Diagnostics</A>
<LI><A NAME="TOC22" HREF="flex.html#SEC22">Files</A>
<LI><A NAME="TOC23" HREF="flex.html#SEC23">Deficiencies / Bugs</A>
<LI><A NAME="TOC24" HREF="flex.html#SEC24">See also</A>
<LI><A NAME="TOC25" HREF="flex.html#SEC25">Author</A>
</UL>
</UL>
<P><HR><P>

<P>
Copyright (C) 1990 The Regents of the University of California.
All rights reserved.


<P>
This code is derived from software contributed to Berkeley by
Vern Paxson.


<P>
The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.


<P>
Redistribution and use in source and binary forms with or without
modification are permitted provided that: (1) source distributions
retain this entire copyright notice and comment, and (2)
distributions including binaries display the following
acknowledgement:  "This product includes software developed by the
University of California, Berkeley and its contributors" in the
documentation or other materials provided with the distribution and
in all advertising materials mentioning features or use of this
software.  Neither the name of the University nor the names of its
contributors may be used to endorse or promote products derived
from this software without specific prior written permission.


<P>
THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.




<H2><A NAME="SEC1" HREF="flex.html#TOC1">Name</A></H2>

<P>
flex - fast lexical analyzer generator




<H2><A NAME="SEC2" HREF="flex.html#TOC2">Synopsis</A></H2>


<PRE>
flex [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]
[--help --version] [<VAR>filename</VAR> ...]
</PRE>



<H2><A NAME="SEC3" HREF="flex.html#TOC3">Overview</A></H2>

<P>
This manual describes <CODE>flex</CODE>, a tool for generating programs
that perform pattern-matching on text.  The manual
includes both tutorial and reference sections:


<DL COMPACT>

<DT>Description
<DD>
a brief overview of the tool

<DT>Some Simple Examples
<DD>
<DT>Format Of The Input File
<DD>
<DT>Patterns
<DD>
the extended regular expressions used by flex

<DT>How The Input Is Matched
<DD>
the rules for determining what has been matched

<DT>Actions
<DD>
how to specify what to do when a pattern is matched

<DT>The Generated Scanner
<DD>
details regarding the scanner that flex produces;
how to control the input source

<DT>Start Conditions
<DD>
introducing context into your scanners, and
managing "mini-scanners"

<DT>Multiple Input Buffers
<DD>
how to manipulate multiple input sources; how to
scan from strings instead of files

<DT>End-of-file Rules
<DD>
special rules for matching the end of the input

<DT>Miscellaneous Macros
<DD>
a summary of macros available to the actions

<DT>Values Available To The User
<DD>
a summary of values available to the actions

<DT>Interfacing With Yacc
<DD>
connecting flex scanners together with yacc parsers

<DT>Options
<DD>
flex command-line options, and the "%option"
directive

<DT>Performance Considerations
<DD>
how to make your scanner go as fast as possible

<DT>Generating C++ Scanners
<DD>
the (experimental) facility for generating C++
scanner classes

<DT>Incompatibilities With Lex And POSIX
<DD>
how flex differs from AT&#38;T lex and the POSIX lex
standard

<DT>Diagnostics
<DD>
those error messages produced by flex (or scanners
it generates) whose meanings might not be apparent

<DT>Files
<DD>
files used by flex

<DT>Deficiencies / Bugs
<DD>
known problems with flex

<DT>See Also
<DD>
other documentation, related tools

<DT>Author
<DD>
includes contact information
</DL>



<H2><A NAME="SEC4" HREF="flex.html#TOC4">Description</A></H2>

<P>
<CODE>flex</CODE> is a tool for generating <EM>scanners</EM>: programs which
recognized lexical patterns in text.  <CODE>flex</CODE> reads the given
input files, or its standard input if no file names are
given, for a description of a scanner to generate.  The
description is in the form of pairs of regular expressions
and C code, called <EM>rules</EM>. <CODE>flex</CODE> generates as output a C
source file, <TT>`lex.yy.c'</TT>, which defines a routine <SAMP>`yylex()'</SAMP>.
This file is compiled and linked with the <SAMP>`-lfl'</SAMP> library to
produce an executable.  When the executable is run, it
analyzes its input for occurrences of the regular
expressions.  Whenever it finds one, it executes the
corresponding C code.




<H2><A NAME="SEC5" HREF="flex.html#TOC5">Some simple examples</A></H2>

<P>
First some simple examples to get the flavor of how one
uses <CODE>flex</CODE>.  The following <CODE>flex</CODE> input specifies a scanner
which whenever it encounters the string "username" will
replace it with the user's login name:



<PRE>
%%
username    printf( "%s", getlogin() );
</PRE>

<P>
By default, any text not matched by a <CODE>flex</CODE> scanner is
copied to the output, so the net effect of this scanner is
to copy its input file to its output with each occurrence
of "username" expanded.  In this input, there is just one
rule.  "username" is the <VAR>pattern</VAR> and the "printf" is the
<VAR>action</VAR>.  The "%%" marks the beginning of the rules.


<P>
Here's another simple example:



<PRE>
        int num_lines = 0, num_chars = 0;

%%
\n      ++num_lines; ++num_chars;
.       ++num_chars;

%%
main()
        {
        yylex();
        printf( "# of lines = %d, # of chars = %d\n",
                num_lines, num_chars );
        }
</PRE>

<P>
This scanner counts the number of characters and the
number of lines in its input (it produces no output other
than the final report on the counts).  The first line
declares two globals, "num_lines" and "num_chars", which
are accessible both inside <SAMP>`yylex()'</SAMP> and in the <SAMP>`main()'</SAMP>
routine declared after the second "%%".  There are two rules,
one which matches a newline ("\n") and increments both the
line count and the character count, and one which matches
any character other than a newline (indicated by the "."
regular expression).


<P>
A somewhat more complicated example:



<PRE>
/* scanner for a toy Pascal-like language */

%{
/* need this for the call to atof() below */
#include &#60;math.h&#62;
%}

DIGIT    [0-9]
ID       [a-z][a-z0-9]*

%%

{DIGIT}+    {
            printf( "An integer: %s (%d)\n", yytext,
                    atoi( yytext ) );
            }

{DIGIT}+"."{DIGIT}*        {
            printf( "A float: %s (%g)\n", yytext,
                    atof( yytext ) );
            }

if|then|begin|end|procedure|function        {
            printf( "A keyword: %s\n", yytext );
            }

{ID}        printf( "An identifier: %s\n", yytext );

"+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

"{"[^}\n]*"}"     /* eat up one-line comments */

[ \t\n]+          /* eat up whitespace */

.           printf( "Unrecognized character: %s\n", yytext );

%%

main( argc, argv )
int argc;
char **argv;
    {
    ++argv, --argc;  /* skip over program name */
    if ( argc &#62; 0 )
            yyin = fopen( argv[0], "r" );
    else
            yyin = stdin;

    yylex();
    }
</PRE>

<P>
This is the beginnings of a simple scanner for a language
like Pascal.  It identifies different types of <VAR>tokens</VAR> and
reports on what it has seen.


<P>
The details of this example will be explained in the
following sections.




<H2><A NAME="SEC6" HREF="flex.html#TOC6">Format of the input file</A></H2>

<P>
The <CODE>flex</CODE> input file consists of three sections, separated
by a line with just <SAMP>`%%'</SAMP> in it:



<PRE>
definitions
%%
rules
%%
user code
</PRE>

<P>
The <EM>definitions</EM> section contains declarations of simple
<EM>name</EM> definitions to simplify the scanner specification,
and declarations of <EM>start conditions</EM>, which are explained
in a later section.
Name definitions have the form:



<PRE>
name definition
</PRE>

<P>
The "name" is a word beginning with a letter or an
underscore ('_') followed by zero or more letters, digits, '_',
or '-' (dash).  The definition is taken to begin at the
first non-white-space character following the name and
continuing to the end of the line.  The definition can
subsequently be referred to using "{name}", which will
expand to "(definition)".  For example,



<PRE>
DIGIT    [0-9]
ID       [a-z][a-z0-9]*
</PRE>

<P>
defines "DIGIT" to be a regular expression which matches a
single digit, and "ID" to be a regular expression which
matches a letter followed by zero-or-more
letters-or-digits.  A subsequent reference to



<PRE>
{DIGIT}+"."{DIGIT}*
</PRE>

<P>
is identical to



<PRE>
([0-9])+"."([0-9])*
</PRE>

<P>
and matches one-or-more digits followed by a '.' followed
by zero-or-more digits.


<P>
The <VAR>rules</VAR> section of the <CODE>flex</CODE> input contains a series of
rules of the form:



<PRE>
pattern   action
</PRE>

<P>
where the pattern must be unindented and the action must
begin on the same line.


<P>
See below for a further description of patterns and
actions.


<P>
Finally, the user code section is simply copied to
<TT>`lex.yy.c'</TT> verbatim.  It is used for companion routines
which call or are called by the scanner.  The presence of
this section is optional; if it is missing, the second <SAMP>`%%'</SAMP>
in the input file may be skipped, too.


<P>
In the definitions and rules sections, any <EM>indented</EM> text or
text enclosed in <SAMP>`%{'</SAMP> and <SAMP>`%}'</SAMP> is copied verbatim to the
output (with the <SAMP>`%{}'</SAMP>'s removed).  The <SAMP>`%{}'</SAMP>'s must
appear unindented on lines by themselves.


<P>
In the rules section, any indented or %{} text appearing
before the first rule may be used to declare variables
which are local to the scanning routine and (after the
declarations) code which is to be executed whenever the
scanning routine is entered.  Other indented or %{} text
in the rule section is still copied to the output, but its
meaning is not well-defined and it may well cause
compile-time errors (this feature is present for <CODE>POSIX</CODE> compliance;
see below for other such features).


<P>
In the definitions section (but not in the rules section),
an unindented comment (i.e., a line beginning with "/*")
is also copied verbatim to the output up to the next "*/".




<H2><A NAME="SEC7" HREF="flex.html#TOC7">Patterns</A></H2>

<P>
The patterns in the input are written using an extended
set of regular expressions.  These are:


<DL COMPACT>

<DT><SAMP>`x'</SAMP>
<DD>
match the character <SAMP>`x'</SAMP>
<DT><SAMP>`.'</SAMP>
<DD>
any character (byte) except newline
<DT><SAMP>`[xyz]'</SAMP>
<DD>
a "character class"; in this case, the pattern
matches either an <SAMP>`x'</SAMP>, a <SAMP>`y'</SAMP>, or a <SAMP>`z'</SAMP>
<DT><SAMP>`[abj-oZ]'</SAMP>
<DD>
a "character class" with a range in it; matches
an <SAMP>`a'</SAMP>, a <SAMP>`b'</SAMP>, any letter from <SAMP>`j'</SAMP> through <SAMP>`o'</SAMP>,
or a <SAMP>`Z'</SAMP>
<DT><SAMP>`[^A-Z]'</SAMP>
<DD>
a "negated character class", i.e., any character
but those in the class.  In this case, any
character EXCEPT an uppercase letter.
<DT><SAMP>`[^A-Z\n]'</SAMP>
<DD>
any character EXCEPT an uppercase letter or
a newline
<DT><SAMP>`<VAR>r</VAR>*'</SAMP>
<DD>
zero or more <VAR>r</VAR>'s, where <VAR>r</VAR> is any regular expression
<DT><SAMP>`<VAR>r</VAR>+'</SAMP>
<DD>
one or more <VAR>r</VAR>'s
<DT><SAMP>`<VAR>r</VAR>?'</SAMP>
<DD>
zero or one <VAR>r</VAR>'s (that is, "an optional <VAR>r</VAR>")
<DT><SAMP>`<VAR>r</VAR>{2,5}'</SAMP>
<DD>
anywhere from two to five <VAR>r</VAR>'s
<DT><SAMP>`<VAR>r</VAR>{2,}'</SAMP>
<DD>
two or more <VAR>r</VAR>'s
<DT><SAMP>`<VAR>r</VAR>{4}'</SAMP>
<DD>
exactly 4 <VAR>r</VAR>'s
<DT><SAMP>`{<VAR>name</VAR>}'</SAMP>
<DD>
the expansion of the "<VAR>name</VAR>" definition
(see above)
<DT><SAMP>`"[xyz]\"foo"'</SAMP>
<DD>
the literal string: <SAMP>`[xyz]"foo'</SAMP>
<DT><SAMP>`\<VAR>x</VAR>'</SAMP>
<DD>
if <VAR>x</VAR> is an <SAMP>`a'</SAMP>, <SAMP>`b'</SAMP>, <SAMP>`f'</SAMP>, <SAMP>`n'</SAMP>, <SAMP>`r'</SAMP>, <SAMP>`t'</SAMP>, or <SAMP>`v'</SAMP>,
then the ANSI-C interpretation of \<VAR>x</VAR>.
Otherwise, a literal <SAMP>`<VAR>x</VAR>'</SAMP> (used to escape
operators such as <SAMP>`*'</SAMP>)
<DT><SAMP>`\0'</SAMP>
<DD>
a NUL character (ASCII code 0)
<DT><SAMP>`\123'</SAMP>
<DD>
the character with octal value 123
<DT><SAMP>`\x2a'</SAMP>
<DD>
the character with hexadecimal value <CODE>2a</CODE>
<DT><SAMP>`(<VAR>r</VAR>)'</SAMP>
<DD>
match an <VAR>r</VAR>; parentheses are used to override
precedence (see below)
<DT><SAMP>`<VAR>r</VAR><VAR>s</VAR>'</SAMP>
<DD>
the regular expression <VAR>r</VAR> followed by the
regular expression <VAR>s</VAR>; called "concatenation"
<DT><SAMP>`<VAR>r</VAR>|<VAR>s</VAR>'</SAMP>
<DD>
either an <VAR>r</VAR> or an <VAR>s</VAR>
<DT><SAMP>`<VAR>r</VAR>/<VAR>s</VAR>'</SAMP>
<DD>
an <VAR>r</VAR> but only if it is followed by an <VAR>s</VAR>.  The text
matched by <VAR>s</VAR> is included when determining whether this rule is
the <EM>longest match</EM>, but is then returned to the input before
the action is executed.  So the action only sees the text matched
by <VAR>r</VAR>.  This type of pattern is called <EM>trailing context</EM>.
(There are some combinations of <SAMP>`<VAR>r</VAR>/<VAR>s</VAR>'</SAMP> that <CODE>flex</CODE>
cannot match correctly; see notes in the Deficiencies / Bugs section
below regarding "dangerous trailing context".)
<DT><SAMP>`^<VAR>r</VAR>'</SAMP>
<DD>
an <VAR>r</VAR>, but only at the beginning of a line (i.e.,
which just starting to scan, or right after a
newline has been scanned).
<DT><SAMP>`<VAR>r</VAR>$'</SAMP>
<DD>
an <VAR>r</VAR>, but only at the end of a line (i.e., just
before a newline).  Equivalent to "<VAR>r</VAR>/\n".

Note that flex's notion of "newline" is exactly
whatever the C compiler used to compile flex
interprets '\n' as; in particular, on some DOS
systems you must either filter out \r's in the
input yourself, or explicitly use <VAR>r</VAR>/\r\n for "r$".
<DT><SAMP>`&#60;<VAR>s</VAR>&#62;<VAR>r</VAR>'</SAMP>
<DD>
an <VAR>r</VAR>, but only in start condition <VAR>s</VAR> (see
below for discussion of start conditions)
&#60;<VAR>s1</VAR>,<VAR>s2</VAR>,<VAR>s3</VAR>&#62;<VAR>r</VAR>
same, but in any of start conditions <VAR>s1</VAR>,
<VAR>s2</VAR>, or <VAR>s3</VAR>
<DT><SAMP>`&#60;*&#62;<VAR>r</VAR>'</SAMP>
<DD>
an <VAR>r</VAR> in any start condition, even an exclusive one.
<DT><SAMP>`&#60;&#60;EOF&#62;&#62;'</SAMP>
<DD>
an end-of-file
<DT><SAMP>`&#60;<VAR>s1</VAR>,<VAR>s2</VAR>&#62;&#60;&#60;EOF&#62;&#62;'</SAMP>
<DD>
an end-of-file when in start condition <VAR>s1</VAR> or <VAR>s2</VAR>
</DL>

<P>
Note that inside of a character class, all regular
expression operators lose their special meaning except escape
('\') and the character class operators, '-', ']', and, at
the beginning of the class, '^'.


<P>
The regular expressions listed above are grouped according
to precedence, from highest precedence at the top to
lowest at the bottom.  Those grouped together have equal
precedence.  For example,



<PRE>
foo|bar*
</PRE>

<P>
is the same as



<PRE>
(foo)|(ba(r*))
</PRE>

<P>
since the '*' operator has higher precedence than
concatenation, and concatenation higher than alternation ('|').
This pattern therefore matches <EM>either</EM> the string "foo" <EM>or</EM>
the string "ba" followed by zero-or-more r's.  To match
"foo" or zero-or-more "bar"'s, use:



<PRE>
foo|(bar)*
</PRE>

<P>
and to match zero-or-more "foo"'s-or-"bar"'s:



<PRE>
(foo|bar)*
</PRE>

<P>
In addition to characters and ranges of characters,
character classes can also contain character class
<EM>expressions</EM>.  These are expressions enclosed inside <SAMP>`['</SAMP>: and <SAMP>`:'</SAMP>]
delimiters (which themselves must appear between the '['
and ']' of the character class; other elements may occur
inside the character class, too).  The valid expressions
are:



<PRE>
[:alnum:] [:alpha:] [:blank:]
[:cntrl:] [:digit:] [:graph:]
[:lower:] [:print:] [:punct:]
[:space:] [:upper:] [:xdigit:]
</PRE>

<P>
These expressions all designate a set of characters
equivalent to the corresponding standard C <SAMP>`isXXX'</SAMP> function.  For
example, <SAMP>`[:alnum:]'</SAMP> designates those characters for which
<SAMP>`isalnum()'</SAMP> returns true - i.e., any alphabetic or numeric.
Some systems don't provide <SAMP>`isblank()'</SAMP>, so flex defines
<SAMP>`[:blank:]'</SAMP> as a blank or a tab.


<P>
For example, the following character classes are all
equivalent:



<PRE>
[[:alnum:]]
[[:alpha:][:digit:]
[[:alpha:]0-9]
[a-zA-Z0-9]
</PRE>

<P>
If your scanner is case-insensitive (the <SAMP>`-i'</SAMP> flag), then
<SAMP>`[:upper:]'</SAMP> and <SAMP>`[:lower:]'</SAMP> are equivalent to <SAMP>`[:alpha:]'</SAMP>.


<P>
Some notes on patterns:



<UL>
<LI>

A negated character class such as the example
"[^A-Z]" above <EM>will match a newline</EM> unless "\n" (or an
equivalent escape sequence) is one of the
characters explicitly present in the negated character
class (e.g., "[^A-Z\n]").  This is unlike how many
other regular expression tools treat negated
character classes, but unfortunately the inconsistency
is historically entrenched.  Matching newlines
means that a pattern like [^"]* can match the
entire input unless there's another quote in the
input.

<LI>

A rule can have at most one instance of trailing
context (the '/' operator or the '$' operator).
The start condition, '^', and "&#60;&#60;EOF&#62;&#62;" patterns
can only occur at the beginning of a pattern, and,
as well as with '/' and '$', cannot be grouped
inside parentheses.  A '^' which does not occur at
the beginning of a rule or a '$' which does not
occur at the end of a rule loses its special
properties and is treated as a normal character.

The following are illegal:


<PRE>
foo/bar$
&#60;sc1&#62;foo&#60;sc2&#62;bar
</PRE>

Note that the first of these, can be written
"foo/bar\n".

The following will result in '$' or '^' being
treated as a normal character:


<PRE>
foo|(bar$)
foo|^bar
</PRE>

If what's wanted is a "foo" or a
bar-followed-by-a-newline, the following could be used (the special
'|' action is explained below):


<PRE>
foo      |
bar$     /* action goes here */
</PRE>

A similar trick will work for matching a foo or a
bar-at-the-beginning-of-a-line.
</UL>



<H2><A NAME="SEC8" HREF="flex.html#TOC8">How the input is matched</A></H2>

<P>
When the generated scanner is run, it analyzes its input
looking for strings which match any of its patterns.  If
it finds more than one match, it takes the one matching
the most text (for trailing context rules, this includes
the length of the trailing part, even though it will then
be returned to the input).  If it finds two or more
matches of the same length, the rule listed first in the
<CODE>flex</CODE> input file is chosen.


<P>
Once the match is determined, the text corresponding to
the match (called the <VAR>token</VAR>) is made available in the
global character pointer <CODE>yytext</CODE>, and its length in the
global integer <CODE>yyleng</CODE>.  The <VAR>action</VAR> corresponding to the
matched pattern is then executed (a more detailed
description of actions follows), and then the remaining input is
scanned for another match.


<P>
If no match is found, then the <EM>default rule</EM> is executed:
the next character in the input is considered matched and
copied to the standard output.  Thus, the simplest legal
<CODE>flex</CODE> input is:



<PRE>
%%
</PRE>

<P>
which generates a scanner that simply copies its input
(one character at a time) to its output.


<P>
Note that <CODE>yytext</CODE> can be defined in two different ways:
either as a character <EM>pointer</EM> or as a character <EM>array</EM>.
You can control which definition <CODE>flex</CODE> uses by including
one of the special directives <SAMP>`%pointer'</SAMP> or <SAMP>`%array'</SAMP> in the
first (definitions) section of your flex input.  The
default is <SAMP>`%pointer'</SAMP>, unless you use the <SAMP>`-l'</SAMP> lex
compatibility option, in which case <CODE>yytext</CODE> will be an array.  The
advantage of using <SAMP>`%pointer'</SAMP> is substantially faster
scanning and no buffer overflow when matching very large
tokens (unless you run out of dynamic memory).  The
disadvantage is that you are restricted in how your actions can
modify <CODE>yytext</CODE> (see the next section), and calls to the
<SAMP>`unput()'</SAMP> function destroys the present contents of <CODE>yytext</CODE>,
which can be a considerable porting headache when moving
between different <CODE>lex</CODE> versions.


<P>
The advantage of <SAMP>`%array'</SAMP> is that you can then modify <CODE>yytext</CODE>
to your heart's content, and calls to <SAMP>`unput()'</SAMP> do not
destroy <CODE>yytext</CODE> (see below).  Furthermore, existing <CODE>lex</CODE>
programs sometimes access <CODE>yytext</CODE> externally using
declarations of the form:

<PRE>
extern char yytext[];
</PRE>

<P>
This definition is erroneous when used with <SAMP>`%pointer'</SAMP>, but
correct for <SAMP>`%array'</SAMP>.


<P>
<SAMP>`%array'</SAMP> defines <CODE>yytext</CODE> to be an array of <CODE>YYLMAX</CODE> characters,
which defaults to a fairly large value.  You can change
the size by simply #define'ing <CODE>YYLMAX</CODE> to a different value
in the first section of your <CODE>flex</CODE> input.  As mentioned
above, with <SAMP>`%pointer'</SAMP> yytext grows dynamically to
accommodate large tokens.  While this means your <SAMP>`%pointer'</SAMP> scanner
can accommodate very large tokens (such as matching entire
blocks of comments), bear in mind that each time the
scanner must resize <CODE>yytext</CODE> it also must rescan the entire
token from the beginning, so matching such tokens can
prove slow.  <CODE>yytext</CODE> presently does <EM>not</EM> dynamically grow if
a call to <SAMP>`unput()'</SAMP> results in too much text being pushed
back; instead, a run-time error results.


<P>
Also note that you cannot use <SAMP>`%array'</SAMP> with C++ scanner
classes (the <CODE>c++</CODE> option; see below).




<H2><A NAME="SEC9" HREF="flex.html#TOC9">Actions</A></H2>

<P>
Each pattern in a rule has a corresponding action, which
can be any arbitrary C statement.  The pattern ends at the
first non-escaped whitespace character; the remainder of
the line is its action.  If the action is empty, then when
the pattern is matched the input token is simply
discarded.  For example, here is the specification for a
program which deletes all occurrences of "zap me" from its
input:



<PRE>
%%
"zap me"
</PRE>

<P>
(It will copy all other characters in the input to the
output since they will be matched by the default rule.)


<P>
Here is a program which compresses multiple blanks and
tabs down to a single blank, and throws away whitespace
found at the end of a line:



<PRE>
%%
[ \t]+        putchar( ' ' );
[ \t]+$       /* ignore this token */
</PRE>

<P>
If the action contains a '{', then the action spans till
the balancing '}' is found, and the action may cross
multiple lines.  <CODE>flex</CODE> knows about C strings and comments and
won't be fooled by braces found within them, but also
allows actions to begin with <SAMP>`%{'</SAMP> and will consider the
action to be all the text up to the next <SAMP>`%}'</SAMP> (regardless of
ordinary braces inside the action).


<P>
An action consisting solely of a vertical bar ('|') means
"same as the action for the next rule." See below for an
illustration.


<P>
Actions can include arbitrary C code, including <CODE>return</CODE>
statements to return a value to whatever routine called
<SAMP>`yylex()'</SAMP>.  Each time <SAMP>`yylex()'</SAMP> is called it continues
processing tokens from where it last left off until it either
reaches the end of the file or executes a return.


<P>
Actions are free to modify <CODE>yytext</CODE> except for lengthening
it (adding characters to its end--these will overwrite
later characters in the input stream).  This however does
not apply when using <SAMP>`%array'</SAMP> (see above); in that case,
<CODE>yytext</CODE> may be freely modified in any way.


<P>
Actions are free to modify <CODE>yyleng</CODE> except they should not
do so if the action also includes use of <SAMP>`yymore()'</SAMP> (see
below).


<P>
There are a number of special directives which can be
included within an action:



<UL>
<LI>

<SAMP>`ECHO'</SAMP> copies yytext to the scanner's output.

<LI>

<CODE>BEGIN</CODE> followed by the name of a start condition
places the scanner in the corresponding start
condition (see below).

<LI>

<CODE>REJECT</CODE> directs the scanner to proceed on to the
"second best" rule which matched the input (or a
prefix of the input).  The rule is chosen as
described above in "How the Input is Matched", and
<CODE>yytext</CODE> and <CODE>yyleng</CODE> set up appropriately.  It may
either be one which matched as much text as the
originally chosen rule but came later in the <CODE>flex</CODE>
input file, or one which matched less text.  For
example, the following will both count the words in
the input and call the routine special() whenever
"frob" is seen:


<PRE>
        int word_count = 0;
%%

frob        special(); REJECT;
[^ \t\n]+   ++word_count;
</PRE>

Without the <CODE>REJECT</CODE>, any "frob"'s in the input would
not be counted as words, since the scanner normally
executes only one action per token.  Multiple
<CODE>REJECT's</CODE> are allowed, each one finding the next
best choice to the currently active rule.  For
example, when the following scanner scans the token
"abcd", it will write "abcdabcaba" to the output:


<PRE>
%%
a        |
ab       |
abc      |
abcd     ECHO; REJECT;
.|\n     /* eat up any unmatched character */
</PRE>

(The first three rules share the fourth's action
since they use the special '|' action.)  <CODE>REJECT</CODE> is
a particularly expensive feature in terms of
scanner performance; if it is used in <EM>any</EM> of the
scanner's actions it will slow down <EM>all</EM> of the
scanner's matching.  Furthermore, <CODE>REJECT</CODE> cannot be used
with the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> options (see below).

Note also that unlike the other special actions,
<CODE>REJECT</CODE> is a <EM>branch</EM>; code immediately following it
in the action will <EM>not</EM> be executed.

<LI>

<SAMP>`yymore()'</SAMP> tells the scanner that the next time it
matches a rule, the corresponding token should be
<EM>appended</EM> onto the current value of <CODE>yytext</CODE> rather
than replacing it.  For example, given the input
"mega-kludge" the following will write
"mega-mega-kludge" to the output:


<PRE>
%%
mega-    ECHO; yymore();
kludge   ECHO;
</PRE>

First "mega-" is matched and echoed to the output.
Then "kludge" is matched, but the previous "mega-"
is still hanging around at the beginning of <CODE>yytext</CODE>
so the <SAMP>`ECHO'</SAMP> for the "kludge" rule will actually
write "mega-kludge".
</UL>

<P>
Two notes regarding use of <SAMP>`yymore()'</SAMP>.  First, <SAMP>`yymore()'</SAMP>
depends on the value of <CODE>yyleng</CODE> correctly reflecting the
size of the current token, so you must not modify <CODE>yyleng</CODE>
if you are using <SAMP>`yymore()'</SAMP>.  Second, the presence of
<SAMP>`yymore()'</SAMP> in the scanner's action entails a minor
performance penalty in the scanner's matching speed.



<UL>
<LI>

<SAMP>`yyless(n)'</SAMP> returns all but the first <VAR>n</VAR> characters of
the current token back to the input stream, where
they will be rescanned when the scanner looks for
the next match.  <CODE>yytext</CODE> and <CODE>yyleng</CODE> are adjusted
appropriately (e.g., <CODE>yyleng</CODE> will now be equal to <VAR>n</VAR>
).  For example, on the input "foobar" the
following will write out "foobarbar":


<PRE>
%%
foobar    ECHO; yyless(3);
[a-z]+    ECHO;
</PRE>

An argument of 0 to <CODE>yyless</CODE> will cause the entire
current input string to be scanned again.  Unless
you've changed how the scanner will subsequently
process its input (using <CODE>BEGIN</CODE>, for example), this
will result in an endless loop.

Note that <CODE>yyless</CODE> is a macro and can only be used in the
flex input file, not from other source files.

<LI>

<SAMP>`unput(c)'</SAMP> puts the character <CODE>c</CODE> back onto the input
stream.  It will be the next character scanned.
The following action will take the current token
and cause it to be rescanned enclosed in
parentheses.


<PRE>
{
int i;
/* Copy yytext because unput() trashes yytext */
char *yycopy = strdup( yytext );
unput( ')' );
for ( i = yyleng - 1; i &#62;= 0; --i )
    unput( yycopy[i] );
unput( '(' );
free( yycopy );
}
</PRE>

Note that since each <SAMP>`unput()'</SAMP> puts the given
character back at the <EM>beginning</EM> of the input stream,
pushing back strings must be done back-to-front.
An important potential problem when using <SAMP>`unput()'</SAMP> is that
if you are using <SAMP>`%pointer'</SAMP> (the default), a call to <SAMP>`unput()'</SAMP>
<EM>destroys</EM> the contents of <CODE>yytext</CODE>, starting with its
rightmost character and devouring one character to the left
with each call.  If you need the value of yytext preserved
after a call to <SAMP>`unput()'</SAMP> (as in the above example), you
must either first copy it elsewhere, or build your scanner
using <SAMP>`%array'</SAMP> instead (see How The Input Is Matched).

Finally, note that you cannot put back <CODE>EOF</CODE> to attempt to
mark the input stream with an end-of-file.

<LI>

<SAMP>`input()'</SAMP> reads the next character from the input
stream.  For example, the following is one way to
eat up C comments:


<PRE>
%%
"/*"        {
            register int c;

            for ( ; ; )
                {
                while ( (c = input()) != '*' &#38;&#38;
                        c != EOF )
                    ;    /* eat up text of comment */

                if ( c == '*' )
                    {
                    while ( (c = input()) == '*' )
                        ;
                    if ( c == '/' )
                        break;    /* found the end */
                    }

                if ( c == EOF )
                    {
                    error( "EOF in comment" );
                    break;
                    }
                }
            }
</PRE>

(Note that if the scanner is compiled using <SAMP>`C++'</SAMP>,
then <SAMP>`input()'</SAMP> is instead referred to as <SAMP>`yyinput()'</SAMP>,
in order to avoid a name clash with the <SAMP>`C++'</SAMP> stream
by the name of <CODE>input</CODE>.)

<LI>YY_FLUSH_BUFFER

flushes the scanner's internal buffer so that the next time the scanner
attempts to match a token, it will first refill the buffer using
<CODE>YY_INPUT</CODE> (see The Generated Scanner, below).  This action is
a special case of the more general <SAMP>`yy_flush_buffer()'</SAMP> function,
described below in the section Multiple Input Buffers.

<LI>

<SAMP>`yyterminate()'</SAMP> can be used in lieu of a return
statement in an action.  It terminates the scanner
and returns a 0 to the scanner's caller, indicating
"all done".  By default, <SAMP>`yyterminate()'</SAMP> is also
called when an end-of-file is encountered.  It is a
macro and may be redefined.
</UL>



<H2><A NAME="SEC10" HREF="flex.html#TOC10">The generated scanner</A></H2>

<P>
The output of <CODE>flex</CODE> is the file <TT>`lex.yy.c'</TT>, which contains
the scanning routine <SAMP>`yylex()'</SAMP>, a number of tables used by
it for matching tokens, and a number of auxiliary routines
and macros.  By default, <SAMP>`yylex()'</SAMP> is declared as follows:



<PRE>
int yylex()
    {
    ... various definitions and the actions in here ...
    }
</PRE>

<P>
(If your environment supports function prototypes, then it
will be "int yylex( void  )".)   This  definition  may  be
changed by defining the "YY_DECL" macro.  For example, you
could use:



<PRE>
#define YY_DECL float lexscan( a, b ) float a, b;
</PRE>

<P>
to give the scanning routine the name <CODE>lexscan</CODE>, returning a
float, and taking two floats as arguments.  Note that if
you give arguments to the scanning routine using a
K&#38;R-style/non-prototyped function declaration, you must
terminate the definition with a semi-colon (<SAMP>`;'</SAMP>).


<P>
Whenever <SAMP>`yylex()'</SAMP> is called, it scans tokens from the
global input file <CODE>yyin</CODE> (which defaults to stdin).  It
continues until it either reaches an end-of-file (at which
point it returns the value 0) or one of its actions
executes a <CODE>return</CODE> statement.


<P>
If the scanner reaches an end-of-file, subsequent calls are undefined
unless either <CODE>yyin</CODE> is pointed at a new input file (in which case
scanning continues from that file), or <SAMP>`yyrestart()'</SAMP> is called.
<SAMP>`yyrestart()'</SAMP> takes one argument, a <SAMP>`FILE *'</SAMP> pointer (which
can be nil, if you've set up <CODE>YY_INPUT</CODE> to scan from a source
other than <CODE>yyin</CODE>), and initializes <CODE>yyin</CODE> for scanning from
that file.  Essentially there is no difference between just assigning
<CODE>yyin</CODE> to a new input file or using <SAMP>`yyrestart()'</SAMP> to do so;
the latter is available for compatibility with previous versions of
<CODE>flex</CODE>, and because it can be used to switch input files in the
middle of scanning.  It can also be used to throw away the current
input buffer, by calling it with an argument of <CODE>yyin</CODE>; but
better is to use <CODE>YY_FLUSH_BUFFER</CODE> (see above).  Note that
<SAMP>`yyrestart()'</SAMP> does <EM>not</EM> reset the start condition to
<CODE>INITIAL</CODE> (see Start Conditions, below).


<P>
If <SAMP>`yylex()'</SAMP> stops scanning due to executing a <CODE>return</CODE>
statement in one of the actions, the scanner may then be called
again and it will resume scanning where it left off.


<P>
By default (and for purposes of efficiency), the scanner
uses block-reads rather than simple <SAMP>`getc()'</SAMP> calls to read
characters from <CODE>yyin</CODE>.  The nature of how it gets its input
can be controlled by defining the <CODE>YY_INPUT</CODE> macro.
YY_INPUT's calling sequence is
"YY_INPUT(buf,result,max_size)".  Its action is to place
up to <VAR>max_size</VAR> characters in the character array <VAR>buf</VAR> and
return in the integer variable <VAR>result</VAR> either the number of
characters read or the constant YY_NULL (0 on Unix
systems) to indicate EOF.  The default YY_INPUT reads from
the global file-pointer "yyin".


<P>
A sample definition of YY_INPUT (in the definitions
section of the input file):



<PRE>
%{
#define YY_INPUT(buf,result,max_size) \
    { \
    int c = getchar(); \
    result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
    }
%}
</PRE>

<P>
This definition will change the input processing to occur
one character at a time.


<P>
When the scanner receives an end-of-file indication from
YY_INPUT, it then checks the <SAMP>`yywrap()'</SAMP> function.  If
<SAMP>`yywrap()'</SAMP> returns false (zero), then it is assumed that the
function has gone ahead and set up <CODE>yyin</CODE> to point to
another input file, and scanning continues.  If it returns
true (non-zero), then the scanner terminates, returning 0
to its caller.  Note that in either case, the start
condition remains unchanged; it does <EM>not</EM> revert to <CODE>INITIAL</CODE>.


<P>
If you do not supply your own version of <SAMP>`yywrap()'</SAMP>, then you
must either use <SAMP>`%option noyywrap'</SAMP> (in which case the scanner
behaves as though <SAMP>`yywrap()'</SAMP> returned 1), or you must link with
<SAMP>`-lfl'</SAMP> to obtain the default version of the routine, which always
returns 1.


<P>
Three routines are available for scanning from in-memory
buffers rather than files: <SAMP>`yy_scan_string()'</SAMP>,
<SAMP>`yy_scan_bytes()'</SAMP>, and <SAMP>`yy_scan_buffer()'</SAMP>.  See the discussion
of them below in the section Multiple Input Buffers.


<P>
The scanner writes its <SAMP>`ECHO'</SAMP> output to the <CODE>yyout</CODE> global
(default, stdout), which may be redefined by the user
simply by assigning it to some other <CODE>FILE</CODE> pointer.




<H2><A NAME="SEC11" HREF="flex.html#TOC11">Start conditions</A></H2>

<P>
<CODE>flex</CODE> provides a mechanism for conditionally activating
rules.  Any rule whose pattern is prefixed with "&#60;sc&#62;"
will only be active when the scanner is in the start
condition named "sc".  For example,



<PRE>
&#60;STRING&#62;[^"]*        { /* eat up the string body ... */
            ...
            }
</PRE>

<P>
will be active only when the scanner is in the "STRING"
start condition, and



<PRE>
&#60;INITIAL,STRING,QUOTE&#62;\.        { /* handle an escape ... */
            ...
            }
</PRE>

<P>
will be active only when the current start condition is
either "INITIAL", "STRING", or "QUOTE".


<P>
Start conditions are declared in the definitions (first)
section of the input using unindented lines beginning with
either <SAMP>`%s'</SAMP> or <SAMP>`%x'</SAMP> followed by a list of names.  The former
declares <EM>inclusive</EM> start conditions, the latter <EM>exclusive</EM>
start conditions.  A start condition is activated using
the <CODE>BEGIN</CODE> action.  Until the next <CODE>BEGIN</CODE> action is
executed, rules with the given start condition will be active
and rules with other start conditions will be inactive.
If the start condition is <EM>inclusive</EM>, then rules with no
start conditions at all will also be active.  If it is
<EM>exclusive</EM>, then <EM>only</EM> rules qualified with the start
condition will be active.  A set of rules contingent on the
same exclusive start condition describe a scanner which is
independent of any of the other rules in the <CODE>flex</CODE> input.
Because of this, exclusive start conditions make it easy
to specify "mini-scanners" which scan portions of the
input that are syntactically different from the rest
(e.g., comments).


<P>
If the distinction between inclusive and exclusive start
conditions is still a little vague, here's a simple
example illustrating the connection between the two.  The set
of rules:



<PRE>
%s example
%%

&#60;example&#62;foo   do_something();

bar            something_else();
</PRE>

<P>
is equivalent to



<PRE>
%x example
%%

&#60;example&#62;foo   do_something();

&#60;INITIAL,example&#62;bar    something_else();
</PRE>

<P>
Without the <SAMP>`&#60;INITIAL,example&#62;'</SAMP> qualifier, the <SAMP>`bar'</SAMP> pattern
in the second example wouldn't be active (i.e., couldn't match) when
in start condition <SAMP>`example'</SAMP>.  If we just used <SAMP>`&#60;example&#62;'</SAMP>
to qualify <SAMP>`bar'</SAMP>, though, then it would only be active in
<SAMP>`example'</SAMP> and not in <CODE>INITIAL</CODE>, while in the first example
it's active in both, because in the first example the <SAMP>`example'</SAMP>
starting condition is an <EM>inclusive</EM> (<SAMP>`%s'</SAMP>) start condition.


<P>
Also note that the special start-condition specifier <SAMP>`&#60;*&#62;'</SAMP>
matches every start condition.  Thus, the above example
could also have been written;



<PRE>
%x example
%%

&#60;example&#62;foo   do_something();

&#60;*&#62;bar    something_else();
</PRE>

<P>
The default rule (to <SAMP>`ECHO'</SAMP> any unmatched character) remains
active in start conditions.  It is equivalent to:



<PRE>
&#60;*&#62;.|\\n     ECHO;
</PRE>

<P>
<SAMP>`BEGIN(0)'</SAMP> returns to the original state where only the
rules with no start conditions are active.  This state can
also be referred to as the start-condition "INITIAL", so
<SAMP>`BEGIN(INITIAL)'</SAMP> is equivalent to <SAMP>`BEGIN(0)'</SAMP>.  (The
parentheses around the start condition name are not required but
are considered good style.)


<P>
<CODE>BEGIN</CODE> actions can also be given as indented code at the
beginning of the rules section.  For example, the
following will cause the scanner to enter the "SPECIAL" start
condition whenever <SAMP>`yylex()'</SAMP> is called and the global
variable <CODE>enter_special</CODE> is true:



<PRE>
        int enter_special;

%x SPECIAL
%%
        if ( enter_special )
            BEGIN(SPECIAL);

&#60;SPECIAL&#62;blahblahblah
...more rules follow...
</PRE>

<P>
To illustrate the uses of start conditions, here is a
scanner which provides two different interpretations of a
string like "123.456".  By default it will treat it as as
three tokens, the integer "123", a dot ('.'), and the
integer "456".  But if the string is preceded earlier in
the line by the string "expect-floats" it will treat it as
a single token, the floating-point number 123.456:



<PRE>
%{
#include &#60;math.h&#62;
%}
%s expect

%%
expect-floats        BEGIN(expect);

&#60;expect&#62;[0-9]+"."[0-9]+      {
            printf( "found a float, = %f\n",
                    atof( yytext ) );
            }
&#60;expect&#62;\n           {
            /* that's the end of the line, so
             * we need another "expect-number"
             * before we'll recognize any more
             * numbers
             */
            BEGIN(INITIAL);
            }

[0-9]+      {

Version 2.5               December 1994                        18

            printf( "found an integer, = %d\n",
                    atoi( yytext ) );
            }

"."         printf( "found a dot\n" );
</PRE>

<P>
Here is a scanner which recognizes (and discards) C
comments while maintaining a count of the current input line.



<PRE>
%x comment
%%
        int line_num = 1;

"/*"         BEGIN(comment);

&#60;comment&#62;[^*\n]*        /* eat anything that's not a '*' */
&#60;comment&#62;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&#60;comment&#62;\n             ++line_num;
&#60;comment&#62;"*"+"/"        BEGIN(INITIAL);
</PRE>

<P>
This scanner goes to a bit of trouble to match as much
text as possible with each rule.  In general, when
attempting to write a high-speed scanner try to match as
much possible in each rule, as it's a big win.


<P>
Note that start-conditions names are really integer values
and can be stored as such.  Thus, the above could be
extended in the following fashion:



<PRE>
%x comment foo
%%
        int line_num = 1;
        int comment_caller;

"/*"         {
             comment_caller = INITIAL;
             BEGIN(comment);
             }

...

&#60;foo&#62;"/*"    {
             comment_caller = foo;
             BEGIN(comment);
             }

&#60;comment&#62;[^*\n]*        /* eat anything that's not a '*' */
&#60;comment&#62;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&#60;comment&#62;\n             ++line_num;
&#60;comment&#62;"*"+"/"        BEGIN(comment_caller);
</PRE>

<P>
Furthermore, you can access the current start condition
using the integer-valued <CODE>YY_START</CODE> macro.  For example, the
above assignments to <CODE>comment_caller</CODE> could instead be
written



<PRE>
comment_caller = YY_START;
</PRE>

<P>
Flex provides <CODE>YYSTATE</CODE> as an alias for <CODE>YY_START</CODE> (since that
is what's used by AT&#38;T <CODE>lex</CODE>).


<P>
Note that start conditions do not have their own
name-space; %s's and %x's declare names in the same fashion as
#define's.


<P>
Finally, here's an example of how to match C-style quoted
strings using exclusive start conditions, including
expanded escape sequences (but not including checking for
a string that's too long):



<PRE>
%x str

%%
        char string_buf[MAX_STR_CONST];
        char *string_buf_ptr;

\"      string_buf_ptr = string_buf; BEGIN(str);

&#60;str&#62;\"        { /* saw closing quote - all done */
        BEGIN(INITIAL);
        *string_buf_ptr = '\0';
        /* return string constant token type and
         * value to parser
         */
        }

&#60;str&#62;\n        {
        /* error - unterminated string constant */
        /* generate error message */
        }

&#60;str&#62;\\[0-7]{1,3} {
        /* octal escape sequence */
        int result;

        (void) sscanf( yytext + 1, "%o", &#38;result );

        if ( result &#62; 0xff )
                /* error, constant is out-of-bounds */

        *string_buf_ptr++ = result;
        }

&#60;str&#62;\\[0-9]+ {
        /* generate error - bad escape sequence; something
         * like '\48' or '\0777777'
         */
        }

&#60;str&#62;\\n  *string_buf_ptr++ = '\n';
&#60;str&#62;\\t  *string_buf_ptr++ = '\t';
&#60;str&#62;\\r  *string_buf_ptr++ = '\r';
&#60;str&#62;\\b  *string_buf_ptr++ = '\b';
&#60;str&#62;\\f  *string_buf_ptr++ = '\f';

&#60;str&#62;\\(.|\n)  *string_buf_ptr++ = yytext[1];

&#60;str&#62;[^\\\n\"]+        {
        char *yptr = yytext;

        while ( *yptr )
                *string_buf_ptr++ = *yptr++;
        }
</PRE>

<P>
Often, such as in some of the examples above, you wind up
writing a whole bunch of rules all preceded by the same
start condition(s).  Flex makes this a little easier and
cleaner by introducing a notion of start condition <EM>scope</EM>.
A start condition scope is begun with:



<PRE>
&#60;SCs&#62;{
</PRE>

<P>
where SCs is a list of one or more start conditions.
Inside the start condition scope, every rule automatically
has the prefix <SAMP>`&#60;SCs&#62;'</SAMP> applied to it, until a <SAMP>`}'</SAMP> which
matches the initial <SAMP>`{'</SAMP>.  So, for example,



<PRE>
&#60;ESC&#62;{
    "\\n"   return '\n';
    "\\r"   return '\r';
    "\\f"   return '\f';
    "\\0"   return '\0';
}
</PRE>

<P>
is equivalent to:



<PRE>
&#60;ESC&#62;"\\n"  return '\n';
&#60;ESC&#62;"\\r"  return '\r';
&#60;ESC&#62;"\\f"  return '\f';
&#60;ESC&#62;"\\0"  return '\0';
</PRE>

<P>
Start condition scopes may be nested.


<P>
Three routines are available for manipulating stacks of
start conditions:


<DL COMPACT>

<DT><SAMP>`void yy_push_state(int new_state)'</SAMP>
<DD>
pushes the current start condition onto the top of
the start condition stack and switches to <VAR>new_state</VAR>
as though you had used <SAMP>`BEGIN new_state'</SAMP> (recall that
start condition names are also integers).

<DT><SAMP>`void yy_pop_state()'</SAMP>
<DD>
pops the top of the stack and switches to it via
<CODE>BEGIN</CODE>.

<DT><SAMP>`int yy_top_state()'</SAMP>
<DD>
returns the top of the stack without altering the
stack's contents.
</DL>

<P>
The start condition stack grows dynamically and so has no
built-in size limitation.  If memory is exhausted, program
execution aborts.


<P>
To use start condition stacks, your scanner must include a
<SAMP>`%option stack'</SAMP> directive (see Options below).




<H2><A NAME="SEC12" HREF="flex.html#TOC12">Multiple input buffers</A></H2>

<P>
Some scanners (such as those which support "include"
files) require reading from several input streams.  As
<CODE>flex</CODE> scanners do a large amount of buffering, one cannot
control where the next input will be read from by simply
writing a <CODE>YY_INPUT</CODE> which is sensitive to the scanning
context.  <CODE>YY_INPUT</CODE> is only called when the scanner reaches
the end of its buffer, which may be a long time after
scanning a statement such as an "include" which requires
switching the input source.


<P>
To negotiate these sorts of problems, <CODE>flex</CODE> provides a
mechanism for creating and switching between multiple
input buffers.  An input buffer is created by using:



<PRE>
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
</PRE>

<P>
which takes a <CODE>FILE</CODE> pointer and a size and creates a buffer
associated with the given file and large enough to hold
<VAR>size</VAR> characters (when in doubt, use <CODE>YY_BUF_SIZE</CODE> for the
size).  It returns a <CODE>YY_BUFFER_STATE</CODE> handle, which may
then be passed to other routines (see below).  The
<CODE>YY_BUFFER_STATE</CODE> type is a pointer to an opaque <CODE>struct</CODE>
<CODE>yy_buffer_state</CODE> structure, so you may safely initialize
YY_BUFFER_STATE variables to <SAMP>`((YY_BUFFER_STATE) 0)'</SAMP> if you
wish, and also refer to the opaque structure in order to
correctly declare input buffers in source files other than
that of your scanner.  Note that the <CODE>FILE</CODE> pointer in the
call to <CODE>yy_create_buffer</CODE> is only used as the value of <CODE>yyin</CODE>
seen by <CODE>YY_INPUT</CODE>; if you redefine <CODE>YY_INPUT</CODE> so it no longer
uses <CODE>yyin</CODE>, then you can safely pass a nil <CODE>FILE</CODE> pointer to
<CODE>yy_create_buffer</CODE>.  You select a particular buffer to scan
from using:



<PRE>
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
</PRE>

<P>
switches the scanner's input buffer so subsequent tokens
will come from <VAR>new_buffer</VAR>.  Note that
<SAMP>`yy_switch_to_buffer()'</SAMP> may be used by <SAMP>`yywrap()'</SAMP> to set
things up for continued scanning, instead of opening a new
file and pointing <CODE>yyin</CODE> at it.  Note also that switching
input sources via either <SAMP>`yy_switch_to_buffer()'</SAMP> or <SAMP>`yywrap()'</SAMP>
does <EM>not</EM> change the start condition.



<PRE>
void yy_delete_buffer( YY_BUFFER_STATE buffer )
</PRE>

<P>
is used to reclaim the storage associated with a buffer.
You can also clear the current contents of a buffer using:



<PRE>
void yy_flush_buffer( YY_BUFFER_STATE buffer )
</PRE>

<P>
This function discards the buffer's contents, so the next time the
scanner attempts to match a token from the buffer, it will first fill
the buffer anew using <CODE>YY_INPUT</CODE>.


<P>
<SAMP>`yy_new_buffer()'</SAMP> is an alias for <SAMP>`yy_create_buffer()'</SAMP>,
provided for compatibility with the C++ use of <CODE>new</CODE> and <CODE>delete</CODE>
for creating and destroying dynamic objects.


<P>
Finally, the <CODE>YY_CURRENT_BUFFER</CODE> macro returns a
<CODE>YY_BUFFER_STATE</CODE> handle to the current buffer.


<P>
Here is an example of using these features for writing a
scanner which expands include files (the <SAMP>`&#60;&#60;EOF&#62;&#62;'</SAMP> feature
is discussed below):



<PRE>
/* the "incl" state is used for picking up the name
 * of an include file
 */
%x incl

%{
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr = 0;
%}

%%
include             BEGIN(incl);

[a-z]+              ECHO;
[^a-z\n]*\n?        ECHO;

&#60;incl&#62;[ \t]*      /* eat the whitespace */
&#60;incl&#62;[^ \t\n]+   { /* got the include file name */
        if ( include_stack_ptr &#62;= MAX_INCLUDE_DEPTH )
            {
            fprintf( stderr, "Includes nested too deeply" );
            exit( 1 );
            }

        include_stack[include_stack_ptr++] =
            YY_CURRENT_BUFFER;

        yyin = fopen( yytext, "r" );

        if ( ! yyin )
            error( ... );

        yy_switch_to_buffer(
            yy_create_buffer( yyin, YY_BUF_SIZE ) );

        BEGIN(INITIAL);
        }

&#60;&#60;EOF&#62;&#62; {
        if ( --include_stack_ptr &#60; 0 )
            {
            yyterminate();
            }

        else
            {
            yy_delete_buffer( YY_CURRENT_BUFFER );
            yy_switch_to_buffer(
                 include_stack[include_stack_ptr] );
            }
        }
</PRE>

<P>
Three routines are available for setting up input buffers
for scanning in-memory strings instead of files.  All of
them create a new input buffer for scanning the string,
and return a corresponding <CODE>YY_BUFFER_STATE</CODE> handle (which
you should delete with <SAMP>`yy_delete_buffer()'</SAMP> when done with
it).  They also switch to the new buffer using
<SAMP>`yy_switch_to_buffer()'</SAMP>, so the next call to <SAMP>`yylex()'</SAMP> will
start scanning the string.


<DL COMPACT>

<DT><SAMP>`yy_scan_string(const char *str)'</SAMP>
<DD>
scans a NUL-terminated string.

<DT><SAMP>`yy_scan_bytes(const char *bytes, int len)'</SAMP>
<DD>
scans <CODE>len</CODE> bytes (including possibly NUL's) starting
at location <VAR>bytes</VAR>.
</DL>

<P>
Note that both of these functions create and scan a <EM>copy</EM>
of the string or bytes.  (This may be desirable, since
<SAMP>`yylex()'</SAMP> modifies the contents of the buffer it is
scanning.) You can avoid the copy by using:


<DL COMPACT>

<DT><SAMP>`yy_scan_buffer(char *base, yy_size_t size)'</SAMP>
<DD>
which scans in place the buffer starting at <VAR>base</VAR>,
consisting of <VAR>size</VAR> bytes, the last two bytes of
which <EM>must</EM> be <CODE>YY_END_OF_BUFFER_CHAR</CODE> (ASCII NUL).
These last two bytes are not scanned; thus,
scanning consists of <SAMP>`base[0]'</SAMP> through <SAMP>`base[size-2]'</SAMP>,
inclusive.

If you fail to set up <VAR>base</VAR> in this manner (i.e.,
forget the final two <CODE>YY_END_OF_BUFFER_CHAR</CODE> bytes),
then <SAMP>`yy_scan_buffer()'</SAMP> returns a nil pointer instead
of creating a new input buffer.

The type <CODE>yy_size_t</CODE> is an integral type to which you
can cast an integer expression reflecting the size
of the buffer.
</DL>



<H2><A NAME="SEC13" HREF="flex.html#TOC13">End-of-file rules</A></H2>

<P>
The special rule "&#60;&#60;EOF&#62;&#62;" indicates actions which are to
be taken when an end-of-file is encountered and yywrap()
returns non-zero (i.e., indicates no further files to
process).  The action must finish by doing one of four
things:



<UL>
<LI>

assigning <CODE>yyin</CODE> to a new input file (in previous
versions of flex, after doing the assignment you
had to call the special action <CODE>YY_NEW_FILE</CODE>; this is
no longer necessary);

<LI>

executing a <CODE>return</CODE> statement;

<LI>

executing the special <SAMP>`yyterminate()'</SAMP> action;

<LI>

or, switching to a new buffer using
<SAMP>`yy_switch_to_buffer()'</SAMP> as shown in the example
above.
</UL>

<P>
&#60;&#60;EOF&#62;&#62; rules may not be used with other patterns; they
may only be qualified with a list of start conditions.  If
an unqualified &#60;&#60;EOF&#62;&#62; rule is given, it applies to <EM>all</EM>
start conditions which do not already have &#60;&#60;EOF&#62;&#62;
actions.  To specify an &#60;&#60;EOF&#62;&#62; rule for only the initial
start condition, use



<PRE>
&#60;INITIAL&#62;&#60;&#60;EOF&#62;&#62;
</PRE>

<P>
These rules are useful for catching things like unclosed
comments.  An example:



<PRE>
%x quote
%%

...other rules for dealing with quotes...

&#60;quote&#62;&#60;&#60;EOF&#62;&#62;   {
         error( "unterminated quote" );
         yyterminate();
         }
&#60;&#60;EOF&#62;&#62;  {
         if ( *++filelist )
             yyin = fopen( *filelist, "r" );
         else
            yyterminate();
         }
</PRE>



<H2><A NAME="SEC14" HREF="flex.html#TOC14">Miscellaneous macros</A></H2>

<P>
The macro <CODE>YY_USER_ACTION</CODE> can be defined to provide an
action which is always executed prior to the matched
rule's action.  For example, it could be #define'd to call
a routine to convert yytext to lower-case.  When
<CODE>YY_USER_ACTION</CODE> is invoked, the variable <CODE>yy_act</CODE> gives the
number of the matched rule (rules are numbered starting
with 1).  Suppose you want to profile how often each of
your rules is matched.  The following would do the trick:



<PRE>
#define YY_USER_ACTION ++ctr[yy_act]
</PRE>

<P>
where <CODE>ctr</CODE> is an array to hold the counts for the different
rules.  Note that the macro <CODE>YY_NUM_RULES</CODE> gives the total number
of rules (including the default rule, even if you use <SAMP>`-s'</SAMP>, so
a correct declaration for <CODE>ctr</CODE> is:



<PRE>
int ctr[YY_NUM_RULES];
</PRE>

<P>
The macro <CODE>YY_USER_INIT</CODE> may be defined to provide an action
which is always executed before the first scan (and before
the scanner's internal initializations are done).  For
example, it could be used to call a routine to read in a
data table or open a logging file.


<P>
The macro <SAMP>`yy_set_interactive(is_interactive)'</SAMP> can be used
to control whether the current buffer is considered
<EM>interactive</EM>.  An interactive buffer is processed more slowly,
but must be used when the scanner's input source is indeed
interactive to avoid problems due to waiting to fill
buffers (see the discussion of the <SAMP>`-I'</SAMP> flag below).  A
non-zero value in the macro invocation marks the buffer as
interactive, a zero value as non-interactive.  Note that
use of this macro overrides <SAMP>`%option always-interactive'</SAMP> or
<SAMP>`%option never-interactive'</SAMP> (see Options below).
<SAMP>`yy_set_interactive()'</SAMP> must be invoked prior to beginning to
scan the buffer that is (or is not) to be considered
interactive.


<P>
The macro <SAMP>`yy_set_bol(at_bol)'</SAMP> can be used to control
whether the current buffer's scanning context for the next
token match is done as though at the beginning of a line.
A non-zero macro argument makes rules anchored with


<P>
The macro <SAMP>`YY_AT_BOL()'</SAMP> returns true if the next token
scanned from the current buffer will have '^' rules
active, false otherwise.


<P>
In the generated scanner, the actions are all gathered in
one large switch statement and separated using <CODE>YY_BREAK</CODE>,
which may be redefined.  By default, it is simply a
"break", to separate each rule's action from the following
rule's.  Redefining <CODE>YY_BREAK</CODE> allows, for example, C++
users to #define YY_BREAK to do nothing (while being very
careful that every rule ends with a "break" or a
"return"!) to avoid suffering from unreachable statement
warnings where because a rule's action ends with "return",
the <CODE>YY_BREAK</CODE> is inaccessible.




<H2><A NAME="SEC15" HREF="flex.html#TOC15">Values available to the user</A></H2>

<P>
This section summarizes the various values available to
the user in the rule actions.



<UL>
<LI>

<SAMP>`char *yytext'</SAMP> holds the text of the current token.
It may be modified but not lengthened (you cannot
append characters to the end).

If the special directive <SAMP>`%array'</SAMP> appears in the
first section of the scanner description, then
<CODE>yytext</CODE> is instead declared <SAMP>`char yytext[YYLMAX]'</SAMP>,
where <CODE>YYLMAX</CODE> is a macro definition that you can
redefine in the first section if you don't like the
default value (generally 8KB).  Using <SAMP>`%array'</SAMP>
results in somewhat slower scanners, but the value
of <CODE>yytext</CODE> becomes immune to calls to <SAMP>`input()'</SAMP> and
<SAMP>`unput()'</SAMP>, which potentially destroy its value when
<CODE>yytext</CODE> is a character pointer.  The opposite of
<SAMP>`%array'</SAMP> is <SAMP>`%pointer'</SAMP>, which is the default.

You cannot use <SAMP>`%array'</SAMP> when generating C++ scanner
classes (the <SAMP>`-+'</SAMP> flag).

<LI>

<SAMP>`int yyleng'</SAMP> holds the length of the current token.

<LI>

<SAMP>`FILE *yyin'</SAMP> is the file which by default <CODE>flex</CODE> reads
from.  It may be redefined but doing so only makes
sense before scanning begins or after an EOF has
been encountered.  Changing it in the midst of
scanning will have unexpected results since <CODE>flex</CODE>
buffers its input; use <SAMP>`yyrestart()'</SAMP> instead.  Once
scanning terminates because an end-of-file has been
seen, you can assign <CODE>yyin</CODE> at the new input file and
then call the scanner again to continue scanning.

<LI>

<SAMP>`void yyrestart( FILE *new_file )'</SAMP> may be called to
point <CODE>yyin</CODE> at the new input file.  The switch-over
to the new file is immediate (any previously
buffered-up input is lost).  Note that calling
<SAMP>`yyrestart()'</SAMP> with <CODE>yyin</CODE> as an argument thus throws
away the current input buffer and continues
scanning the same input file.

<LI>

<SAMP>`FILE *yyout'</SAMP> is the file to which <SAMP>`ECHO'</SAMP> actions are
done.  It can be reassigned by the user.

<LI>

<CODE>YY_CURRENT_BUFFER</CODE> returns a <CODE>YY_BUFFER_STATE</CODE> handle
to the current buffer.

<LI>

<CODE>YY_START</CODE> returns an integer value corresponding to
the current start condition.  You can subsequently
use this value with <CODE>BEGIN</CODE> to return to that start
condition.
</UL>



<H2><A NAME="SEC16" HREF="flex.html#TOC16">Interfacing with <CODE>yacc</CODE></A></H2>

<P>
One of the main uses of <CODE>flex</CODE> is as a companion to the <CODE>yacc</CODE>
parser-generator.  <CODE>yacc</CODE> parsers expect to call a routine
named <SAMP>`yylex()'</SAMP> to find the next input token.  The routine
is supposed to return the type of the next token as well
as putting any associated value in the global <CODE>yylval</CODE>.  To
use <CODE>flex</CODE> with <CODE>yacc</CODE>, one specifies the <SAMP>`-d'</SAMP> option to <CODE>yacc</CODE> to
instruct it to generate the file <TT>`y.tab.h'</TT> containing
definitions of all the <SAMP>`%tokens'</SAMP> appearing in the <CODE>yacc</CODE> input.
This file is then included in the <CODE>flex</CODE> scanner.  For
example, if one of the tokens is "TOK_NUMBER", part of the
scanner might look like:



<PRE>
%{
#include "y.tab.h"
%}

%%

[0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
</PRE>



<H2><A NAME="SEC17" HREF="flex.html#TOC17">Options</A></H2>
<P>
<CODE>flex</CODE> has the following options:


<DL COMPACT>

<DT><SAMP>`-b'</SAMP>
<DD>
Generate backing-up information to <TT>`lex.backup'</TT>.
This is a list of scanner states which require
backing up and the input characters on which they
do so.  By adding rules one can remove backing-up
states.  If <EM>all</EM> backing-up states are eliminated
and <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> is used, the generated scanner will
run faster (see the <SAMP>`-p'</SAMP> flag).  Only users who wish
to squeeze every last cycle out of their scanners
need worry about this option.  (See the section on
Performance Considerations below.)

<DT><SAMP>`-c'</SAMP>
<DD>
is a do-nothing, deprecated option included for
POSIX compliance.

<DT><SAMP>`-d'</SAMP>
<DD>
makes the generated scanner run in <EM>debug</EM> mode.
Whenever a pattern is recognized and the global
<CODE>yy_flex_debug</CODE> is non-zero (which is the default),
the scanner will write to <CODE>stderr</CODE> a line of the
form:


<PRE>
--accepting rule at line 53 ("the matched text")
</PRE>

The line number refers to the location of the rule
in the file defining the scanner (i.e., the file
that was fed to flex).  Messages are also generated
when the scanner backs up, accepts the default
rule, reaches the end of its input buffer (or
encounters a NUL; at this point, the two look the
same as far as the scanner's concerned), or reaches
an end-of-file.

<DT><SAMP>`-f'</SAMP>
<DD>
specifies <EM>fast scanner</EM>.  No table compression is
done and stdio is bypassed.  The result is large
but fast.  This option is equivalent to <SAMP>`-Cfr'</SAMP> (see
below).

<DT><SAMP>`-h'</SAMP>
<DD>
generates a "help" summary of <CODE>flex's</CODE> options to
<CODE>stdout</CODE> and then exits.  <SAMP>`-?'</SAMP> and <SAMP>`--help'</SAMP> are synonyms
for <SAMP>`-h'</SAMP>.

<DT><SAMP>`-i'</SAMP>
<DD>
instructs <CODE>flex</CODE> to generate a <EM>case-insensitive</EM>
scanner.  The case of letters given in the <CODE>flex</CODE> input
patterns will be ignored, and tokens in the input
will be matched regardless of case.  The matched
text given in <CODE>yytext</CODE> will have the preserved case
(i.e., it will not be folded).

<DT><SAMP>`-l'</SAMP>
<DD>
turns on maximum compatibility with the original
AT&#38;T <CODE>lex</CODE> implementation.  Note that this does not
mean <EM>full</EM> compatibility.  Use of this option costs
a considerable amount of performance, and it cannot
be used with the <SAMP>`-+, -f, -F, -Cf'</SAMP>, or <SAMP>`-CF'</SAMP> options.
For details on the compatibilities it provides, see
the section "Incompatibilities With Lex And POSIX"
below.  This option also results in the name
<CODE>YY_FLEX_LEX_COMPAT</CODE> being #define'd in the generated
scanner.

<DT><SAMP>`-n'</SAMP>
<DD>
is another do-nothing, deprecated option included
only for POSIX compliance.

<DT><SAMP>`-p'</SAMP>
<DD>
generates a performance report to stderr.  The
report consists of comments regarding features of
the <CODE>flex</CODE> input file which will cause a serious loss
of performance in the resulting scanner.  If you
give the flag twice, you will also get comments
regarding features that lead to minor performance
losses.

Note that the use of <CODE>REJECT</CODE>, <SAMP>`%option yylineno'</SAMP> and
variable trailing context (see the Deficiencies / Bugs section below)
entails a substantial performance penalty; use of <SAMP>`yymore()'</SAMP>,
the <SAMP>`^'</SAMP> operator, and the <SAMP>`-I'</SAMP> flag entail minor performance
penalties.

<DT><SAMP>`-s'</SAMP>
<DD>
causes the <EM>default rule</EM> (that unmatched scanner
input is echoed to <CODE>stdout</CODE>) to be suppressed.  If
the scanner encounters input that does not match
any of its rules, it aborts with an error.  This
option is useful for finding holes in a scanner's
rule set.

<DT><SAMP>`-t'</SAMP>
<DD>
instructs <CODE>flex</CODE> to write the scanner it generates to
standard output instead of <TT>`lex.yy.c'</TT>.

<DT><SAMP>`-v'</SAMP>
<DD>
specifies that <CODE>flex</CODE> should write to <CODE>stderr</CODE> a
summary of statistics regarding the scanner it
generates.  Most of the statistics are meaningless to
the casual <CODE>flex</CODE> user, but the first line identifies
the version of <CODE>flex</CODE> (same as reported by <SAMP>`-V'</SAMP>), and
the next line the flags used when generating the
scanner, including those that are on by default.

<DT><SAMP>`-w'</SAMP>
<DD>
suppresses warning messages.

<DT><SAMP>`-B'</SAMP>
<DD>
instructs <CODE>flex</CODE> to generate a <EM>batch</EM> scanner, the
opposite of <EM>interactive</EM> scanners generated by <SAMP>`-I'</SAMP>
(see below).  In general, you use <SAMP>`-B'</SAMP> when you are
<EM>certain</EM> that your scanner will never be used
interactively, and you want to squeeze a <EM>little</EM> more
performance out of it.  If your goal is instead to
squeeze out a <EM>lot</EM> more performance, you should be
using the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> options (discussed below),
which turn on <SAMP>`-B'</SAMP> automatically anyway.

<DT><SAMP>`-F'</SAMP>
<DD>
specifies that the <EM>fast</EM> scanner table
representation should be used (and stdio bypassed).  This
representation is about as fast as the full table
representation <SAMP>`(-f)'</SAMP>, and for some sets of patterns
will be considerably smaller (and for others,
larger).  In general, if the pattern set contains
both "keywords" and a catch-all, "identifier" rule,
such as in the set:


<PRE>
"case"    return TOK_CASE;
"switch"  return TOK_SWITCH;
...
"default" return TOK_DEFAULT;
[a-z]+    return TOK_ID;
</PRE>

then you're better off using the full table
representation.  If only the "identifier" rule is
present and you then use a hash table or some such to
detect the keywords, you're better off using <SAMP>`-F'</SAMP>.

This option is equivalent to <SAMP>`-CFr'</SAMP> (see below).  It
cannot be used with <SAMP>`-+'</SAMP>.

<DT><SAMP>`-I'</SAMP>
<DD>
instructs <CODE>flex</CODE> to generate an <EM>interactive</EM> scanner.
An interactive scanner is one that only looks ahead
to decide what token has been matched if it
absolutely must.  It turns out that always looking one
extra character ahead, even if the scanner has
already seen enough text to disambiguate the
current token, is a bit faster than only looking ahead
when necessary.  But scanners that always look
ahead give dreadful interactive performance; for
example, when a user types a newline, it is not
recognized as a newline token until they enter
<EM>another</EM> token, which often means typing in another
whole line.

<CODE>Flex</CODE> scanners default to <EM>interactive</EM> unless you use
the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> table-compression options (see
below).  That's because if you're looking for
high-performance you should be using one of these
options, so if you didn't, <CODE>flex</CODE> assumes you'd
rather trade off a bit of run-time performance for
intuitive interactive behavior.  Note also that you
<EM>cannot</EM> use <SAMP>`-I'</SAMP> in conjunction with <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>.
Thus, this option is not really needed; it is on by
default for all those cases in which it is allowed.

You can force a scanner to <EM>not</EM> be interactive by
using <SAMP>`-B'</SAMP> (see above).

<DT><SAMP>`-L'</SAMP>
<DD>
instructs <CODE>flex</CODE> not to generate <SAMP>`#line'</SAMP> directives.
Without this option, <CODE>flex</CODE> peppers the generated
scanner with #line directives so error messages in
the actions will be correctly located with respect
to either the original <CODE>flex</CODE> input file (if the
errors are due to code in the input file), or
<TT>`lex.yy.c'</TT> (if the errors are <CODE>flex's</CODE> fault -- you
should report these sorts of errors to the email
address given below).

<DT><SAMP>`-T'</SAMP>
<DD>
makes <CODE>flex</CODE> run in <CODE>trace</CODE> mode.  It will generate a
lot of messages to <CODE>stderr</CODE> concerning the form of
the input and the resultant non-deterministic and
deterministic finite automata.  This option is
mostly for use in maintaining <CODE>flex</CODE>.

<DT><SAMP>`-V'</SAMP>
<DD>
prints the version number to <CODE>stdout</CODE> and exits.
<SAMP>`--version'</SAMP> is a synonym for <SAMP>`-V'</SAMP>.

<DT><SAMP>`-7'</SAMP>
<DD>
instructs <CODE>flex</CODE> to generate a 7-bit scanner, i.e.,
one which can only recognized 7-bit characters in
its input.  The advantage of using <SAMP>`-7'</SAMP> is that the
scanner's tables can be up to half the size of
those generated using the <SAMP>`-8'</SAMP> option (see below).
The disadvantage is that such scanners often hang
or crash if their input contains an 8-bit
character.

Note, however, that unless you generate your
scanner using the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> table compression options,
use of <SAMP>`-7'</SAMP> will save only a small amount of table
space, and make your scanner considerably less
portable.  <CODE>Flex's</CODE> default behavior is to generate
an 8-bit scanner unless you use the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>, in
which case <CODE>flex</CODE> defaults to generating 7-bit
scanners unless your site was always configured to
generate 8-bit scanners (as will often be the case
with non-USA sites).  You can tell whether flex
generated a 7-bit or an 8-bit scanner by inspecting
the flag summary in the <SAMP>`-v'</SAMP> output as described
above.

Note that if you use <SAMP>`-Cfe'</SAMP> or <SAMP>`-CFe'</SAMP> (those table
compression options, but also using equivalence
classes as discussed see below), flex still
defaults to generating an 8-bit scanner, since
usually with these compression options full 8-bit
tables are not much more expensive than 7-bit
tables.

<DT><SAMP>`-8'</SAMP>
<DD>
instructs <CODE>flex</CODE> to generate an 8-bit scanner, i.e.,
one which can recognize 8-bit characters.  This
flag is only needed for scanners generated using
<SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>, as otherwise flex defaults to
generating an 8-bit scanner anyway.

See the discussion of <SAMP>`-7'</SAMP> above for flex's default
behavior and the tradeoffs between 7-bit and 8-bit
scanners.

<DT><SAMP>`-+'</SAMP>
<DD>
specifies that you want flex to generate a C++
scanner class.  See the section on Generating C++
Scanners below for details.

<DT><SAMP>`-C[aefFmr]'</SAMP>
<DD>
controls the degree of table compression and, more
generally, trade-offs between small scanners and
fast scanners.

<SAMP>`-Ca'</SAMP> ("align") instructs flex to trade off larger
tables in the generated scanner for faster
performance because the elements of the tables are better
aligned for memory access and computation.  On some
RISC architectures, fetching and manipulating
long-words is more efficient than with smaller-sized
units such as shortwords.  This option can double
the size of the tables used by your scanner.

<SAMP>`-Ce'</SAMP> directs <CODE>flex</CODE> to construct <EM>equivalence classes</EM>,
i.e., sets of characters which have identical
lexical properties (for example, if the only appearance
of digits in the <CODE>flex</CODE> input is in the character
class "[0-9]" then the digits '0', '1', ..., '9'
will all be put in the same equivalence class).
Equivalence classes usually give dramatic
reductions in the final table/object file sizes
(typically a factor of 2-5) and are pretty cheap
performance-wise (one array look-up per character
scanned).

<SAMP>`-Cf'</SAMP> specifies that the <EM>full</EM> scanner tables should
be generated - <CODE>flex</CODE> should not compress the tables
by taking advantages of similar transition
functions for different states.

<SAMP>`-CF'</SAMP> specifies that the alternate fast scanner
representation (described above under the <SAMP>`-F'</SAMP> flag)
should be used.  This option cannot be used with
<SAMP>`-+'</SAMP>.

<SAMP>`-Cm'</SAMP> directs <CODE>flex</CODE> to construct <EM>meta-equivalence
classes</EM>, which are sets of equivalence classes (or
characters, if equivalence classes are not being
used) that are commonly used together.
Meta-equivalence classes are often a big win when using
compressed tables, but they have a moderate
performance impact (one or two "if" tests and one array
look-up per character scanned).

<SAMP>`-Cr'</SAMP> causes the generated scanner to <EM>bypass</EM> use of
the standard I/O library (stdio) for input.
Instead of calling <SAMP>`fread()'</SAMP> or <SAMP>`getc()'</SAMP>, the scanner
will use the <SAMP>`read()'</SAMP> system call, resulting in a
performance gain which varies from system to
system, but in general is probably negligible unless
you are also using <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>.  Using <SAMP>`-Cr'</SAMP> can cause
strange behavior if, for example, you read from
<CODE>yyin</CODE> using stdio prior to calling the scanner
(because the scanner will miss whatever text your
previous reads left in the stdio input buffer).

<SAMP>`-Cr'</SAMP> has no effect if you define <CODE>YY_INPUT</CODE> (see The
Generated Scanner above).

A lone <SAMP>`-C'</SAMP> specifies that the scanner tables should
be compressed but neither equivalence classes nor
meta-equivalence classes should be used.

The options <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> and <SAMP>`-Cm'</SAMP> do not make sense
together - there is no opportunity for
meta-equivalence classes if the table is not being
compressed.  Otherwise the options may be freely
mixed, and are cumulative.

The default setting is <SAMP>`-Cem'</SAMP>, which specifies that
<CODE>flex</CODE> should generate equivalence classes and
meta-equivalence classes.  This setting provides the
highest degree of table compression.  You can trade
off faster-executing scanners at the cost of larger
tables with the following generally being true:


<PRE>
slowest &#38; smallest
      -Cem
      -Cm
      -Ce
      -C
      -C{f,F}e
      -C{f,F}
      -C{f,F}a
fastest &#38; largest
</PRE>

Note that scanners with the smallest tables are
usually generated and compiled the quickest, so
during development you will usually want to use the
default, maximal compression.

<SAMP>`-Cfe'</SAMP> is often a good compromise between speed and
size for production scanners.

<DT><SAMP>`-ooutput'</SAMP>
<DD>
directs flex to write the scanner to the file <SAMP>`out-'</SAMP>
<CODE>put</CODE> instead of <TT>`lex.yy.c'</TT>.  If you combine <SAMP>`-o'</SAMP> with
the <SAMP>`-t'</SAMP> option, then the scanner is written to
<CODE>stdout</CODE> but its <SAMP>`#line'</SAMP> directives (see the <SAMP>`-L'</SAMP> option
above) refer to the file <CODE>output</CODE>.

<DT><SAMP>`-Pprefix'</SAMP>
<DD>
changes the default <SAMP>`yy'</SAMP> prefix used by <CODE>flex</CODE> for all
globally-visible variable and function names to
instead be <VAR>prefix</VAR>.  For example, <SAMP>`-Pfoo'</SAMP> changes the
name of <CODE>yytext</CODE> to <TT>`footext'</TT>.  It also changes the
name of the default output file from <TT>`lex.yy.c'</TT> to
<TT>`lex.foo.c'</TT>.  Here are all of the names affected:


<PRE>
yy_create_buffer
yy_delete_buffer
yy_flex_debug
yy_init_buffer
yy_flush_buffer
yy_load_buffer_state
yy_switch_to_buffer
yyin
yyleng
yylex
yylineno
yyout
yyrestart
yytext
yywrap
</PRE>

(If you are using a C++ scanner, then only <CODE>yywrap</CODE>
and <CODE>yyFlexLexer</CODE> are affected.) Within your scanner
itself, you can still refer to the global variables
and functions using either version of their name;
but externally, they have the modified name.

This option lets you easily link together multiple
<CODE>flex</CODE> programs into the same executable.  Note,
though, that using this option also renames
<SAMP>`yywrap()'</SAMP>, so you now <EM>must</EM> either provide your own
(appropriately-named) version of the routine for
your scanner, or use <SAMP>`%option noyywrap'</SAMP>, as linking
with <SAMP>`-lfl'</SAMP> no longer provides one for you by
default.

<DT><SAMP>`-Sskeleton_file'</SAMP>
<DD>
overrides the default skeleton file from which <CODE>flex</CODE>
constructs its scanners.  You'll never need this
option unless you are doing <CODE>flex</CODE> maintenance or
development.
</DL>

<P>
<CODE>flex</CODE> also provides a mechanism for controlling options
within the scanner specification itself, rather than from
the flex command-line.  This is done by including <SAMP>`%option'</SAMP>
directives in the first section of the scanner
specification.  You can specify multiple options with a single
<SAMP>`%option'</SAMP> directive, and multiple directives in the first
section of your flex input file.  Most options are given
simply as names, optionally preceded by the word "no"
(with no intervening whitespace) to negate their meaning.
A number are equivalent to flex flags or their negation:



<PRE>
7bit            -7 option
8bit            -8 option
align           -Ca option
backup          -b option
batch           -B option
c++             -+ option

caseful or
case-sensitive  opposite of -i (default)

case-insensitive or
caseless        -i option

debug           -d option
default         opposite of -s option
ecs             -Ce option
fast            -F option
full            -f option
interactive     -I option
lex-compat      -l option
meta-ecs        -Cm option
perf-report     -p option
read            -Cr option
stdout          -t option
verbose         -v option
warn            opposite of -w option
                (use "%option nowarn" for -w)

array           equivalent to "%array"
pointer         equivalent to "%pointer" (default)
</PRE>

<P>
Some <SAMP>`%option's'</SAMP> provide features otherwise not available:


<DL COMPACT>

<DT><SAMP>`always-interactive'</SAMP>
<DD>
instructs flex to generate a scanner which always
considers its input "interactive".  Normally, on
each new input file the scanner calls <SAMP>`isatty()'</SAMP> in
an attempt to determine whether the scanner's input
source is interactive and thus should be read a
character at a time.  When this option is used,
however, then no such call is made.

<DT><SAMP>`main'</SAMP>
<DD>
directs flex to provide a default <SAMP>`main()'</SAMP> program
for the scanner, which simply calls <SAMP>`yylex()'</SAMP>.  This
option implies <CODE>noyywrap</CODE> (see below).

<DT><SAMP>`never-interactive'</SAMP>
<DD>
instructs flex to generate a scanner which never
considers its input "interactive" (again, no call
made to <SAMP>`isatty())'</SAMP>.  This is the opposite of <SAMP>`always-'</SAMP>
<EM>interactive</EM>.

<DT><SAMP>`stack'</SAMP>
<DD>
enables the use of start condition stacks (see
Start Conditions above).

<DT><SAMP>`stdinit'</SAMP>
<DD>
if unset (i.e., <SAMP>`%option nostdinit'</SAMP>) initializes <CODE>yyin</CODE>
and <CODE>yyout</CODE> to nil <CODE>FILE</CODE> pointers, instead of <CODE>stdin</CODE>
and <CODE>stdout</CODE>.

<DT><SAMP>`yylineno'</SAMP>
<DD>
directs <CODE>flex</CODE> to generate a scanner that maintains the number
of the current line read from its input in the global variable
<CODE>yylineno</CODE>.  This option is implied by <SAMP>`%option lex-compat'</SAMP>.

<DT><SAMP>`yywrap'</SAMP>
<DD>
if unset (i.e., <SAMP>`%option noyywrap'</SAMP>), makes the
scanner not call <SAMP>`yywrap()'</SAMP> upon an end-of-file, but
simply assume that there are no more files to scan
(until the user points <CODE>yyin</CODE> at a new file and calls
<SAMP>`yylex()'</SAMP> again).
</DL>

<P>
<CODE>flex</CODE> scans your rule actions to determine whether you use
the <CODE>REJECT</CODE> or <SAMP>`yymore()'</SAMP> features.  The <CODE>reject</CODE> and <CODE>yymore</CODE>
options are available to override its decision as to
whether you use the options, either by setting them (e.g.,
<SAMP>`%option reject'</SAMP>) to indicate the feature is indeed used, or
unsetting them to indicate it actually is not used (e.g.,
<SAMP>`%option noyymore'</SAMP>).


<P>
Three options take string-delimited values, offset with '=':



<PRE>
%option outfile="ABC"
</PRE>

<P>
is equivalent to <SAMP>`-oABC'</SAMP>, and



<PRE>
%option prefix="XYZ"
</PRE>

<P>
is equivalent to <SAMP>`-PXYZ'</SAMP>.


<P>
Finally,



<PRE>
%option yyclass="foo"
</PRE>

<P>
only applies when generating a C++ scanner (<SAMP>`-+'</SAMP> option).  It
informs <CODE>flex</CODE> that you have derived <SAMP>`foo'</SAMP> as a subclass of
<CODE>yyFlexLexer</CODE> so <CODE>flex</CODE> will place your actions in the member
function <SAMP>`foo::yylex()'</SAMP> instead of <SAMP>`yyFlexLexer::yylex()'</SAMP>.
It also generates a <SAMP>`yyFlexLexer::yylex()'</SAMP> member function that
emits a run-time error (by invoking <SAMP>`yyFlexLexer::LexerError()'</SAMP>)
if called.  See Generating C++ Scanners, below, for additional
information.


<P>
A number of options are available for lint purists who
want to suppress the appearance of unneeded routines in
the generated scanner.  Each of the following, if unset,
results in the corresponding routine not appearing in the
generated scanner:



<PRE>
input, unput
yy_push_state, yy_pop_state, yy_top_state
yy_scan_buffer, yy_scan_bytes, yy_scan_string
</PRE>

<P>
(though <SAMP>`yy_push_state()'</SAMP> and friends won't appear anyway
unless you use <SAMP>`%option stack'</SAMP>).




<H2><A NAME="SEC18" HREF="flex.html#TOC18">Performance considerations</A></H2>

<P>
The main design goal of <CODE>flex</CODE> is that it generate
high-performance scanners.  It has been optimized for dealing
well with large sets of rules.  Aside from the effects on
scanner speed of the table compression <SAMP>`-C'</SAMP> options outlined
above, there are a number of options/actions which degrade
performance.  These are, from most expensive to least:



<PRE>
REJECT
%option yylineno
arbitrary trailing context

pattern sets that require backing up
%array
%option interactive
%option always-interactive

'^' beginning-of-line operator
yymore()
</PRE>

<P>
with the first three all being quite expensive and the
last two being quite cheap.  Note also that <SAMP>`unput()'</SAMP> is
implemented as a routine call that potentially does quite
a bit of work, while <SAMP>`yyless()'</SAMP> is a quite-cheap macro; so
if just putting back some excess text you scanned, use
<SAMP>`yyless()'</SAMP>.


<P>
<CODE>REJECT</CODE> should be avoided at all costs when performance is
important.  It is a particularly expensive option.


<P>
Getting rid of backing up is messy and often may be an
enormous amount of work for a complicated scanner.  In
principal, one begins by using the <SAMP>`-b'</SAMP> flag to generate a
<TT>`lex.backup'</TT> file.  For example, on the input



<PRE>
%%
foo        return TOK_KEYWORD;
foobar     return TOK_KEYWORD;
</PRE>

<P>
the file looks like:



<PRE>
State #6 is non-accepting -
 associated rule line numbers:
       2       3
 out-transitions: [ o ]
 jam-transitions: EOF [ \001-n  p-\177 ]

State #8 is non-accepting -
 associated rule line numbers:
       3
 out-transitions: [ a ]
 jam-transitions: EOF [ \001-`  b-\177 ]

State #9 is non-accepting -
 associated rule line numbers:
       3
 out-transitions: [ r ]
 jam-transitions: EOF [ \001-q  s-\177 ]

Compressed tables always back up.
</PRE>

<P>
The first few lines tell us that there's a scanner state
in which it can make a transition on an 'o' but not on any
other character, and that in that state the currently
scanned text does not match any rule.  The state occurs
when trying to match the rules found at lines 2 and 3 in
the input file.  If the scanner is in that state and then
reads something other than an 'o', it will have to back up
to find a rule which is matched.  With a bit of
head-scratching one can see that this must be the state it's in
when it has seen "fo".  When this has happened, if
anything other than another 'o' is seen, the scanner will
have to back up to simply match the 'f' (by the default
rule).


<P>
The comment regarding State #8 indicates there's a problem
when "foob" has been scanned.  Indeed, on any character
other than an 'a', the scanner will have to back up to
accept "foo".  Similarly, the comment for State #9
concerns when "fooba" has been scanned and an 'r' does not
follow.


<P>
The final comment reminds us that there's no point going
to all the trouble of removing backing up from the rules
unless we're using <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>, since there's no
performance gain doing so with compressed scanners.


<P>
The way to remove the backing up is to add "error" rules:



<PRE>
%%
foo         return TOK_KEYWORD;
foobar      return TOK_KEYWORD;

fooba       |
foob        |
fo          {
            /* false alarm, not really a keyword */
            return TOK_ID;
            }
</PRE>

<P>
Eliminating backing up among a list of keywords can also
be done using a "catch-all" rule:



<PRE>
%%
foo         return TOK_KEYWORD;
foobar      return TOK_KEYWORD;

[a-z]+      return TOK_ID;
</PRE>

<P>
This is usually the best solution when appropriate.


<P>
Backing up messages tend to cascade.  With a complicated
set of rules it's not uncommon to get hundreds of
messages.  If one can decipher them, though, it often only
takes a dozen or so rules to eliminate the backing up
(though it's easy to make a mistake and have an error rule
accidentally match a valid token.  A possible future <CODE>flex</CODE>
feature will be to automatically add rules to eliminate
backing up).


<P>
It's important to keep in mind that you gain the benefits
of eliminating backing up only if you eliminate <EM>every</EM>
instance of backing up.  Leaving just one means you gain
nothing.


<P>
<VAR>Variable</VAR> trailing context (where both the leading and
trailing parts do not have a fixed length) entails almost
the same performance loss as <CODE>REJECT</CODE> (i.e., substantial).
So when possible a rule like:



<PRE>
%%
mouse|rat/(cat|dog)   run();
</PRE>

<P>
is better written:



<PRE>
%%
mouse/cat|dog         run();
rat/cat|dog           run();
</PRE>

<P>
or as



<PRE>
%%
mouse|rat/cat         run();
mouse|rat/dog         run();
</PRE>

<P>
Note that here the special '|' action does <EM>not</EM> provide any
savings, and can even make things worse (see Deficiencies
/ Bugs below).


<P>
Another area where the user can increase a scanner's
performance (and one that's easier to implement) arises from
the fact that the longer the tokens matched, the faster
the scanner will run.  This is because with long tokens
the processing of most input characters takes place in the
(short) inner scanning loop, and does not often have to go
through the additional work of setting up the scanning
environment (e.g., <CODE>yytext</CODE>) for the action.  Recall the
scanner for C comments:



<PRE>
%x comment
%%
        int line_num = 1;

"/*"         BEGIN(comment);

&#60;comment&#62;[^*\n]*
&#60;comment&#62;"*"+[^*/\n]*
&#60;comment&#62;\n             ++line_num;
&#60;comment&#62;"*"+"/"        BEGIN(INITIAL);
</PRE>

<P>
This could be sped up by writing it as:



<PRE>
%x comment
%%
        int line_num = 1;

"/*"         BEGIN(comment);

&#60;comment&#62;[^*\n]*
&#60;comment&#62;[^*\n]*\n      ++line_num;
&#60;comment&#62;"*"+[^*/\n]*
&#60;comment&#62;"*"+[^*/\n]*\n ++line_num;
&#60;comment&#62;"*"+"/"        BEGIN(INITIAL);
</PRE>

<P>
Now instead of each newline requiring the processing of
another action, recognizing the newlines is "distributed"
over the other rules to keep the matched text as long as
possible.  Note that <EM>adding</EM> rules does <EM>not</EM> slow down the
scanner!  The speed of the scanner is independent of the
number of rules or (modulo the considerations given at the
beginning of this section) how complicated the rules are
with regard to operators such as '*' and '|'.


<P>
A final example in speeding up a scanner: suppose you want
to scan through a file containing identifiers and
keywords, one per line and with no other extraneous
characters, and recognize all the keywords.  A natural first
approach is:



<PRE>
%%
asm      |
auto     |
break    |
... etc ...
volatile |
while    /* it's a keyword */

.|\n     /* it's not a keyword */
</PRE>

<P>
To eliminate the back-tracking, introduce a catch-all
rule:



<PRE>
%%
asm      |
auto     |
break    |
... etc ...
volatile |
while    /* it's a keyword */

[a-z]+   |
.|\n     /* it's not a keyword */
</PRE>

<P>
Now, if it's guaranteed that there's exactly one word per
line, then we can reduce the total number of matches by a
half by merging in the recognition of newlines with that
of the other tokens:



<PRE>
%%
asm\n    |
auto\n   |
break\n  |
... etc ...
volatile\n |
while\n  /* it's a keyword */

[a-z]+\n |
.|\n     /* it's not a keyword */
</PRE>

<P>
One has to be careful here, as we have now reintroduced
backing up into the scanner.  In particular, while <EM>we</EM> know
that there will never be any characters in the input
stream other than letters or newlines, <CODE>flex</CODE> can't figure
this out, and it will plan for possibly needing to back up
when it has scanned a token like "auto" and then the next
character is something other than a newline or a letter.
Previously it would then just match the "auto" rule and be
done, but now it has no "auto" rule, only a "auto\n" rule.
To eliminate the possibility of backing up, we could
either duplicate all rules but without final newlines, or,
since we never expect to encounter such an input and
therefore don't how it's classified, we can introduce one
more catch-all rule, this one which doesn't include a
newline:



<PRE>
%%
asm\n    |
auto\n   |
break\n  |
... etc ...
volatile\n |
while\n  /* it's a keyword */

[a-z]+\n |
[a-z]+   |
.|\n     /* it's not a keyword */
</PRE>

<P>
Compiled with <SAMP>`-Cf'</SAMP>, this is about as fast as one can get a
<CODE>flex</CODE> scanner to go for this particular problem.


<P>
A final note: <CODE>flex</CODE> is slow when matching NUL's,
particularly when a token contains multiple NUL's.  It's best to
write rules which match <EM>short</EM> amounts of text if it's
anticipated that the text will often include NUL's.


<P>
Another final note regarding performance: as mentioned
above in the section How the Input is Matched, dynamically
resizing <CODE>yytext</CODE> to accommodate huge tokens is a slow
process because it presently requires that the (huge) token
be rescanned from the beginning.  Thus if performance is
vital, you should attempt to match "large" quantities of
text but not "huge" quantities, where the cutoff between
the two is at about 8K characters/token.




<H2><A NAME="SEC19" HREF="flex.html#TOC19">Generating C++ scanners</A></H2>

<P>
<CODE>flex</CODE> provides two different ways to generate scanners for
use with C++.  The first way is to simply compile a
scanner generated by <CODE>flex</CODE> using a C++ compiler instead of a C
compiler.  You should not encounter any compilations
errors (please report any you find to the email address
given in the Author section below).  You can then use C++
code in your rule actions instead of C code.  Note that
the default input source for your scanner remains <CODE>yyin</CODE>,
and default echoing is still done to <CODE>yyout</CODE>.  Both of these
remain <SAMP>`FILE *'</SAMP> variables and not C++ <CODE>streams</CODE>.


<P>
You can also use <CODE>flex</CODE> to generate a C++ scanner class, using
the <SAMP>`-+'</SAMP> option, (or, equivalently, <SAMP>`%option c++'</SAMP>), which
is automatically specified if the name of the flex executable ends
in a <SAMP>`+'</SAMP>, such as <CODE>flex++</CODE>.  When using this option, flex
defaults to generating the scanner to the file <TT>`lex.yy.cc'</TT> instead
of <TT>`lex.yy.c'</TT>.  The generated scanner includes the header file
<TT>`FlexLexer.h'</TT>, which defines the interface to two C++ classes.


<P>
The first class, <CODE>FlexLexer</CODE>, provides an abstract base
class defining the general scanner class interface.  It
provides the following member functions:


<DL COMPACT>

<DT><SAMP>`const char* YYText()'</SAMP>
<DD>
returns the text of the most recently matched
token, the equivalent of <CODE>yytext</CODE>.

<DT><SAMP>`int YYLeng()'</SAMP>
<DD>
returns the length of the most recently matched
token, the equivalent of <CODE>yyleng</CODE>.

<DT><SAMP>`int lineno() const'</SAMP>
<DD>
returns the current input line number (see <SAMP>`%option yylineno'</SAMP>),
or 1 if <SAMP>`%option yylineno'</SAMP> was not used.

<DT><SAMP>`void set_debug( int flag )'</SAMP>
<DD>
sets the debugging flag for the scanner, equivalent to assigning to
<CODE>yy_flex_debug</CODE> (see the Options section above).  Note that you
must build the scanner using <SAMP>`%option debug'</SAMP> to include debugging
information in it.

<DT><SAMP>`int debug() const'</SAMP>
<DD>
returns the current setting of the debugging flag.
</DL>

<P>
Also provided are member functions equivalent to
<SAMP>`yy_switch_to_buffer(), yy_create_buffer()'</SAMP> (though the
first argument is an <SAMP>`istream*'</SAMP> object pointer and not a
<SAMP>`FILE*'</SAMP>, <SAMP>`yy_flush_buffer()'</SAMP>, <SAMP>`yy_delete_buffer()'</SAMP>,
and <SAMP>`yyrestart()'</SAMP> (again, the first argument is a <SAMP>`istream*'</SAMP>
object pointer).


<P>
The second class defined in <TT>`FlexLexer.h'</TT> is <CODE>yyFlexLexer</CODE>,
which is derived from <CODE>FlexLexer</CODE>.  It defines the following
additional member functions:


<DL COMPACT>

<DT><SAMP>`yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )'</SAMP>
<DD>
constructs a <CODE>yyFlexLexer</CODE> object using the given
streams for input and output.  If not specified,
the streams default to <CODE>cin</CODE> and <CODE>cout</CODE>, respectively.

<DT><SAMP>`virtual int yylex()'</SAMP>
<DD>
performs the same role is <SAMP>`yylex()'</SAMP> does for ordinary
flex scanners: it scans the input stream, consuming
tokens, until a rule's action returns a value.  If you derive a subclass
<VAR>S</VAR>
from <CODE>yyFlexLexer</CODE>
and want to access the member functions and variables of
<VAR>S</VAR>
inside <SAMP>`yylex()'</SAMP>,
then you need to use <SAMP>`%option yyclass="<VAR>S</VAR>"'</SAMP>
to inform <CODE>flex</CODE>
that you will be using that subclass instead of <CODE>yyFlexLexer</CODE>.
In this case, rather than generating <SAMP>`yyFlexLexer::yylex()'</SAMP>,
<CODE>flex</CODE> generates <SAMP>`<VAR>S</VAR>::yylex()'</SAMP>
(and also generates a dummy <SAMP>`yyFlexLexer::yylex()'</SAMP>
that calls <SAMP>`yyFlexLexer::LexerError()'</SAMP>
if called).

<DT><SAMP>`virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)'</SAMP>
<DD>
reassigns <CODE>yyin</CODE> to <CODE>new_in</CODE>
(if non-nil)
and <CODE>yyout</CODE> to <CODE>new_out</CODE>
(ditto), deleting the previous input buffer if <CODE>yyin</CODE>
is reassigned.

<DT><SAMP>`int yylex( istream* new_in = 0, ostream* new_out = 0 )'</SAMP>
<DD>
first switches the input streams via <SAMP>`switch_streams( new_in, new_out )'</SAMP>
and then returns the value of <SAMP>`yylex()'</SAMP>.
</DL>

<P>
In addition, <CODE>yyFlexLexer</CODE> defines the following protected
virtual functions which you can redefine in derived
classes to tailor the scanner:


<DL COMPACT>

<DT><SAMP>`virtual int LexerInput( char* buf, int max_size )'</SAMP>
<DD>
reads up to <SAMP>`max_size'</SAMP> characters into <VAR>buf</VAR> and
returns the number of characters read.  To indicate
end-of-input, return 0 characters.  Note that
"interactive" scanners (see the <SAMP>`-B'</SAMP> and <SAMP>`-I'</SAMP> flags)
define the macro <CODE>YY_INTERACTIVE</CODE>.  If you redefine
<CODE>LexerInput()</CODE> and need to take different actions
depending on whether or not the scanner might be
scanning an interactive input source, you can test
for the presence of this name via <SAMP>`#ifdef'</SAMP>.

<DT><SAMP>`virtual void LexerOutput( const char* buf, int size )'</SAMP>
<DD>
writes out <VAR>size</VAR> characters from the buffer <VAR>buf</VAR>,
which, while NUL-terminated, may also contain
"internal" NUL's if the scanner's rules can match
text with NUL's in them.

<DT><SAMP>`virtual void LexerError( const char* msg )'</SAMP>
<DD>
reports a fatal error message.  The default version
of this function writes the message to the stream
<CODE>cerr</CODE> and exits.
</DL>

<P>
Note that a <CODE>yyFlexLexer</CODE> object contains its <EM>entire</EM>
scanning state.  Thus you can use such objects to create
reentrant scanners.  You can instantiate multiple instances of
the same <CODE>yyFlexLexer</CODE> class, and you can also combine
multiple C++ scanner classes together in the same program
using the <SAMP>`-P'</SAMP> option discussed above.
Finally, note that the <SAMP>`%array'</SAMP> feature is not available to
C++ scanner classes; you must use <SAMP>`%pointer'</SAMP> (the default).


<P>
Here is an example of a simple C++ scanner:



<PRE>
    // An example of using the flex C++ scanner class.

%{
int mylineno = 0;
%}

string  \"[^\n"]+\"

ws      [ \t]+

alpha   [A-Za-z]
dig     [0-9]
name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number  {num1}|{num2}

%%

{ws}    /* skip blanks and tabs */

"/*"    {
        int c;

        while((c = yyinput()) != 0)
            {
            if(c == '\n')
                ++mylineno;

            else if(c == '*')
                {
                if((c = yyinput()) == '/')
                    break;
                else
                    unput(c);
                }
            }
        }

{number}  cout &#60;&#60; "number " &#60;&#60; YYText() &#60;&#60; '\n';

\n        mylineno++;

{name}    cout &#60;&#60; "name " &#60;&#60; YYText() &#60;&#60; '\n';

{string}  cout &#60;&#60; "string " &#60;&#60; YYText() &#60;&#60; '\n';

%%

Version 2.5               December 1994                        44

int main( int /* argc */, char** /* argv */ )
    {
    FlexLexer* lexer = new yyFlexLexer;
    while(lexer-&#62;yylex() != 0)
        ;
    return 0;
    }
</PRE>

<P>
If you want to create multiple (different) lexer classes,
you use the <SAMP>`-P'</SAMP> flag (or the <SAMP>`prefix='</SAMP> option) to rename each
<CODE>yyFlexLexer</CODE> to some other <CODE>xxFlexLexer</CODE>.  You then can
include <SAMP>`&#60;FlexLexer.h&#62;'</SAMP> in your other sources once per lexer
class, first renaming <CODE>yyFlexLexer</CODE> as follows:



<PRE>
#undef yyFlexLexer
#define yyFlexLexer xxFlexLexer
#include &#60;FlexLexer.h&#62;

#undef yyFlexLexer
#define yyFlexLexer zzFlexLexer
#include &#60;FlexLexer.h&#62;
</PRE>

<P>
if, for example, you used <SAMP>`%option prefix="xx"'</SAMP> for one of
your scanners and <SAMP>`%option prefix="zz"'</SAMP> for the other.


<P>
IMPORTANT: the present form of the scanning class is
<EM>experimental</EM> and may change considerably between major
releases.




<H2><A NAME="SEC20" HREF="flex.html#TOC20">Incompatibilities with <CODE>lex</CODE> and POSIX</A></H2>

<P>
<CODE>flex</CODE> is a rewrite of the AT&#38;T Unix <CODE>lex</CODE> tool (the two
implementations do not share any code, though), with some
extensions and incompatibilities, both of which are of
concern to those who wish to write scanners acceptable to
either implementation.  Flex is fully compliant with the
POSIX <CODE>lex</CODE> specification, except that when using <SAMP>`%pointer'</SAMP>
(the default), a call to <SAMP>`unput()'</SAMP> destroys the contents of
<CODE>yytext</CODE>, which is counter to the POSIX specification.


<P>
In this section we discuss all of the known areas of
incompatibility between flex, AT&#38;T lex, and the POSIX
specification.


<P>
<CODE>flex's</CODE> <SAMP>`-l'</SAMP> option turns on maximum compatibility with the
original AT&#38;T <CODE>lex</CODE> implementation, at the cost of a major
loss in the generated scanner's performance.  We note
below which incompatibilities can be overcome using the <SAMP>`-l'</SAMP>
option.


<P>
<CODE>flex</CODE> is fully compatible with <CODE>lex</CODE> with the following
exceptions:



<UL>
<LI>

The undocumented <CODE>lex</CODE> scanner internal variable <CODE>yylineno</CODE>
is not supported unless <SAMP>`-l'</SAMP> or <SAMP>`%option yylineno'</SAMP> is used.
<CODE>yylineno</CODE> should be maintained on a per-buffer basis, rather
than a per-scanner (single global variable) basis.  <CODE>yylineno</CODE> is
not part of the POSIX specification.

<LI>

The <SAMP>`input()'</SAMP> routine is not redefinable, though it
may be called to read characters following whatever
has been matched by a rule.  If <SAMP>`input()'</SAMP> encounters
an end-of-file the normal <SAMP>`yywrap()'</SAMP> processing is
done.  A "real" end-of-file is returned by
<SAMP>`input()'</SAMP> as <CODE>EOF</CODE>.

Input is instead controlled by defining the
<CODE>YY_INPUT</CODE> macro.

The <CODE>flex</CODE> restriction that <SAMP>`input()'</SAMP> cannot be
redefined is in accordance with the POSIX
specification, which simply does not specify any way of
controlling the scanner's input other than by making
an initial assignment to <CODE>yyin</CODE>.

<LI>

The <SAMP>`unput()'</SAMP> routine is not redefinable.  This
restriction is in accordance with POSIX.

<LI>

<CODE>flex</CODE> scanners are not as reentrant as <CODE>lex</CODE> scanners.
In particular, if you have an interactive scanner
and an interrupt handler which long-jumps out of
the scanner, and the scanner is subsequently called
again, you may get the following message:


<PRE>
fatal flex scanner internal error--end of buffer missed
</PRE>

To reenter the scanner, first use


<PRE>
yyrestart( yyin );
</PRE>

Note that this call will throw away any buffered
input; usually this isn't a problem with an
interactive scanner.

Also note that flex C++ scanner classes <EM>are</EM>
reentrant, so if using C++ is an option for you, you
should use them instead.  See "Generating C++
Scanners" above for details.

<LI>

<SAMP>`output()'</SAMP> is not supported.  Output from the <SAMP>`ECHO'</SAMP>
macro is done to the file-pointer <CODE>yyout</CODE> (default
<CODE>stdout</CODE>).

<SAMP>`output()'</SAMP> is not part of the POSIX specification.

<LI>

<CODE>lex</CODE> does not support exclusive start conditions
(%x), though they are in the POSIX specification.

<LI>

When definitions are expanded, <CODE>flex</CODE> encloses them
in parentheses.  With lex, the following:


<PRE>
NAME    [A-Z][A-Z0-9]*
%%
foo{NAME}?      printf( "Found it\n" );
%%
</PRE>

will not match the string "foo" because when the
macro is expanded the rule is equivalent to
"foo[A-Z][A-Z0-9]*?" and the precedence is such that the
'?' is associated with "[A-Z0-9]*".  With <CODE>flex</CODE>, the
rule will be expanded to "foo([A-Z][A-Z0-9]*)?" and
so the string "foo" will match.

Note that if the definition begins with <SAMP>`^'</SAMP> or ends
with <SAMP>`$'</SAMP> then it is <EM>not</EM> expanded with parentheses, to
allow these operators to appear in definitions
without losing their special meanings.  But the
<SAMP>`&#60;s&#62;, /'</SAMP>, and <SAMP>`&#60;&#60;EOF&#62;&#62;'</SAMP> operators cannot be used in a
<CODE>flex</CODE> definition.

Using <SAMP>`-l'</SAMP> results in the <CODE>lex</CODE> behavior of no
parentheses around the definition.

The POSIX specification is that the definition be enclosed in
parentheses.

<LI>

Some implementations of <CODE>lex</CODE> allow a rule's action to begin on
a separate line, if the rule's pattern has trailing whitespace:


<PRE>
%%
foo|bar&#60;space here&#62;
  { foobar_action(); }
</PRE>

<CODE>flex</CODE> does not support this feature.

<LI>

The <CODE>lex</CODE> <SAMP>`%r'</SAMP> (generate a Ratfor scanner) option is
not supported.  It is not part of the POSIX
specification.

<LI>

After a call to <SAMP>`unput()'</SAMP>, <CODE>yytext</CODE> is undefined until
the next token is matched, unless the scanner was
built using <SAMP>`%array'</SAMP>.  This is not the case with <CODE>lex</CODE>
or the POSIX specification.  The <SAMP>`-l'</SAMP> option does
away with this incompatibility.

<LI>

The precedence of the <SAMP>`{}'</SAMP> (numeric range) operator
is different.  <CODE>lex</CODE> interprets "abc{1,3}" as "match
one, two, or three occurrences of 'abc'", whereas
<CODE>flex</CODE> interprets it as "match 'ab' followed by one,
two, or three occurrences of 'c'".  The latter is
in agreement with the POSIX specification.

<LI>

The precedence of the <SAMP>`^'</SAMP> operator is different.  <CODE>lex</CODE>
interprets "^foo|bar" as "match either 'foo' at the
beginning of a line, or 'bar' anywhere", whereas
<CODE>flex</CODE> interprets it as "match either 'foo' or 'bar'
if they come at the beginning of a line".  The
latter is in agreement with the POSIX specification.

<LI>

The special table-size declarations such as <SAMP>`%a'</SAMP>
supported by <CODE>lex</CODE> are not required by <CODE>flex</CODE> scanners;
<CODE>flex</CODE> ignores them.

<LI>

The name FLEX_SCANNER is #define'd so scanners may
be written for use with either <CODE>flex</CODE> or <CODE>lex</CODE>.
Scanners also include <CODE>YY_FLEX_MAJOR_VERSION</CODE> and
<CODE>YY_FLEX_MINOR_VERSION</CODE> indicating which version of
<CODE>flex</CODE> generated the scanner (for example, for the
2.5 release, these defines would be 2 and 5
respectively).
</UL>

<P>
The following <CODE>flex</CODE> features are not included in <CODE>lex</CODE> or the
POSIX specification:



<PRE>
C++ scanners
%option
start condition scopes
start condition stacks
interactive/non-interactive scanners
yy_scan_string() and friends
yyterminate()
yy_set_interactive()
yy_set_bol()
YY_AT_BOL()
&#60;&#60;EOF&#62;&#62;
&#60;*&#62;
YY_DECL
YY_START
YY_USER_ACTION
YY_USER_INIT
#line directives
%{}'s around actions
multiple actions on a line
</PRE>

<P>
plus almost all of the flex flags.  The last feature in
the list refers to the fact that with <CODE>flex</CODE> you can put
multiple actions on the same line, separated with
semicolons, while with <CODE>lex</CODE>, the following



<PRE>
foo    handle_foo(); ++num_foos_seen;
</PRE>

<P>
is (rather surprisingly) truncated to



<PRE>
foo    handle_foo();
</PRE>

<P>
<CODE>flex</CODE> does not truncate the action.  Actions that are not
enclosed in braces are simply terminated at the end of the
line.




<H2><A NAME="SEC21" HREF="flex.html#TOC21">Diagnostics</A></H2>

<DL COMPACT>

<DT><SAMP>`warning, rule cannot be matched'</SAMP>
<DD>
indicates that the given
rule cannot be matched because it follows other rules that
will always match the same text as it.  For example, in
the following "foo" cannot be matched because it comes
after an identifier "catch-all" rule:


<PRE>
[a-z]+    got_identifier();
foo       got_foo();
</PRE>

Using <CODE>REJECT</CODE> in a scanner suppresses this warning.

<DT><SAMP>`warning, -s option given but default rule can be matched'</SAMP>
<DD>
means that it is possible (perhaps only in a particular
start condition) that the default rule (match any single
character) is the only one that will match a particular
input.  Since <SAMP>`-s'</SAMP> was given, presumably this is not
intended.

<DT><SAMP>`reject_used_but_not_detected undefined'</SAMP>
<DD>
<DT><SAMP>`yymore_used_but_not_detected undefined'</SAMP>
<DD>
These errors can
occur at compile time.  They indicate that the scanner
uses <CODE>REJECT</CODE> or <SAMP>`yymore()'</SAMP> but that <CODE>flex</CODE> failed to notice the
fact, meaning that <CODE>flex</CODE> scanned the first two sections
looking for occurrences of these actions and failed to
find any, but somehow you snuck some in (via a #include
file, for example).  Use <SAMP>`%option reject'</SAMP> or <SAMP>`%option yymore'</SAMP>
to indicate to flex that you really do use these features.

<DT><SAMP>`flex scanner jammed'</SAMP>
<DD>
a scanner compiled with <SAMP>`-s'</SAMP> has
encountered an input string which wasn't matched by any of
its rules.  This error can also occur due to internal
problems.

<DT><SAMP>`token too large, exceeds YYLMAX'</SAMP>
<DD>
your scanner uses <SAMP>`%array'</SAMP>
and one of its rules matched a string longer than the <SAMP>`YYL-'</SAMP>
<CODE>MAX</CODE> constant (8K bytes by default).  You can increase the
value by #define'ing <CODE>YYLMAX</CODE> in the definitions section of
your <CODE>flex</CODE> input.

<DT><SAMP>`scanner requires -8 flag to use the character '<VAR>x</VAR>''</SAMP>
<DD>
Your
scanner specification includes recognizing the 8-bit
character <VAR>x</VAR> and you did not specify the -8 flag, and your
scanner defaulted to 7-bit because you used the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>
table compression options.  See the discussion of the <SAMP>`-7'</SAMP>
flag for details.

<DT><SAMP>`flex scanner push-back overflow'</SAMP>
<DD>
you used <SAMP>`unput()'</SAMP> to push
back so much text that the scanner's buffer could not hold
both the pushed-back text and the current token in <CODE>yytext</CODE>.
Ideally the scanner should dynamically resize the buffer
in this case, but at present it does not.

<DT><SAMP>`input buffer overflow, can't enlarge buffer because scanner uses REJECT'</SAMP>
<DD>
the scanner was working on matching an
extremely large token and needed to expand the input
buffer.  This doesn't work with scanners that use <CODE>REJECT</CODE>.

<DT><SAMP>`fatal flex scanner internal error--end of buffer missed'</SAMP>
<DD>
This can occur in an scanner which is reentered after a
long-jump has jumped out (or over) the scanner's
activation frame.  Before reentering the scanner, use:


<PRE>
yyrestart( yyin );
</PRE>

or, as noted above, switch to using the C++ scanner class.

<DT><SAMP>`too many start conditions in &#60;&#62; construct!'</SAMP>
<DD>
you listed
more start conditions in a &#60;&#62; construct than exist (so you
must have listed at least one of them twice).
</DL>



<H2><A NAME="SEC22" HREF="flex.html#TOC22">Files</A></H2>

<DL COMPACT>

<DT><TT>`-lfl'</TT>
<DD>
library with which scanners must be linked.

<DT><TT>`lex.yy.c'</TT>
<DD>
generated scanner (called <TT>`lexyy.c'</TT> on some systems).

<DT><TT>`lex.yy.cc'</TT>
<DD>
generated C++ scanner class, when using <SAMP>`-+'</SAMP>.

<DT><TT>`&#60;FlexLexer.h&#62;'</TT>
<DD>
header file defining the C++ scanner base class,
<CODE>FlexLexer</CODE>, and its derived class, <CODE>yyFlexLexer</CODE>.

<DT><TT>`flex.skl'</TT>
<DD>
skeleton scanner.  This file is only used when
building flex, not when flex executes.

<DT><TT>`lex.backup'</TT>
<DD>
backing-up information for <SAMP>`-b'</SAMP> flag (called <TT>`lex.bck'</TT>
on some systems).
</DL>



<H2><A NAME="SEC23" HREF="flex.html#TOC23">Deficiencies / Bugs</A></H2>

<P>
Some trailing context patterns cannot be properly matched
and generate warning messages ("dangerous trailing
context").  These are patterns where the ending of the first
part of the rule matches the beginning of the second part,
such as "zx*/xy*", where the 'x*' matches the 'x' at the
beginning of the trailing context.  (Note that the POSIX
draft states that the text matched by such patterns is
undefined.)


<P>
For some trailing context rules, parts which are actually
fixed-length are not recognized as such, leading to the
abovementioned performance loss.  In particular, parts
using '|' or {n} (such as "foo{3}") are always considered
variable-length.


<P>
Combining trailing context with the special '|' action can
result in <EM>fixed</EM> trailing context being turned into the
more expensive <VAR>variable</VAR> trailing context.  For example, in
the following:



<PRE>
%%
abc      |
xyz/def
</PRE>

<P>
Use of <SAMP>`unput()'</SAMP> invalidates yytext and yyleng, unless the
<SAMP>`%array'</SAMP> directive or the <SAMP>`-l'</SAMP> option has been used.


<P>
Pattern-matching of NUL's is substantially slower than
matching other characters.


<P>
Dynamic resizing of the input buffer is slow, as it
entails rescanning all the text matched so far by the
current (generally huge) token.


<P>
Due to both buffering of input and read-ahead, you cannot
intermix calls to &#60;stdio.h&#62; routines, such as, for
example, <SAMP>`getchar()'</SAMP>, with <CODE>flex</CODE> rules and expect it to work.
Call <SAMP>`input()'</SAMP> instead.


<P>
The total table entries listed by the <SAMP>`-v'</SAMP> flag excludes the
number of table entries needed to determine what rule has
been matched.  The number of entries is equal to the
number of DFA states if the scanner does not use <CODE>REJECT</CODE>, and
somewhat greater than the number of states if it does.


<P>
<CODE>REJECT</CODE> cannot be used with the <SAMP>`-f'</SAMP> or <SAMP>`-F'</SAMP> options.


<P>
The <CODE>flex</CODE> internal algorithms need documentation.




<H2><A NAME="SEC24" HREF="flex.html#TOC24">See also</A></H2>

<P>
<CODE>lex</CODE>(1), <CODE>yacc</CODE>(1), <CODE>sed</CODE>(1), <CODE>awk</CODE>(1).


<P>
John Levine, Tony Mason, and Doug Brown: Lex &#38; Yacc;
O'Reilly and Associates.  Be sure to get the 2nd edition.


<P>
M. E. Lesk and E. Schmidt, LEX - Lexical Analyzer Generator.


<P>
Alfred Aho, Ravi Sethi and Jeffrey Ullman: Compilers:
Principles, Techniques and Tools; Addison-Wesley (1986).
Describes the pattern-matching techniques used by <CODE>flex</CODE>
(deterministic finite automata).




<H2><A NAME="SEC25" HREF="flex.html#TOC25">Author</A></H2>

<P>
Vern Paxson, with the help of many ideas and much inspiration from
Van Jacobson.  Original version by Jef Poskanzer.  The fast table
representation is a partial implementation of a design done by Van
Jacobson.  The implementation was done by Kevin Gong and Vern Paxson.


<P>
Thanks to the many <CODE>flex</CODE> beta-testers, feedbackers, and
contributors, especially Francois Pinard, Casey Leedom, Stan
Adermann, Terry Allen, David Barker-Plummer, John Basrai, Nelson
H.F. Beebe, <SAMP>`benson@odi.com'</SAMP>, Karl Berry, Peter A. Bigot,
Simon Blanchard, Keith Bostic, Frederic Brehm, Ian Brockbank, Kin
Cho, Nick Christopher, Brian Clapper, J.T. Conklin, Jason Coughlin,
Bill Cox, Nick Cropper, Dave Curtis, Scott David Daniels, Chris
G. Demetriou, Theo Deraadt, Mike Donahue, Chuck Doucette, Tom Epperly,
Leo Eskin, Chris Faylor, Chris Flatters, Jon Forrest, Joe Gayda, Kaveh
R. Ghazi, Eric Goldman, Christopher M.  Gould, Ulrich Grepel, Peer
Griebel, Jan Hajic, Charles Hemphill, NORO Hideo, Jarkko Hietaniemi,
Scott Hofmann, Jeff Honig, Dana Hudes, Eric Hughes, John Interrante,
Ceriel Jacobs, Michal Jaegermann, Sakari Jalovaara, Jeffrey R. Jones,
Henry Juengst, Klaus Kaempf, Jonathan I. Kamens, Terrence O Kane,
Amir Katz, <SAMP>`ken@ken.hilco.com'</SAMP>, Kevin B. Kenny, Steve Kirsch,
Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard,
Craig Leres, John Levine, Steve Liddle, Mike Long, Mohamed el Lozy,
Brian Madsen, Malte, Joe Marshall, Bengt Martensson, Chris Metcalf,
Luke Mewburn, Jim Meyering, R.  Alexander Milowski, Erik Naggum,
G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, Richard Ohnemus,
Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero, Gaumond
Pierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha, Frederic
Raimbault, Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe Rommel,
Jim Roskind, Alberto Santini, Andreas Scherer, Darrell Schiebel, Raf
Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas Schwab, Alex
Siegel, Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul Stuart,
Dave Tallman, Ian Lance Taylor, Chris Thewalt, Richard M. Timoney,
Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard Wilhelms,
Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn, and
those whose names have slipped my marginal mail-archiving skills but
whose contributions are appreciated all the same.


<P>
Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore,
Craig Leres, John Levine, Bob Mulcahy, G.T.  Nicol, Francois Pinard,
Rich Salz, and Richard Stallman for help with various distribution
headaches.


<P>
Thanks to Esmond Pitt and Earle Horton for 8-bit character support;
to Benson Margulies and Fred Burke for C++ support; to Kent Williams
and Tom Epperly for C++ class support; to Ove Ewerlid for support of
NUL's; and to Eric Hughes for support of multiple buffers.


<P>
This work was primarily done when I was with the Real Time Systems
Group at the Lawrence Berkeley Laboratory in Berkeley, CA.  Many thanks
to all there for the support I received.


<P>
Send comments to <SAMP>`vern@ee.lbl.gov'</SAMP>.


<P><HR><P>
This document was generated on 23 February 2001 using
<A HREF="http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>&nbsp;1.56k.
</BODY>
</HTML>
