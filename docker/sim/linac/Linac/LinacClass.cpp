/*----- PROTECTED REGION ID(LinacClass.cpp) ENABLED START -----*/
static const char *RcsId      = "$Id:  $";
static const char *TagName    = "$Name:  $";
static const char *CvsPath    = "$Source:  $";
static const char *SvnPath    = "$HeadURL:  $";
static const char *HttpServer = "http://www.esrf.eu/computing/cs/tango/tango_doc/ds_doc/";
//=============================================================================
//
// file :        LinacClass.cpp
//
// description : C++ source for the LinacClass.
//               A singleton class derived from DeviceClass.
//               It implements the command and attribute list
//               and all properties and methods required
//               by the Linac once per process.
//
// project :     Linac
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <tango.h>
#include <Linac.h>
#include <LinacClass.h>

/*----- PROTECTED REGION END -----*/	//	LinacClass.cpp

//-------------------------------------------------------------------
/**
 *	Create LinacClass singleton and
 *	return it in a C function for Python usage
 */
//-------------------------------------------------------------------
extern "C" {
#ifdef _TG_WINDOWS_

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_Linac_class(const char *name) {
		return Linac_ns::LinacClass::init(name);
	}
}

namespace Linac_ns
{
//===================================================================
//	Initialize pointer for singleton pattern
//===================================================================
LinacClass *LinacClass::_instance = NULL;

//--------------------------------------------------------
/**
 * method : 		LinacClass::LinacClass(string &s)
 * description : 	constructor for the LinacClass
 *
 * @param s	The class name
 */
//--------------------------------------------------------
LinacClass::LinacClass(string &s):Tango::DeviceClass(s)
{
	cout2 << "Entering LinacClass constructor" << endl;
	set_default_property();
	write_class_property();

	/*----- PROTECTED REGION ID(LinacClass::constructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::constructor

	cout2 << "Leaving LinacClass constructor" << endl;
}

//--------------------------------------------------------
/**
 * method : 		LinacClass::~LinacClass()
 * description : 	destructor for the LinacClass
 */
//--------------------------------------------------------
LinacClass::~LinacClass()
{
	/*----- PROTECTED REGION ID(LinacClass::destructor) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::destructor

	_instance = NULL;
}


//--------------------------------------------------------
/**
 * method : 		LinacClass::init
 * description : 	Create the object if not already done.
 *                  Otherwise, just return a pointer to the object
 *
 * @param	name	The class name
 */
//--------------------------------------------------------
LinacClass *LinacClass::init(const char *name)
{
	if (_instance == NULL)
	{
		try
		{
			string s(name);
			_instance = new LinacClass(s);
		}
		catch (bad_alloc &)
		{
			throw;
		}
	}
	return _instance;
}

//--------------------------------------------------------
/**
 * method : 		LinacClass::instance
 * description : 	Check if object already created,
 *                  and return a pointer to the object
 */
//--------------------------------------------------------
LinacClass *LinacClass::instance()
{
	if (_instance == NULL)
	{
		cerr << "Class is not initialised !!" << endl;
		exit(-1);
	}
	return _instance;
}



//===================================================================
//	Command execution method calls
//===================================================================
//--------------------------------------------------------
/**
 * method : 		OnClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *OnClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "OnClass::execute(): arrived" << endl;
	((static_cast<Linac *>(device))->on());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		OffClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *OffClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "OffClass::execute(): arrived" << endl;
	((static_cast<Linac *>(device))->off());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		StandbyClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *StandbyClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "StandbyClass::execute(): arrived" << endl;
	((static_cast<Linac *>(device))->standby());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		LowHeatingClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *LowHeatingClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "LowHeatingClass::execute(): arrived" << endl;
	((static_cast<Linac *>(device))->low_heating());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		AbortClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *AbortClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "AbortClass::execute(): arrived" << endl;
	((static_cast<Linac *>(device))->abort());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ResetClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ResetClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ResetClass::execute(): arrived" << endl;
	((static_cast<Linac *>(device))->reset());
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ReadDirNameClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ReadDirNameClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "ReadDirNameClass::execute(): arrived" << endl;
	return insert((static_cast<Linac *>(device))->read_dir_name());
}

//--------------------------------------------------------
/**
 * method : 		LoadFileClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *LoadFileClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "LoadFileClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<Linac *>(device))->load_file(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		SaveFileClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *SaveFileClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "SaveFileClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<Linac *>(device))->save_file(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		ForceSaveClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *ForceSaveClass::execute(Tango::DeviceImpl *device, const CORBA::Any &in_any)
{
	cout2 << "ForceSaveClass::execute(): arrived" << endl;
	Tango::DevString argin;
	extract(in_any, argin);
	((static_cast<Linac *>(device))->force_save(argin));
	return new CORBA::Any();
}

//--------------------------------------------------------
/**
 * method : 		GetPCTDeviceNameClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetPCTDeviceNameClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetPCTDeviceNameClass::execute(): arrived" << endl;
	return insert((static_cast<Linac *>(device))->get_pctdevice_name());
}

//--------------------------------------------------------
/**
 * method : 		GetICTDeviceNameClass::execute()
 * description : 	method to trigger the execution of the command.
 *
 * @param	device	The device on which the command must be executed
 * @param	in_any	The command input data
 *
 *	returns The command output data (packed in the Any object)
 */
//--------------------------------------------------------
CORBA::Any *GetICTDeviceNameClass::execute(Tango::DeviceImpl *device, TANGO_UNUSED(const CORBA::Any &in_any))
{
	cout2 << "GetICTDeviceNameClass::execute(): arrived" << endl;
	return insert((static_cast<Linac *>(device))->get_ictdevice_name());
}


//===================================================================
//	Properties management
//===================================================================
//--------------------------------------------------------
/**
 *	Method      : LinacClass::get_class_property()
 *	Description : Get the class property for specified name.
 */
//--------------------------------------------------------
Tango::DbDatum LinacClass::get_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_prop.size() ; i++)
		if (cl_prop[i].name == prop_name)
			return cl_prop[i];
	//	if not found, returns  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LinacClass::get_default_device_property()
 *	Description : Return the default value for device property.
 */
//--------------------------------------------------------
Tango::DbDatum LinacClass::get_default_device_property(string &prop_name)
{
	for (unsigned int i=0 ; i<dev_def_prop.size() ; i++)
		if (dev_def_prop[i].name == prop_name)
			return dev_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}

//--------------------------------------------------------
/**
 *	Method      : LinacClass::get_default_class_property()
 *	Description : Return the default value for class property.
 */
//--------------------------------------------------------
Tango::DbDatum LinacClass::get_default_class_property(string &prop_name)
{
	for (unsigned int i=0 ; i<cl_def_prop.size() ; i++)
		if (cl_def_prop[i].name == prop_name)
			return cl_def_prop[i];
	//	if not found, return  an empty DbDatum
	return Tango::DbDatum(prop_name);
}


//--------------------------------------------------------
/**
 *	Method      : LinacClass::set_default_property()
 *	Description : Set default property (class and device) for wizard.
 *                For each property, add to wizard property name and description.
 *                If default value has been set, add it to wizard property and
 *                store it in a DbDatum.
 */
//--------------------------------------------------------
void LinacClass::set_default_property()
{
	string	prop_name;
	string	prop_desc;
	string	prop_def;
	vector<string>	vect_data;

	//	Set Default Class Properties

	//	Set Default device Properties
	prop_name = "Dirname";
	prop_desc = "The operation files for the linac will be load and saved in that directory\nand its subfolders.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Startfile";
	prop_desc = "Name of the config file to be loaded at startup.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ICT_device";
	prop_desc = "ICT device on which we could read the current used for beamstop functionality.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PCT_device";
	prop_desc = "PCT device on which we could read the current used for\nbeamstop functionality only if we can`t read the taco resource\nsr/d-ct/1/name during the init.\nIf we can read this taco resource, we will use this resource as the PCT\ndevice to be read.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Sequencer";
	prop_desc = "Sequencer device name.";
	prop_def  = "";
	vect_data.clear();
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "ICT_limit";
	prop_desc = "Value used at startup as SRCT limit when ct_device = ICT.";
	prop_def  = "4.60";
	vect_data.clear();
	vect_data.push_back("4.60");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "PCT_limit";
	prop_desc = "Value used at startup as SRCT limit when ct_device = PCT.";
	prop_def  = "200.0";
	vect_data.clear();
	vect_data.push_back("200.0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Daresbury";
	prop_desc = "Name of the daresbury device.";
	prop_def  = "elin/intlk/0";
	vect_data.clear();
	vect_data.push_back("elin/intlk/0");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Pss_interlocks_list";
	prop_desc = "list of pss interlocks.";
	prop_def  = "3.3\n5.2\n17.4";
	vect_data.clear();
	vect_data.push_back("3.3");
	vect_data.push_back("5.2");
	vect_data.push_back("17.4");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
	prop_name = "Reset_devices_list";
	prop_desc = "List of devices to be reset when the command reset is called";
	prop_def  = "elin/master/seq\nelin/intlk/0\nelin/r-mod/reset\nelin/focus/klystron1\nelin/focus/klystron2\nelin/focus/beam1\nelin/focus/beam2\nelin/steer/1";
	vect_data.clear();
	vect_data.push_back("elin/master/seq");
	vect_data.push_back("elin/intlk/0");
	vect_data.push_back("elin/r-mod/reset");
	vect_data.push_back("elin/focus/klystron1");
	vect_data.push_back("elin/focus/klystron2");
	vect_data.push_back("elin/focus/beam1");
	vect_data.push_back("elin/focus/beam2");
	vect_data.push_back("elin/steer/1");
	if (prop_def.length()>0)
	{
		Tango::DbDatum	data(prop_name);
		data << vect_data ;
		dev_def_prop.push_back(data);
		add_wiz_dev_prop(prop_name, prop_desc,  prop_def);
	}
	else
		add_wiz_dev_prop(prop_name, prop_desc);
}

//--------------------------------------------------------
/**
 *	Method      : LinacClass::write_class_property()
 *	Description : Set class description fields as property in database
 */
//--------------------------------------------------------
void LinacClass::write_class_property()
{
	//	First time, check if database used
	if (Tango::Util::_UseDb == false)
		return;

	Tango::DbData	data;
	string	classname = get_name();
	string	header;
	string::size_type	start, end;

	//	Put title
	Tango::DbDatum	title("ProjectTitle");
	string	str_title("Linac");
	title << str_title;
	data.push_back(title);

	//	Put Description
	Tango::DbDatum	description("Description");
	vector<string>	str_desc;
	str_desc.push_back("This class will manage the high level object controlling the linac.");
	str_desc.push_back("This object will allow the executions of sequences to put the linac in ON,OFF,");
	str_desc.push_back("STANDBY or LOW HEATING STATE.");
	description << str_desc;
	data.push_back(description);

	//	put cvs or svn location
	string	filename("Linac");
	filename += "Class.cpp";

	// check for cvs information
	string	src_path(CvsPath);
	start = src_path.find("/");
	if (start!=string::npos)
	{
		end   = src_path.find(filename);
		if (end>start)
		{
			string	strloc = src_path.substr(start, end-start);
			//	Check if specific repository
			start = strloc.find("/cvsroot/");
			if (start!=string::npos && start>0)
			{
				string	repository = strloc.substr(0, start);
				if (repository.find("/segfs/")!=string::npos)
					strloc = "ESRF:" + strloc.substr(start, strloc.length()-start);
			}
			Tango::DbDatum	cvs_loc("cvs_location");
			cvs_loc << strloc;
			data.push_back(cvs_loc);
		}
	}

	// check for svn information
	else
	{
		string	src_path(SvnPath);
		start = src_path.find("://");
		if (start!=string::npos)
		{
			end = src_path.find(filename);
			if (end>start)
			{
				header = "$HeadURL: ";
				start = header.length();
				string	strloc = src_path.substr(start, (end-start));
				
				Tango::DbDatum	svn_loc("svn_location");
				svn_loc << strloc;
				data.push_back(svn_loc);
			}
		}
	}

	//	Get CVS or SVN revision tag
	
	// CVS tag
	string	tagname(TagName);
	header = "$Name: ";
	start = header.length();
	string	endstr(" $");
	
	end   = tagname.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strtag = tagname.substr(start, end-start);
		Tango::DbDatum	cvs_tag("cvs_tag");
		cvs_tag << strtag;
		data.push_back(cvs_tag);
	}
	
	// SVN tag
	string	svnpath(SvnPath);
	header = "$HeadURL: ";
	start = header.length();
	
	end   = svnpath.find(endstr);
	if (end!=string::npos && end>start)
	{
		string	strloc = svnpath.substr(start, end-start);
		
		string tagstr ("/tags/");
		start = strloc.find(tagstr);
		if ( start!=string::npos )
		{
			start = start + tagstr.length();
			end   = strloc.find(filename);
			string	strtag = strloc.substr(start, end-start-1);
			
			Tango::DbDatum	svn_tag("svn_tag");
			svn_tag << strtag;
			data.push_back(svn_tag);
		}
	}

	//	Get URL location
	string	httpServ(HttpServer);
	if (httpServ.length()>0)
	{
		Tango::DbDatum	db_doc_url("doc_url");
		db_doc_url << httpServ;
		data.push_back(db_doc_url);
	}

	//  Put inheritance
	Tango::DbDatum	inher_datum("InheritedFrom");
	vector<string> inheritance;
	inheritance.push_back("TANGO_BASE_CLASS");
	inher_datum << inheritance;
	data.push_back(inher_datum);

	//	Call database and and values
	get_db_class()->put_property(data);
}

//===================================================================
//	Factory methods
//===================================================================

//--------------------------------------------------------
/**
 *	Method      : LinacClass::device_factory()
 *	Description : Create the device object(s)
 *                and store them in the device list
 */
//--------------------------------------------------------
void LinacClass::device_factory(const Tango::DevVarStringArray *devlist_ptr)
{
	/*----- PROTECTED REGION ID(LinacClass::device_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::device_factory_before

	//	Create devices and add it into the device list
	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		cout4 << "Device name : " << (*devlist_ptr)[i].in() << endl;
		device_list.push_back(new Linac(this, (*devlist_ptr)[i]));
	}

	//	Manage dynamic attributes if any
	erase_dynamic_attributes(devlist_ptr, get_class_attr()->get_attr_list());

	//	Export devices to the outside world
	for (unsigned long i=1 ; i<=devlist_ptr->length() ; i++)
	{
		//	Add dynamic attributes if any
		Linac *dev = static_cast<Linac *>(device_list[device_list.size()-i]);
		dev->add_dynamic_attributes();

		//	Check before if database used.
		if ((Tango::Util::_UseDb == true) && (Tango::Util::_FileDb == false))
			export_device(dev);
		else
			export_device(dev, dev->get_name().c_str());
	}

	/*----- PROTECTED REGION ID(LinacClass::device_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::device_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LinacClass::attribute_factory()
 *	Description : Create the attribute object(s)
 *                and store them in the attribute list
 */
//--------------------------------------------------------
void LinacClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	/*----- PROTECTED REGION ID(LinacClass::attribute_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::attribute_factory_before
	//	Attribute : File
	FileAttrib	*file = new FileAttrib();
	Tango::UserDefaultAttrProp	file_prop;
	file_prop.set_description("Configuration file");
	//	label	not set for File
	//	unit	not set for File
	//	standard_unit	not set for File
	//	display_unit	not set for File
	//	format	not set for File
	//	max_value	not set for File
	//	min_value	not set for File
	//	max_alarm	not set for File
	//	min_alarm	not set for File
	//	max_warning	not set for File
	//	min_warning	not set for File
	//	delta_t	not set for File
	//	delta_val	not set for File
	
	file->set_default_properties(file_prop);
	//	Not Polled
	file->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(file);

	//	Attribute : SRCT_Limit
	SRCT_LimitAttrib	*srct_limit = new SRCT_LimitAttrib();
	Tango::UserDefaultAttrProp	srct_limit_prop;
	srct_limit_prop.set_description("The set value of this attribute corresponds to the maximum\nallowed threshold for the current in the SR.\nIf the SR current is greater than the set value of this attribute,\nthe linac is put in Standby state and cannot be switched ON.\n\nThe read value of this attribute is the present SR current value.");
	srct_limit_prop.set_label("SRCT limit");
	srct_limit_prop.set_unit("mA");
	srct_limit_prop.set_standard_unit("mA");
	srct_limit_prop.set_display_unit("mA");
	srct_limit_prop.set_format("%5.2f");
	//	max_value	not set for SRCT_Limit
	srct_limit_prop.set_min_value("0");
	//	max_alarm	not set for SRCT_Limit
	//	min_alarm	not set for SRCT_Limit
	//	max_warning	not set for SRCT_Limit
	//	min_warning	not set for SRCT_Limit
	//	delta_t	not set for SRCT_Limit
	//	delta_val	not set for SRCT_Limit
	
	srct_limit->set_default_properties(srct_limit_prop);
	srct_limit->set_polling_period(1000);
	srct_limit->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(srct_limit);

	//	Attribute : CT_device
	CT_deviceAttrib	*ct_device = new CT_deviceAttrib();
	Tango::UserDefaultAttrProp	ct_device_prop;
	ct_device_prop.set_description("Current Transformer on which we read the current used \nfor the beam_stop functionality.\nPossible values are PCT or ICT.");
	ct_device_prop.set_label("CT device");
	//	unit	not set for CT_device
	//	standard_unit	not set for CT_device
	//	display_unit	not set for CT_device
	//	format	not set for CT_device
	//	max_value	not set for CT_device
	//	min_value	not set for CT_device
	//	max_alarm	not set for CT_device
	//	min_alarm	not set for CT_device
	//	max_warning	not set for CT_device
	//	min_warning	not set for CT_device
	//	delta_t	not set for CT_device
	//	delta_val	not set for CT_device
	
	ct_device->set_default_properties(ct_device_prop);
	//	Not Polled
	ct_device->set_disp_level(Tango::OPERATOR);
	ct_device->set_memorized();
	ct_device->set_memorized_init(true);
	att_list.push_back(ct_device);

	//	Attribute : CT_Current
	CT_CurrentAttrib	*ct_current = new CT_CurrentAttrib();
	Tango::UserDefaultAttrProp	ct_current_prop;
	//	description	not set for CT_Current
	//	label	not set for CT_Current
	//	unit	not set for CT_Current
	//	standard_unit	not set for CT_Current
	//	display_unit	not set for CT_Current
	//	format	not set for CT_Current
	//	max_value	not set for CT_Current
	//	min_value	not set for CT_Current
	//	max_alarm	not set for CT_Current
	//	min_alarm	not set for CT_Current
	//	max_warning	not set for CT_Current
	//	min_warning	not set for CT_Current
	//	delta_t	not set for CT_Current
	//	delta_val	not set for CT_Current
	
	ct_current->set_default_properties(ct_current_prop);
	//	Not Polled
	ct_current->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ct_current);

	//	Attribute : ShortStatus
	ShortStatusAttrib	*shortstatus = new ShortStatusAttrib();
	Tango::UserDefaultAttrProp	shortstatus_prop;
	shortstatus_prop.set_description("A short description of the status of the linac.");
	shortstatus_prop.set_label("shortStatus");
	//	unit	not set for ShortStatus
	//	standard_unit	not set for ShortStatus
	//	display_unit	not set for ShortStatus
	//	format	not set for ShortStatus
	//	max_value	not set for ShortStatus
	//	min_value	not set for ShortStatus
	//	max_alarm	not set for ShortStatus
	//	min_alarm	not set for ShortStatus
	//	max_warning	not set for ShortStatus
	//	min_warning	not set for ShortStatus
	//	delta_t	not set for ShortStatus
	//	delta_val	not set for ShortStatus
	
	shortstatus->set_default_properties(shortstatus_prop);
	//	Not Polled
	shortstatus->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(shortstatus);

	//	Attribute : PCT_device
	PCT_deviceAttrib	*pct_device = new PCT_deviceAttrib();
	Tango::UserDefaultAttrProp	pct_device_prop;
	pct_device_prop.set_description("Name of the PCT device read via the \nproperty sr/d-ct/1/CurrentDeviceName");
	pct_device_prop.set_label("PCT device");
	//	unit	not set for PCT_device
	//	standard_unit	not set for PCT_device
	//	display_unit	not set for PCT_device
	//	format	not set for PCT_device
	//	max_value	not set for PCT_device
	//	min_value	not set for PCT_device
	//	max_alarm	not set for PCT_device
	//	min_alarm	not set for PCT_device
	//	max_warning	not set for PCT_device
	//	min_warning	not set for PCT_device
	//	delta_t	not set for PCT_device
	//	delta_val	not set for PCT_device
	
	pct_device->set_default_properties(pct_device_prop);
	//	Not Polled
	pct_device->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(pct_device);

	//	Attribute : ICT_device
	ICT_deviceAttrib	*ict_device = new ICT_deviceAttrib();
	Tango::UserDefaultAttrProp	ict_device_prop;
	ict_device_prop.set_description("Name of the PCT device read via the \nproperty sr/d-ct/2/CurrentDeviceName");
	ict_device_prop.set_label("ICT device");
	//	unit	not set for ICT_device
	//	standard_unit	not set for ICT_device
	//	display_unit	not set for ICT_device
	//	format	not set for ICT_device
	//	max_value	not set for ICT_device
	//	min_value	not set for ICT_device
	//	max_alarm	not set for ICT_device
	//	min_alarm	not set for ICT_device
	//	max_warning	not set for ICT_device
	//	min_warning	not set for ICT_device
	//	delta_t	not set for ICT_device
	//	delta_val	not set for ICT_device
	
	ict_device->set_default_properties(ict_device_prop);
	//	Not Polled
	ict_device->set_disp_level(Tango::OPERATOR);
	//	Not Memorized
	att_list.push_back(ict_device);


	//	Create a list of static attributes
	create_static_attribute_list(get_class_attr()->get_attr_list());
	/*----- PROTECTED REGION ID(LinacClass::attribute_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::attribute_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LinacClass::pipe_factory()
 *	Description : Create the pipe object(s)
 *                and store them in the pipe list
 */
//--------------------------------------------------------
void LinacClass::pipe_factory()
{
	/*----- PROTECTED REGION ID(LinacClass::pipe_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::pipe_factory_before
	/*----- PROTECTED REGION ID(LinacClass::pipe_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::pipe_factory_after
}
//--------------------------------------------------------
/**
 *	Method      : LinacClass::command_factory()
 *	Description : Create the command object(s)
 *                and store them in the command list
 */
//--------------------------------------------------------
void LinacClass::command_factory()
{
	/*----- PROTECTED REGION ID(LinacClass::command_factory_before) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::command_factory_before


	//	Command On
	OnClass	*pOnCmd =
		new OnClass("On",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pOnCmd);

	//	Command Off
	OffClass	*pOffCmd =
		new OffClass("Off",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pOffCmd);

	//	Command Standby
	StandbyClass	*pStandbyCmd =
		new StandbyClass("Standby",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pStandbyCmd);

	//	Command LowHeating
	LowHeatingClass	*pLowHeatingCmd =
		new LowHeatingClass("LowHeating",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pLowHeatingCmd);

	//	Command Abort
	AbortClass	*pAbortCmd =
		new AbortClass("Abort",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pAbortCmd);

	//	Command Reset
	ResetClass	*pResetCmd =
		new ResetClass("Reset",
			Tango::DEV_VOID, Tango::DEV_VOID,
			"",
			"",
			Tango::OPERATOR);
	command_list.push_back(pResetCmd);

	//	Command ReadDirName
	ReadDirNameClass	*pReadDirNameCmd =
		new ReadDirNameClass("ReadDirName",
			Tango::DEV_VOID, Tango::DEV_STRING,
			"",
			"The name of the directory under which the files are load and saved.",
			Tango::OPERATOR);
	command_list.push_back(pReadDirNameCmd);

	//	Command LoadFile
	LoadFileClass	*pLoadFileCmd =
		new LoadFileClass("LoadFile",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"File to load",
			"",
			Tango::OPERATOR);
	command_list.push_back(pLoadFileCmd);

	//	Command SaveFile
	SaveFileClass	*pSaveFileCmd =
		new SaveFileClass("SaveFile",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Name of the file (relative to dirname property)",
			"",
			Tango::OPERATOR);
	command_list.push_back(pSaveFileCmd);

	//	Command ForceSave
	ForceSaveClass	*pForceSaveCmd =
		new ForceSaveClass("ForceSave",
			Tango::DEV_STRING, Tango::DEV_VOID,
			"Name of the file (relative to dirname property)",
			"",
			Tango::OPERATOR);
	command_list.push_back(pForceSaveCmd);

	//	Command GetPCTDeviceName
	GetPCTDeviceNameClass	*pGetPCTDeviceNameCmd =
		new GetPCTDeviceNameClass("GetPCTDeviceName",
			Tango::DEV_VOID, Tango::DEV_STRING,
			"none",
			"PCT device name",
			Tango::OPERATOR);
	command_list.push_back(pGetPCTDeviceNameCmd);

	//	Command GetICTDeviceName
	GetICTDeviceNameClass	*pGetICTDeviceNameCmd =
		new GetICTDeviceNameClass("GetICTDeviceName",
			Tango::DEV_VOID, Tango::DEV_STRING,
			"none",
			"PCT device name",
			Tango::OPERATOR);
	command_list.push_back(pGetICTDeviceNameCmd);

	/*----- PROTECTED REGION ID(LinacClass::command_factory_after) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::command_factory_after
}

//===================================================================
//	Dynamic attributes related methods
//===================================================================

//--------------------------------------------------------
/**
 * method : 		LinacClass::create_static_attribute_list
 * description : 	Create the a list of static attributes
 *
 * @param	att_list	the ceated attribute list
 */
//--------------------------------------------------------
void LinacClass::create_static_attribute_list(vector<Tango::Attr *> &att_list)
{
	for (unsigned long i=0 ; i<att_list.size() ; i++)
	{
		string att_name(att_list[i]->get_name());
		transform(att_name.begin(), att_name.end(), att_name.begin(), ::tolower);
		defaultAttList.push_back(att_name);
	}

	cout2 << defaultAttList.size() << " attributes in default list" << endl;

	/*----- PROTECTED REGION ID(LinacClass::create_static_att_list) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::create_static_att_list
}


//--------------------------------------------------------
/**
 * method : 		LinacClass::erase_dynamic_attributes
 * description : 	delete the dynamic attributes if any.
 *
 * @param	devlist_ptr	the device list pointer
 * @param	list of all attributes
 */
//--------------------------------------------------------
void LinacClass::erase_dynamic_attributes(const Tango::DevVarStringArray *devlist_ptr, vector<Tango::Attr *> &att_list)
{
	Tango::Util *tg = Tango::Util::instance();

	for (unsigned long i=0 ; i<devlist_ptr->length() ; i++)
	{
		Tango::DeviceImpl *dev_impl = tg->get_device_by_name(((string)(*devlist_ptr)[i]).c_str());
		Linac *dev = static_cast<Linac *> (dev_impl);

		vector<Tango::Attribute *> &dev_att_list = dev->get_device_attr()->get_attribute_list();
		vector<Tango::Attribute *>::iterator ite_att;
		for (ite_att=dev_att_list.begin() ; ite_att != dev_att_list.end() ; ++ite_att)
		{
			string att_name((*ite_att)->get_name_lower());
			if ((att_name == "state") || (att_name == "status"))
				continue;
			vector<string>::iterator ite_str = find(defaultAttList.begin(), defaultAttList.end(), att_name);
			if (ite_str == defaultAttList.end())
			{
				cout2 << att_name << " is a UNWANTED dynamic attribute for device " << (*devlist_ptr)[i] << endl;
				Tango::Attribute &att = dev->get_device_attr()->get_attr_by_name(att_name.c_str());
				dev->remove_attribute(att_list[att.get_attr_idx()], true, false);
				--ite_att;
			}
		}
	}
	/*----- PROTECTED REGION ID(LinacClass::erase_dynamic_attributes) ENABLED START -----*/
	
	/*----- PROTECTED REGION END -----*/	//	LinacClass::erase_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Method      : LinacClass::get_attr_by_name()
 *	Description : returns Tango::Attr * object found by name
 */
//--------------------------------------------------------
Tango::Attr *LinacClass::get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname)
{
	vector<Tango::Attr *>::iterator it;
	for (it=att_list.begin() ; it<att_list.end() ; ++it)
		if ((*it)->get_name()==attname)
			return (*it);
	//	Attr does not exist
	return NULL;
}


/*----- PROTECTED REGION ID(LinacClass::Additional Methods) ENABLED START -----*/

/*----- PROTECTED REGION END -----*/	//	LinacClass::Additional Methods
} //	namespace
