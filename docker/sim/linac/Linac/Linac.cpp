/*----- PROTECTED REGION ID(Linac.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        Linac.cpp
//
// description : C++ source for the Linac class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Linac are implemented in this file.
//
// project :     Linac
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <tango.h>
#include <Linac.h>
#include <LinacClass.h>
#include <LinacStateThread.h>
#include <BeamStopThread.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/time.h>

/*----- PROTECTED REGION END -----*/	//	Linac.cpp

/**
 *  Linac class description:
 *    This class will manage the high level object controlling the linac.
 *    This object will allow the executions of sequences to put the linac in ON,OFF,
 *    STANDBY or LOW HEATING STATE.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name      |  Method name
//================================================================
//  State             |  dev_state
//  Status            |  dev_status
//  On                |  on
//  Off               |  off
//  Standby           |  standby
//  LowHeating        |  low_heating
//  Abort             |  abort
//  Reset             |  reset
//  ReadDirName       |  read_dir_name
//  LoadFile          |  load_file
//  SaveFile          |  save_file
//  ForceSave         |  force_save
//  GetPCTDeviceName  |  get_pctdevice_name
//  GetICTDeviceName  |  get_ictdevice_name
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  File         |  Tango::DevString	Scalar
//  SRCT_Limit   |  Tango::DevDouble	Scalar
//  CT_device    |  Tango::DevString	Scalar
//  CT_Current   |  Tango::DevDouble	Scalar
//  ShortStatus  |  Tango::DevString	Scalar
//  PCT_device   |  Tango::DevString	Scalar
//  ICT_device   |  Tango::DevString	Scalar
//================================================================

namespace Linac_ns
{
/*----- PROTECTED REGION ID(Linac::namespace_starting) ENABLED START -----*/

//	static initializations
double get_ticks();

/*----- PROTECTED REGION END -----*/	//	Linac::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : Linac::Linac()
 *	Description : Constructors for a Tango device
 *                implementing the classLinac
 */
//--------------------------------------------------------
Linac::Linac(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Linac::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Linac::constructor_1
}
//--------------------------------------------------------
Linac::Linac(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(Linac::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Linac::constructor_2
}
//--------------------------------------------------------
Linac::Linac(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(Linac::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Linac::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : Linac::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Linac::delete_device()
{
	DEBUG_STREAM << "Linac::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	//	Delete device's allocated object
	CORBA::string_free(*attr_File_read);
	delete attr_File_read;
	delete attr_SRCT_Limit_read;
	delete attr_CT_Current_read;
	CORBA::string_free(*attr_CT_device_read);
	delete attr_CT_device_read;
	CORBA::string_free(*attr_ShortStatus_read);
	delete attr_ShortStatus_read;
	delete PCTds;
	delete ICTds;
	delete Sequencerds;
	delete Daresburyds;
	delete myself;
	{
		omni_mutex_lock l(beamstop_mutex);
		killbeamstopthread = true;
	}
	{
		omni_mutex_lock l(mutex);
		killthread = true;
	}
	delete reset_devices;
	beamstop_thread->join(NULL);
	state_thread->join(NULL);

	/*----- PROTECTED REGION END -----*/	//	Linac::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : Linac::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void Linac::init_device()
{
	DEBUG_STREAM << "Linac::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
        {
		omni_mutex_lock l(mutex);
		gun_aux_name 		= 	"elin/gun/aux";
		gun_name		=	"elin/beam/run";
		gun_HV_name		=	"elin/gun/hv";
		rf_run_name		=	"elin/rf/run";
		cooling_name		=	"elin/cool/1";
		mod1_aux_name		=	"elin/mod1/aux";
		mod2_aux_name		=	"elin/mod2/aux";
		mod1_HV_name		=	"elin/mod1/hv";
		mod2_HV_name		=	"elin/mod2/hv";
		mod1_name		=	"elin/mod1/run";
		mod2_name		=	"elin/mod2/run";
		focus_klystron1_name	= 	"elin/focus/klystron1";
		focus_klystron2_name	= 	"elin/focus/klystron2";
		focus_beam1_name	=	"elin/focus/beam1";
		focus_beam2_name	=	"elin/focus/beam2";
		focus_steer_name	=	"elin/steer/1";
		
		// New Gun addition.
		gun_focus_b1b4_tdk_name 	="elin/focus/gun";
		gun_steerer_tdk_name		="elin/steer/gun";
		prebuncher_steerer_tdk_name ="elin/steer/pbunch";		
		
                
		killthread = false;
		thestate = Tango::UNKNOWN;		
	}
	{
		omni_mutex_lock l(beamstop_mutex);
		killbeamstopthread = false;
		pct_has_changed = false;
		ict_has_changed = false;
		BeamStopProblem = false;
		BeamStopStatus = "";
	}
	StateGivenByThread = Tango::UNKNOWN;
	SequencerState = Tango::UNKNOWN;
	in_init = true;
	last_cmd = NO_CMD;
	linac_permit = true;


	/*----- PROTECTED REGION END -----*/	//	Linac::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(Linac::init_device) ENABLED START -----*/
	
	//	Initialize device
	
	reset_devices = new Tango::Group("reset_devices");
	int nb_reset_devices = reset_devices_list.size();
	for(int i=0; i<nb_reset_devices; i++)
	{
		reset_devices->add(reset_devices_list[i].c_str());
		DEBUG_STREAM << "add " << reset_devices_list[i] << " device to reset_devices group" << endl;
	}
	
	attr_SRCT_Limit_read = new Tango::DevDouble;
	char * myname = name();
	myself = new Tango::DeviceProxy(myname);
	delete [] myname;
	try{myself->set_transparency_reconnection(true);}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
	try
	{
		Sequencerds = new Tango::DeviceProxy(sequencer.c_str());
		Sequencerds->set_transparency_reconnection(true);
	}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
	try
	{
		Daresburyds = new Tango::DeviceProxy(daresbury.c_str());
		Daresburyds->set_transparency_reconnection(true);
	}
	catch(Tango::DevFailed &e){ Tango::Except::print_exception(e);}
#ifdef SIMU
	set_state(Tango::UNKNOWN);
#endif


	attr_ShortStatus_read = new Tango::DevString;
	*attr_ShortStatus_read = CORBA::string_dup("UNKNOWN");
	attr_CT_device_read = new Tango::DevString;
	*attr_CT_device_read = CORBA::string_dup("PCT");
	attr_CT_Current_read = new Tango::DevDouble;
	*attr_CT_Current_read = 0.0;
	attr_PCT_device_read = NULL;
	attr_ICT_device_read = NULL;
	try
	{
		PCTds = new Tango::DeviceProxy(pCT_device.c_str());
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		PCTds = NULL;
	}
	// look which PCT device is read by the clone device
	try
	{
		get_pctdevice_name();
		attr_PCT_device_read = new Tango::DevString;
		*attr_PCT_device_read = CORBA::string_dup(pCT_device.c_str());
	}
	catch(Tango::DevFailed &e)
	{
		cout << "Problem importing the PCT device (sr/d-ct/1/CurrentDeviceName property in the Tango database) cannot import device" << endl;
		cout << "Cannot import also the PCT device defined in the Tango database (elin/master/op/PCT_device property)" << endl;
		throw;
	}
	
	
	try
	{
		ICTds = new Tango::DeviceProxy(iCT_device.c_str());
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		ICTds = NULL;
	}
	// look which ICT device is read by the clone device
	try
	{
		get_ictdevice_name();
		attr_ICT_device_read = new Tango::DevString;
		*attr_ICT_device_read = CORBA::string_dup(iCT_device.c_str());
	}
	catch(Tango::DevFailed &e)
	{
		cout << "Problem importing the ICT device (sr/d-ct/1/CurrentDeviceName property in the Tango database) cannot import device" << endl;
		cout << "Cannot import also the ICT device defined in the Tango database (elin/master/op/ICT_device property)" << endl;
		throw;
	}
	

	attr_File_read = new Tango::DevString;
	*attr_File_read = CORBA::string_alloc(14);
	strcpy(*attr_File_read,"NO FILE LOADED");

	Tango::MultiAttribute		*attr_list;
	attr_list = get_device_attr();
	Tango::WAttribute	&attr_srct_limit = attr_list->get_w_attr_by_name ("SRCT_Limit");
	attr_srct_limit.get_write_value(attr_SRCT_Limit_write);
	*attr_SRCT_Limit_read = attr_SRCT_Limit_write;
	
	// Start the sequence thread
	//
	state_thread = new LinacStateThread(this, mutex);
	// Start the BeamStop thread
	//
	beamstop_thread = new BeamStopThread(this, beamstop_mutex,mutex);
	in_init = false;
	DEBUG_STREAM << "Linac::init_device(): exiting ..." <<endl;

	/*----- PROTECTED REGION END -----*/	//	Linac::init_device
}

//--------------------------------------------------------
/**
 *	Method      : Linac::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void Linac::get_device_property()
{
	/*----- PROTECTED REGION ID(Linac::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	#ifdef SIMU
	dirname	  =  "/users/bourtemb/testlinac/linac";
	pCT_device = "//orion:10000/sr/d-ct/pct-id10";
	iCT_device = "//orion:10000/sr/d-ct/ict1";
#else
	pCT_device = "sr/d-ct/pct-id10";
	iCT_device = "sr/d-ct/ict1";
	dirname	  =  "/operation/linac/conf";
#endif
	sequencer = "elin/master/seq";
	startfile = "NO FILE LOADED";

	/*----- PROTECTED REGION END -----*/	//	Linac::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Dirname"));
	dev_prop.push_back(Tango::DbDatum("Startfile"));
	dev_prop.push_back(Tango::DbDatum("ICT_device"));
	dev_prop.push_back(Tango::DbDatum("PCT_device"));
	dev_prop.push_back(Tango::DbDatum("Sequencer"));
	dev_prop.push_back(Tango::DbDatum("ICT_limit"));
	dev_prop.push_back(Tango::DbDatum("PCT_limit"));
	dev_prop.push_back(Tango::DbDatum("Daresbury"));
	dev_prop.push_back(Tango::DbDatum("Pss_interlocks_list"));
	dev_prop.push_back(Tango::DbDatum("Reset_devices_list"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on LinacClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		LinacClass	*ds_class =
			(static_cast<LinacClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Dirname from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  dirname;
		else {
			//	Try to initialize Dirname from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  dirname;
		}
		//	And try to extract Dirname value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  dirname;

		//	Try to initialize Startfile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  startfile;
		else {
			//	Try to initialize Startfile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  startfile;
		}
		//	And try to extract Startfile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  startfile;

		//	Try to initialize ICT_device from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  iCT_device;
		else {
			//	Try to initialize ICT_device from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  iCT_device;
		}
		//	And try to extract ICT_device value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  iCT_device;

		//	Try to initialize PCT_device from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pCT_device;
		else {
			//	Try to initialize PCT_device from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pCT_device;
		}
		//	And try to extract PCT_device value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pCT_device;

		//	Try to initialize Sequencer from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  sequencer;
		else {
			//	Try to initialize Sequencer from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  sequencer;
		}
		//	And try to extract Sequencer value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sequencer;

		//	Try to initialize ICT_limit from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  iCT_limit;
		else {
			//	Try to initialize ICT_limit from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  iCT_limit;
		}
		//	And try to extract ICT_limit value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  iCT_limit;

		//	Try to initialize PCT_limit from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pCT_limit;
		else {
			//	Try to initialize PCT_limit from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pCT_limit;
		}
		//	And try to extract PCT_limit value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pCT_limit;

		//	Try to initialize Daresbury from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  daresbury;
		else {
			//	Try to initialize Daresbury from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  daresbury;
		}
		//	And try to extract Daresbury value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  daresbury;

		//	Try to initialize Pss_interlocks_list from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  pss_interlocks_list;
		else {
			//	Try to initialize Pss_interlocks_list from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  pss_interlocks_list;
		}
		//	And try to extract Pss_interlocks_list value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pss_interlocks_list;

		//	Try to initialize Reset_devices_list from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  reset_devices_list;
		else {
			//	Try to initialize Reset_devices_list from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  reset_devices_list;
		}
		//	And try to extract Reset_devices_list value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  reset_devices_list;

	}

	/*----- PROTECTED REGION ID(Linac::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	INFO_STREAM << "Dirname            = " << dirname	<< endl;
	INFO_STREAM << "Startfile          = " << startfile	<< endl;
	INFO_STREAM << "PCT device         = " << pCT_device	<< endl;
	INFO_STREAM << "ICT device         = " << iCT_device	<< endl;
	INFO_STREAM << "Sequencer device   = " << sequencer	<< endl;
	INFO_STREAM << "PCT limit          = " << pCT_limit	<< endl;
	INFO_STREAM << "ICT limit          = " << iCT_limit	<< endl;
	for(unsigned int i = 0; i<reset_devices_list.size(); i++)
		INFO_STREAM << "reset devices list = " << reset_devices_list[i] << endl;

	/*----- PROTECTED REGION END -----*/	//	Linac::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : Linac::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Linac::always_executed_hook()
{
	DEBUG_STREAM << "Linac::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	Linac::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : Linac::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Linac::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Linac::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	//	Add your own code here

	/*----- PROTECTED REGION END -----*/	//	Linac::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : Linac::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void Linac::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Linac::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Linac::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute File related method
 *	Description: Configuration file
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::read_File(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Linac::read_File(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_File) ENABLED START -----*/
	attr.set_value(attr_File_read);

	if(strcasecmp(*attr_File_read,"NO FILE LOADED") == 0)
		attr.set_quality(Tango::ATTR_ALARM);
	bool load_file_OK = false;
	try
	{
		Tango::DeviceAttribute isFileLoaded = Sequencerds->read_attribute("isFileLoaded");
		isFileLoaded >> load_file_OK;
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
	}
	if(load_file_OK == false)
		attr.set_quality(Tango::ATTR_ALARM);

	/*----- PROTECTED REGION END -----*/	//	Linac::read_File
}
//--------------------------------------------------------
/**
 *	Read attribute SRCT_Limit related method
 *	Description: The set value of this attribute corresponds to the maximum\nallowed threshold for the current in the SR.\nIf the SR current is greater than the set value of this attribute,\nthe linac is put in Standby state and cannot be switched ON.\n\nThe read value of this attribute is the present SR current value.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::read_SRCT_Limit(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Linac::read_SRCT_Limit(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_SRCT_Limit) ENABLED START -----*/
	attr.set_value(attr_SRCT_Limit_read);

	/*----- PROTECTED REGION END -----*/	//	Linac::read_SRCT_Limit
}
//--------------------------------------------------------
/**
 *	Write attribute SRCT_Limit related method
 *	Description: The set value of this attribute corresponds to the maximum\nallowed threshold for the current in the SR.\nIf the SR current is greater than the set value of this attribute,\nthe linac is put in Standby state and cannot be switched ON.\n\nThe read value of this attribute is the present SR current value.
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::write_SRCT_Limit(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Linac::write_SRCT_Limit(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevDouble	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(Linac::write_SRCT_Limit) ENABLED START -----*/
	{
		omni_mutex_lock l(beamstop_mutex);
		*attr_SRCT_Limit_read = w_val;
	}
	if(!pctselected)
	{
		iCT_limit = w_val;
		try
		{
			Tango::DbData data;
			data.clear();
			data.push_back(Tango::DbDatum("ict_limit"));
			data[0] << iCT_limit;
			get_db_device()->put_property(data);
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
		}
		catch(...)
		{
			ERROR_STREAM << "Error saving ict_limit property in database" << endl;
		}
	}
	else
	{
		pCT_limit = w_val;
		try
		{
			Tango::DbData data;
			data.clear();
			data.push_back(Tango::DbDatum("pct_limit"));
			data[0] << pCT_limit;
			get_db_device()->put_property(data);
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
		}
		catch(...)
		{
			ERROR_STREAM << "Error saving pct_limit property in database" << endl;
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Linac::write_SRCT_Limit
}
//--------------------------------------------------------
/**
 *	Read attribute CT_device related method
 *	Description: Current Transformer on which we read the current used \nfor the beam_stop functionality.\nPossible values are PCT or ICT.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::read_CT_device(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Linac::read_CT_device(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_CT_device) ENABLED START -----*/
	attr.set_value(attr_CT_device_read);

	/*----- PROTECTED REGION END -----*/	//	Linac::read_CT_device
}
//--------------------------------------------------------
/**
 *	Write attribute CT_device related method
 *	Description: Current Transformer on which we read the current used \nfor the beam_stop functionality.\nPossible values are PCT or ICT.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::write_CT_device(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Linac::write_CT_device(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevString	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(Linac::write_CT_device) ENABLED START -----*/
	
	if((strcasecmp(w_val,"PCT") != 0) && (strcasecmp(w_val,"ICT") != 0))
	{
		Tango::Except::throw_exception 
		((const char *)"InvalidValue",
		(const char *)"Possible values for CT_device are \"PCT\" or \"ICT\"",
		(const char *)"Linac::write_CT_device()");
	}
	
	CORBA::string_free(*attr_CT_device_read);
	*attr_CT_device_read = CORBA::string_dup(w_val);
	
	if(strcasecmp(*attr_CT_device_read,"ICT") == 0)
	{
		{
			omni_mutex_lock l(beamstop_mutex);
			pctselectedshared = false;
			*attr_SRCT_Limit_read = attr_SRCT_Limit_write = iCT_limit;
		}
		pctselected = false;
	}
	else
	{
		{
			omni_mutex_lock l(beamstop_mutex);
			pctselectedshared = true;
			*attr_SRCT_Limit_read = attr_SRCT_Limit_write = pCT_limit;
		}
		pctselected = true;
	}
	// update SRCT_Limit set value
	try
	{
		Tango::MultiAttribute		*attr_list;
		attr_list = get_device_attr();
		Tango::WAttribute	&attr_srct_limit = attr_list->get_w_attr_by_name ("SRCT_Limit");
		attr_srct_limit.set_write_value(attr_SRCT_Limit_write);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
	}

	/*----- PROTECTED REGION END -----*/	//	Linac::write_CT_device
}
//--------------------------------------------------------
/**
 *	Read attribute CT_Current related method
 *	Description: 
 *
 *	Data type:	Tango::DevDouble
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::read_CT_Current(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Linac::read_CT_Current(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_CT_Current) ENABLED START -----*/
	// Read the CT Current 
	if(pctselected)
	{
		Tango::DevDouble sr_current;
		try
		{
			//Tango::DeviceAttribute attr_value = PCTds->read_attribute("sig_current");
			Tango::DeviceAttribute attr_value = PCTds->read_attribute("Current");
			attr_value >> sr_current;
			CTread = sr_current;
		}
		catch(...)
		{
			ERROR_STREAM << "Error reading PCT's sig_current attribute" << endl;
			throw;
		}
	}
	else
	{
		// read on ICT device
		Tango::DevDouble sr_current;
		try
		{
			Tango::DeviceAttribute attr_value = ICTds->read_attribute("current");
			attr_value >> sr_current;
			CTread = sr_current;
		}
		catch(...)
		{
			ERROR_STREAM << "Error reading ICT's current attribute" << endl;
			throw;
		}
	}
	*attr_CT_Current_read = CTread;
	attr.set_value(attr_CT_Current_read);

	if(CTread >= attr_SRCT_Limit_write)
	{
		overcurrent = true;
		attr.set_quality(Tango::ATTR_ALARM);
	}
	else
	{
		overcurrent = false;
	}

	/*----- PROTECTED REGION END -----*/	//	Linac::read_CT_Current
}
//--------------------------------------------------------
/**
 *	Read attribute ShortStatus related method
 *	Description: A short description of the status of the linac.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::read_ShortStatus(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Linac::read_ShortStatus(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_ShortStatus) ENABLED START -----*/
	CORBA::string_free(*attr_ShortStatus_read);
	*attr_ShortStatus_read = CORBA::string_dup(shortstatus.c_str());
	attr.set_value(attr_ShortStatus_read);

	/*----- PROTECTED REGION END -----*/	//	Linac::read_ShortStatus
}
//--------------------------------------------------------
/**
 *	Read attribute PCT_device related method
 *	Description: Name of the PCT device read via the \nproperty sr/d-ct/1/CurrentDeviceName
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::read_PCT_device(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Linac::read_PCT_device(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_PCT_device) ENABLED START -----*/
	if(PCTds == NULL)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	CORBA::string_free(*attr_PCT_device_read);
	*attr_PCT_device_read = CORBA::string_dup(pCT_device.c_str());
	attr.set_value(attr_PCT_device_read);

	/*----- PROTECTED REGION END -----*/	//	Linac::read_PCT_device
}
//--------------------------------------------------------
/**
 *	Read attribute ICT_device related method
 *	Description: Name of the PCT device read via the \nproperty sr/d-ct/2/CurrentDeviceName
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Linac::read_ICT_device(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Linac::read_ICT_device(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Linac::read_ICT_device) ENABLED START -----*/
	if(ICTds == NULL)
	{
		attr.set_quality(Tango::ATTR_INVALID);
		return;
	}
	CORBA::string_free(*attr_ICT_device_read);
	*attr_ICT_device_read = CORBA::string_dup(iCT_device.c_str());
	attr.set_value(attr_ICT_device_read);

	/*----- PROTECTED REGION END -----*/	//	Linac::read_ICT_device
}

//--------------------------------------------------------
/**
 *	Method      : Linac::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Linac::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Linac::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	Linac::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command State related method
 *	Description: This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 *	@returns State Code
 */
//--------------------------------------------------------
Tango::DevState Linac::dev_state()
{
	DEBUG_STREAM << "Linac::State()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::dev_state) ENABLED START -----*/
	
	Tango::DevState	argout = Tango::UNKNOWN; // replace by your own algorithm
	//	Add your own code
	bool pss_permit = true;
	Tango::DevState SeqState = Tango::UNKNOWN;
	// read the state computed by the thread
	{
		omni_mutex_lock l(mutex);
		StateGivenByThread = thestate;
		pss_permit = linac_permit;
		SeqState = SequencerState;
	}
	
	if((StateGivenByThread != Tango::FAULT) && (StateGivenByThread != Tango::UNKNOWN)
		&& ( SeqState != Tango::UNKNOWN ) && (pss_permit == false))
	{
		set_state(Tango::DISABLE);
		return Tango::DISABLE;
	}
	
	switch(SeqState)
	{
		case Tango::ON: 	
			argout = StateGivenByThread;
			break;
		case Tango::DISABLE:
			if(StateGivenByThread == Tango::FAULT)
				argout = Tango::FAULT;
			else if(StateGivenByThread == Tango::UNKNOWN)
				argout = Tango::UNKNOWN;
			else
				argout = Tango::ALARM;
			break;
		case Tango::MOVING:
			argout = Tango::MOVING;
			break;
		default:
			if(StateGivenByThread == Tango::FAULT)
				argout = Tango::FAULT;
			else
				argout = Tango::UNKNOWN;
	}
	
	// read the state of the BeamStop
	bool beamstop_pb = false;
	{
		omni_mutex_lock l(beamstop_mutex);
		beamstop_pb = BeamStopProblem;
	}
	if(beamstop_pb)
		argout = Tango::ALARM;
	
        set_state(argout);
        /*line below is normal. This is a patch for 
         * after thwarting an amendment made ​​by pogo 8.1.14
         *
         * if you decide to remove this line attention 
         * modify the behavior of state ALARM (It remains the shortstatus)*/
        return argout;
        
	/*----- PROTECTED REGION END -----*/	//	Linac::dev_state
	set_state(argout);    // Give the state to Tango.
	if (argout!=Tango::ALARM)
		DeviceImpl::dev_state();
	return get_state();  // Return it after Tango management.
}
//--------------------------------------------------------
/**
 *	Command Status related method
 *	Description: This command gets the device status (stored in its <i>device_status</i> data member) and returns it to the caller.
 *
 *	@returns Status description
 */
//--------------------------------------------------------
Tango::ConstDevString Linac::dev_status()
{
	DEBUG_STREAM << "Linac::Status()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::dev_status) ENABLED START -----*/
	
	string	status = "Device is OK";
	//	Add your own code
	bool pss_permit = true;
	Tango::DevState SeqState = Tango::UNKNOWN;
	// read the state computed by the thread
	{
		omni_mutex_lock l(mutex);
		StateGivenByThread = thestate;
		pss_permit = linac_permit;
		SeqState = SequencerState;
	}
        //Tango::DevState effectiveState = dev_state();
	switch(SeqState)
	{
		case Tango::ON: 	
			switch(StateGivenByThread)
			{
				case Tango::ON:
                                    /*if(effectiveState == Tango::ALARM
                                        && (strcasecmp(*attr_File_read,"NO FILE LOADED") == 0)){
                                        thestatus = "ALARM : NO FILE LOADED. Please load file.";
                                        shortstatus = "ALARM : NO FILE LOADED";
                                    }else{*/
                                        thestatus = "On";
					shortstatus = "On";
                                    //}
                                    break;
				case Tango::OFF:
					thestatus = "Off";
					shortstatus = "Off";
					break;
				case Tango::STANDBY:
					thestatus = "Standby";
					shortstatus = "Standby";
					break;
				case Tango::INIT:
					thestatus = "Low Heating";
					shortstatus = "Low Heating";
					break;
				case Tango::UNKNOWN:
					thestatus = "Unknown";
					shortstatus = "Unknown";
					break;
				case Tango::MOVING:
					thestatus = "Moving";
					shortstatus = "Moving";
					break;
				case Tango::FAULT:
					thestatus = "Fault";
					shortstatus = "Fault";
					break;
				case Tango::ALARM:
					thestatus = "Alarm";
					shortstatus = "Alarm";
					break;
				default:
					thestatus = "Unknown";
					shortstatus = "Unknown";
			}
			break;
		case Tango::DISABLE:
			// last sequence failed in its execution
			if(StateGivenByThread == Tango::FAULT)
			{
				thestatus = "Fault";
				shortstatus = "Fault";
			}
			else if(StateGivenByThread == Tango::UNKNOWN)
			{
				thestatus = "Unknown";
				shortstatus = "Unknown";
			}
			else
			{
				switch(last_cmd)
				{
					case ON_CMD:
						thestatus = "On Not Reached\nOn sequence failed in its execution";
						shortstatus = "On Not Reached";
						break;
					case STANDBY_CMD:
						thestatus = "Standby Not Reached\nStandby sequence failed in its execution";
						shortstatus = "Standby Not Reached";
						break;
					case LOW_HEATING_CMD:
						thestatus = "Low Heating Not Reached\nLowHeating sequence failed in its execution";
						shortstatus = "Low Heating Not Reached";
						break;
					case OFF_CMD:
						thestatus = "Off Not Reached\nOff sequence failed in its execution";
						shortstatus = "Off Not Reached";
						break;
					case LOAD_FILE_CMD:
						thestatus = "Error when loading file\nLoadFile sequence failed in its execution";
						shortstatus = "Error when loading file";
						break;
					case SAVE_FILE_CMD:
						thestatus = "Error when saving file\nSaveFile sequence failed in its execution";
						shortstatus = "Error when saving file";
						break;
					case FORCE_SAVE_CMD:
						thestatus = "Error when saving file\nForceSave sequence failed in its execution";
						shortstatus = "Error when saving file";
						break;
					default:
						thestatus = "Last sequence failed in its execution";
						shortstatus = "Last sequence failed in its execution";
						break;	
				}
			}
			break;
		case Tango::MOVING:
			switch(last_cmd)
			{
				case ON_CMD:
					thestatus = "Executing On sequence";
					shortstatus = "Executing On sequence";
					break;
				case STANDBY_CMD:
					thestatus = "Executing Standby sequence";
					shortstatus = "Executing Standby sequence";
					break;
				case LOW_HEATING_CMD:
					thestatus = "Executing Low Heating sequence";
					shortstatus = "Executing Low Heating sequence";
					break;
				case OFF_CMD:
					thestatus = "Executing Off sequence";
					shortstatus = "Executing Off sequence";
					break;
				case LOAD_FILE_CMD:
					thestatus = "Executing LoadFile sequence";
					shortstatus = "Executing LoadFile sequence";
					break;
				case SAVE_FILE_CMD:
					thestatus = "Executing SaveFile sequence";
					shortstatus = "Executing SaveFile sequence";
					break;
				case FORCE_SAVE_CMD:
					thestatus = "Executing ForceSave sequence";
					shortstatus = "Executing ForceSave sequence";
					break;
				default:
					thestatus = "Executing a sequence";
					shortstatus = "Executing a sequence";
					break;
			}
			break;
		default:
			if(StateGivenByThread == Tango::FAULT)
			{
				thestatus = "Fault \nSequencer " + sequencer + " in an unknown state : check if the device server LinacSequencer is running.";
				shortstatus = "Fault ";
			}
			else
			{
				thestatus = "Sequencer " + sequencer + " in an unknown state : check if the device server LinacSequencer is running.";
				shortstatus = sequencer + " in an unknown state";
			}
	}

	if(pss_permit == false)
	{
		thestatus = thestatus + "\n **** No PSS Linac permit ! ****";
		shortstatus += " : No PSS permit !";
	}
	else
	{
		// read the state of the BeamStop
		bool beamstop_pb = false;
		{
			omni_mutex_lock l(beamstop_mutex);
			beamstop_pb = BeamStopProblem;
		}
		if(beamstop_pb)
		{
			thestatus += "\n";
			{
				omni_mutex_lock l(beamstop_mutex);
				thestatus = thestatus + BeamStopStatus;
			}
			shortstatus += " : BeamStop Problem !";
		}
	}

	if(overcurrent == true)
	{
		thestatus = thestatus + "\n **** SR current reached ! ****";
		shortstatus += " : SR current reached !";
	}
	{
		omni_mutex_lock l(mutex);
		thestatus += "\n" + fault_status + unknown_status + alarm_status;
	}
	
	return thestatus.c_str();

	/*----- PROTECTED REGION END -----*/	//	Linac::dev_status
	set_status(status);               // Give the status to Tango.
	return DeviceImpl::dev_status();  // Return it.
}
//--------------------------------------------------------
/**
 *	Command On related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void Linac::on()
{
	DEBUG_STREAM << "Linac::On()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::on) ENABLED START -----*/
	
	//	Add your own code
	if(StateGivenByThread == Tango::OFF)
	{
		Tango::Except::throw_exception(
		(const char *) "CommandNotAllowedInThisDeviceState",
		(const char *) "Command not allowed when the Linac is OFF, please execute Standby Command first",
		(const char *) "Linac::On()");
	}
	// check the name of the PCT device read by the clone device
	if(pctselected)
	{
		try
		{
			get_pctdevice_name();
		}
		catch(Tango::DevFailed &e)
		{
			Tango::Except::print_exception(e);
		}
		Tango::DevDouble sr_current;
		try
		{
			//Tango::DeviceAttribute attr_value = PCTds->read_attribute("sig_current");
			Tango::DeviceAttribute attr_value = PCTds->read_attribute("Current");
			attr_value >> sr_current;
			CTread = sr_current;
		}
		catch(Tango::DevFailed &e)
		{
			ERROR_STREAM << "Error reading PCT's sig_current attribute" << endl;
			Tango::Except::print_exception(e);
//			throw; // ??
		}
		if(CTread >= attr_SRCT_Limit_write)
			overcurrent = true;
		else
			overcurrent = false;
	}
	
	if(overcurrent == true)
	{
		// Linac could not be switched on
		Tango::Except::throw_exception 
		((const char *)"OverCurrent",
		(const char *)"SR Current Reached! The Linac cannot be switched on.",
		(const char *)"Linac::on()");
	}

	last_cmd = ON_CMD;
 	try
 	{
		Sequencerds->command_inout("On");
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	Linac::on
}
//--------------------------------------------------------
/**
 *	Command Off related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void Linac::off()
{
	DEBUG_STREAM << "Linac::Off()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::off) ENABLED START -----*/
	
	//	Add your own code
	if(StateGivenByThread == Tango::ON)
	{
		Tango::Except::throw_exception(
		(const char *) "CommandNotAllowedInThisDeviceState",
		(const char *) "Command not allowed when the Linac is ON, please execute Standby or LowHeating Command first",
		(const char *) "Linac::Off()");
	}
 	try
 	{
		Sequencerds->command_inout("Off");
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
	last_cmd = OFF_CMD;

	/*----- PROTECTED REGION END -----*/	//	Linac::off
}
//--------------------------------------------------------
/**
 *	Command Standby related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void Linac::standby()
{
	DEBUG_STREAM << "Linac::Standby()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::standby) ENABLED START -----*/
	
	//	Add your own code
	try
 	{
		Sequencerds->command_inout("Standby");
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	} 
	last_cmd = STANDBY_CMD;

	/*----- PROTECTED REGION END -----*/	//	Linac::standby
}
//--------------------------------------------------------
/**
 *	Command LowHeating related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void Linac::low_heating()
{
	DEBUG_STREAM << "Linac::LowHeating()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::low_heating) ENABLED START -----*/
	
	//	Add your own code
	try
 	{
		Sequencerds->command_inout("LowHeating");
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	} 
	last_cmd = LOW_HEATING_CMD;

	/*----- PROTECTED REGION END -----*/	//	Linac::low_heating
}
//--------------------------------------------------------
/**
 *	Command Abort related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void Linac::abort()
{
	DEBUG_STREAM << "Linac::Abort()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::abort) ENABLED START -----*/
	
	//	Add your own code
	try
 	{
		Sequencerds->command_inout("Abort");
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}

	/*----- PROTECTED REGION END -----*/	//	Linac::abort
}
//--------------------------------------------------------
/**
 *	Command Reset related method
 *	Description: 
 *
 */
//--------------------------------------------------------
void Linac::reset()
{
	DEBUG_STREAM << "Linac::Reset()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::reset) ENABLED START -----*/
	
	//	Add your own code
	Tango::GroupCmdReplyList rl = reset_devices->command_inout("Reset");
	int nb_errors = 0;
	if(rl.has_failed())
	{
		TangoSys_OMemStream o;
		o << "Reset command failed";
		int nberrors = 0;
		for(unsigned int i=0; i<rl.size(); i++)
		{	
			if(rl[i].has_failed())
			{
				nb_errors++;
				const Tango::DevErrorList& el = rl[i].get_err_stack();
          			for (unsigned int err = 0; err < el.length(); err++)
           			{
              				ERROR_STREAM << el[err].desc.in() << endl;
           			}
				if(nberrors == 1)
					o << "on " << rl[i].dev_name() << " device";
				else
					o << ", on " << rl[i].dev_name() << " device";
			}
		}
		
		o << ends;
		Tango::Except::throw_exception(
		(const char *) "ResetFailed",
		o.str(),
		(const char *) "Linac::reset()");
	}

	/*----- PROTECTED REGION END -----*/	//	Linac::reset
}
//--------------------------------------------------------
/**
 *	Command ReadDirName related method
 *	Description: Command to retrieve the name of the directory under which the Linac configuration files
 *               are load and saved.
 *
 *	@returns The name of the directory under which the files are load and saved.
 */
//--------------------------------------------------------
Tango::DevString Linac::read_dir_name()
{
	Tango::DevString argout;
	DEBUG_STREAM << "Linac::ReadDirName()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::read_dir_name) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	/*Tango::DevString	argout  = new char[6];
	strcpy(argout, "dummy");*/
	DEBUG_STREAM << "Linac::read_dir_name(): entering... !" << endl;

	//	Add your own code to control device here
	Tango::DevString	stringout = CORBA::string_dup(dirname.c_str());
	return stringout;

	/*----- PROTECTED REGION END -----*/	//	Linac::read_dir_name
	return argout;
}
//--------------------------------------------------------
/**
 *	Command LoadFile related method
 *	Description: Load the configuration file given in argument.
 *
 *	@param argin File to load
 */
//--------------------------------------------------------
void Linac::load_file(Tango::DevString argin)
{
	DEBUG_STREAM << "Linac::LoadFile()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::load_file) ENABLED START -----*/
	
	//	Add your own code
	// build the whole path of the file
	filename = dirname + "/" + argin;
	DEBUG_STREAM << "Linac::save_file(): file to load = " << filename << endl;

// change the file attribute
// 	*attr_File_read = new char[strlen(argin)+1];
// 	strcpy(*attr_File_read,argin);
// 	// Save the file name in the property startfile
// 	Tango::DbData data;
// 	data.clear();
// 	data.push_back(Tango::DbDatum("startfile"));
// 	data[0] << argin;
// 	get_db_device()->put_property(data);
 	try
 	{
		Tango::DeviceData file_argin;
		file_argin << filename;
		Sequencerds->command_inout("LoadFile",file_argin);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
	last_cmd = LOAD_FILE_CMD;
	// change the file attribute
	CORBA::string_free(*attr_File_read);
	*attr_File_read = CORBA::string_alloc(strlen(argin));
	strcpy(*attr_File_read,argin);

	/*----- PROTECTED REGION END -----*/	//	Linac::load_file
}
//--------------------------------------------------------
/**
 *	Command SaveFile related method
 *	Description: This command will save all the present settings in a file.
 *               The argin is the name of the file. It's a relative pathname.
 *               For example, if 'test/16bunch' is given in argin, the file will be saved in dirname/test/16bunch.
 *               dirname is the dirname property of the server.
 *               You can use the command readDirName to know the value of dirname.
 *               These settings will be applied by the server from now.
 *
 *	@param argin Name of the file (relative to dirname property)
 */
//--------------------------------------------------------
void Linac::save_file(Tango::DevString argin)
{
	DEBUG_STREAM << "Linac::SaveFile()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::save_file) ENABLED START -----*/
	
	//	Add your own code
	#ifdef WIN32_SEQUENCER
	filename = dirname + "\\" + argin;
#else
	filename = dirname + "/" + argin;
#endif
 	try
 	{
		Tango::DeviceData file_argin;
		file_argin << filename;
		Sequencerds->command_inout("SaveFile",file_argin);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	}
	last_cmd = SAVE_FILE_CMD;
	// change the file attribute
	CORBA::string_free(*attr_File_read);
	*attr_File_read = CORBA::string_alloc(strlen(argin));
	strcpy(*attr_File_read,argin);

	/*----- PROTECTED REGION END -----*/	//	Linac::save_file
}
//--------------------------------------------------------
/**
 *	Command ForceSave related method
 *	Description: This command will force the save of all the present settings in a file
 *               even if there was a problem when getting all the current set points.
 *               If a set point could not be read, the set point given in the last loaded or saved file will be used.
 *               The argin is the name of the file. It's a relative pathname.
 *               For example, if 'test/16bunch' is given in argin, the file will be saved in dirname/test/16bunch.
 *               dirname is the dirname property of the server.
 *               You can use the command readDirName to know the value of dirname.
 *               These settings will be applied by the server from now.
 *
 *	@param argin Name of the file (relative to dirname property)
 */
//--------------------------------------------------------
void Linac::force_save(Tango::DevString argin)
{
	DEBUG_STREAM << "Linac::ForceSave()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::force_save) ENABLED START -----*/
	
	//	Add your own code
	filename = dirname + "/" + argin;
 	try
 	{
		Tango::DeviceData file_argin;
		file_argin << filename;
		Sequencerds->command_inout("ForceSave",file_argin);
	}
	catch(Tango::DevFailed &e)
	{
		Tango::Except::print_exception(e);
		throw;
	} 
	last_cmd = FORCE_SAVE_CMD;
	// change the file attribute
	CORBA::string_free(*attr_File_read);
	*attr_File_read = CORBA::string_alloc(strlen(argin));
	strcpy(*attr_File_read,argin);

	/*----- PROTECTED REGION END -----*/	//	Linac::force_save
}
//--------------------------------------------------------
/**
 *	Command GetPCTDeviceName related method
 *	Description: This command will return the name of the PCT device to be read.
 *               This name is obtained through the Tango database by reading the property sr/d-ct/1/CurrentDeviceName.
 *               After the call to this function, the PCT device used in the Linac server will be the one given by this property.
 *
 *	@returns PCT device name
 */
//--------------------------------------------------------
Tango::DevString Linac::get_pctdevice_name()
{
	Tango::DevString argout;
	DEBUG_STREAM << "Linac::GetPCTDeviceName()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::get_pctdevice_name) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	DEBUG_STREAM << "Linac::get_pctdevice_name(): entering... !" << endl;

	//	Add your own code to control device here
#ifdef SIMU
	argout = CORBA::string_dup(pCT_device.c_str());
	return argout;
#else
	long error;
	char * pct_clone_device = NULL;

	Tango::DbData db_data; 
	db_data.push_back(Tango::DbDatum("CurrentDeviceName"));
	string pct_name_tmp;
	try
	{	
		Tango::Database *db = new Tango::Database();
		db->get_device_property("sr/d-ct/1", db_data);
		db_data[0] >> pct_name_tmp;
		delete db;
	}
	catch(...)
	{
		ERROR_STREAM << "Error getting sr/d-ct/1/CurrentDeviceName property" << endl;
		Tango::DevString argout = CORBA::string_dup(pCT_device.c_str());
		return argout;
	}
	Tango::DevString pct_name;
	pct_name = CORBA::string_dup(pct_name_tmp.c_str());
	string old_pct_name = pCT_device;
	
	if(strcasecmp(pct_name,old_pct_name.c_str()) != 0)
	{
		try
		{
			if(PCTds != NULL)
				delete PCTds;
			PCTds = new Tango::DeviceProxy(pct_name);
			{
				omni_mutex_lock l(beamstop_mutex);
				pct_has_changed = true;
				pCT_device = pct_name;
			}
			return pct_name;
		}
		catch(Tango::DevFailed &e)
		{
			CORBA::string_free(pct_name);
			Tango::Except::print_exception(e);
			try
			{
				// try to restore the old PCT_device
				PCTds = new Tango::DeviceProxy(old_pct_name.c_str());
				Tango::DevString argout = CORBA::string_dup(pCT_device.c_str());
				return argout;
			}
			catch(Tango::DevFailed &e)
			{
				PCTds = NULL;
				Tango::Except::print_exception(e);
				throw;
			}
		}
	}
	else
	{
		CORBA::string_free(pct_name);
		Tango::DevString argout = CORBA::string_dup(pCT_device.c_str());
		return argout;
	}
#endif

	/*----- PROTECTED REGION END -----*/	//	Linac::get_pctdevice_name
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetICTDeviceName related method
 *	Description: This command will return the name of the ICT device to be read.
 *               This name is obtained through the Tango database by reading the property sr/d-ct/2/CurrentDeviceName.
 *               After the call to this function, the ICT device used in the Linac server will be the one given by this property.
 *
 *	@returns PCT device name
 */
//--------------------------------------------------------
Tango::DevString Linac::get_ictdevice_name()
{
	Tango::DevString argout;
	DEBUG_STREAM << "Linac::GetICTDeviceName()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Linac::get_ictdevice_name) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	DEBUG_STREAM << "Linac::get_ictdevice_name(): entering... !" << endl;

	//	Add your own code to control device here
#ifdef SIMU
	argout = CORBA::string_dup(iCT_device.c_str());
	return argout;
#else
	long error;
	char * ict_clone_device = NULL;

	Tango::DbData db_data; 
	db_data.push_back(Tango::DbDatum("CurrentDeviceName"));
	string ict_name_tmp;
	try
	{	
		Tango::Database *db = new Tango::Database();
		db->get_device_property("sr/d-ct/2", db_data);
		db_data[0] >> ict_name_tmp;
		delete db;
	}
	catch(...)
	{
		ERROR_STREAM << "Error getting sr/d-ct/2/CurrentDeviceName property" << endl;
		Tango::DevString argout = CORBA::string_dup(iCT_device.c_str());
		return argout;
	}
	Tango::DevString ict_name;
	ict_name = CORBA::string_dup(ict_name_tmp.c_str());
	string old_ict_name = iCT_device;
	
	if(strcasecmp(ict_name,old_ict_name.c_str()) != 0)
	{
		try
		{
			if(ICTds != NULL)
				delete ICTds;
			ICTds = new Tango::DeviceProxy(ict_name);
			{
				omni_mutex_lock l(beamstop_mutex);
				ict_has_changed = true;
				iCT_device = ict_name;
			}
			return ict_name;
		}
		catch(Tango::DevFailed &e)
		{
			CORBA::string_free(ict_name);
			Tango::Except::print_exception(e);
			try
			{
				// try to restore the old ICT_device
				ICTds = new Tango::DeviceProxy(old_ict_name.c_str());
				Tango::DevString argout = CORBA::string_dup(iCT_device.c_str());
				return argout;
			}
			catch(Tango::DevFailed &e)
			{
				ICTds = NULL;
				Tango::Except::print_exception(e);
				throw;
			}
		}
	}
	else
	{
		CORBA::string_free(ict_name);
		Tango::DevString argout = CORBA::string_dup(iCT_device.c_str());
		return argout;
	}
#endif

	/*----- PROTECTED REGION END -----*/	//	Linac::get_ictdevice_name
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : Linac::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void Linac::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(Linac::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	Linac::add_dynamic_commands
}

/*----- PROTECTED REGION ID(Linac::namespace_ending) ENABLED START -----*/

//	Additional Methods
void MyCallBack::attr_read(Tango::AttrReadEvent * attr_read_ev)
{
	//cout << "MyCallBack::attr_read() entering ..." << endl;
	//string devname = attr_read_ev->device->name();
	if(attr_read_ev->err == true)
	{
		//cout << " " << devname << ": ERROR !" << endl;
		Tango::Except::print_error_stack(attr_read_ev->errors);
	}
	else
	{
		
		//cout << " " << devname << " : NO error" << endl;
		(*(attr_read_ev->argout))[0] >> readState;
	}
}
double get_ticks() {

#ifdef WIN32

  return (double)GetTickCount();

#else

  struct timeval tv;
  gettimeofday(&tv,NULL);
  return ( (tv.tv_sec)*1000.0 + (double)tv.tv_usec/1000.0 );

#endif

}


/*----- PROTECTED REGION END -----*/	//	Linac::namespace_ending
} //	namespace
