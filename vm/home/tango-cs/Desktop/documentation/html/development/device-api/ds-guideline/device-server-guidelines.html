

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Guidelines &mdash; Tango Controls 9.2.5 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="Tango Controls 9.2.5 documentation" href="../../../index.html"/>
        <link rel="up" title="TANGO Device Server Guidelines" href="index.html"/>
        <link rel="next" title="The TANGO device server model" href="../device-server-model.html"/>
        <link rel="prev" title="TANGO Device Server Guidelines" href="index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../contents.html" class="icon icon-home"> Tango Controls
          

          
            
            <img src="../../../_static/logo_tangocontrols_white.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                9.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Welcome to Tango Controls documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting-started/index.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Developer’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../general-guidelines/index.html">General guidelines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../corba.html">10 things you should know about CORBA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../client-api/index.html">Tango Client</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Device Servers</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../introduction.html">Introduction to device server</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="index.html">TANGO Device Server Guidelines</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">Guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tango-concepts">Tango Concepts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tango-device-design">Tango Device Design</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tango-device-implementation">Tango device implementation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#appendices">Appendices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../device-server-model.html">The TANGO device server model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../device-server-writing.html">Writing a TANGO device server</a></li>
<li class="toctree-l3"><a class="reference internal" href="../attribute-alarms.html">Attribute alarms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../enumerated-attribute.html">Enumerated attribute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memorized-attribute.html">Memorized attribute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../forwarded-attribute.html">Forwarded attribute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../device-polling.html">Device polling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../generating-events.html">Generating events in a device server</a></li>
<li class="toctree-l3"><a class="reference internal" href="../java/index.html">Tango Device in Java</a></li>
<li class="toctree-l3"><a class="reference internal" href="../python/index.html">PyTango - a Python binding to Tango</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../debugging-and-testing/index.html">Debugging and Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../advanced/index.html">Advanced</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cpp-api/index.html">Tango Core C++ Classes Reference Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools-and-extensions/index.html">Tools and Extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../administration/index.html">Administration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials-and-howtos/index.html">Tutorials and How-Tos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../contents.html">Tango Controls</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../contents.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Developer’s Guide</a> &raquo;</li>
        
          <li><a href="../index.html">Device Servers</a> &raquo;</li>
        
          <li><a href="index.html">TANGO Device Server Guidelines</a> &raquo;</li>
        
      <li>Guidelines</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/development/device-api/ds-guideline/device-server-guidelines.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="guidelines">
<span id="ds-guidelines"></span><h1>Guidelines<a class="headerlink" href="#guidelines" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes Guidelines for developing Device Servers.
The purpose of this document is not to rewrite the Tango documentation
but to propose the community an interpretation of Tango device
development.
The Tango Device Server Model is flexible and permits different interpretations
of how to implement Device Servers.
However there is a right way of using Tango to implement device servers.
This chapter documents the best practices from experienced developers
(some of them thee original developers of Tango) for device development.</p>
<p>Other ways of using Tango which do not follow these guidelines are possible
and can be useful but they might run into difficulties because Tango
was not designed to be use that way.
All developers should start off by first reading these guidelines and then
deciding if they want to ignore them or not.
We strongly recommend you stick to them to make your Device Classes
easier to share and your Tango control system as efficient as possible.</p>
<p>To this aim the document is divided in 3 main chapters:</p>
<ol class="arabic simple">
<li>Tango concepts</li>
<li>DeviceServers design consideration</li>
<li>Implementation good practices</li>
</ol>
<div class="section" id="about-this-document">
<h2>About this document<a class="headerlink" href="#about-this-document" title="Permalink to this headline">¶</a></h2>
<p>The document has been initiated within the collaborative framework
between SOLEIL and MAX-IV to define common software quality rules for
shared software between these 2 institutes. It has since been adopted by
the Tango community and is maintained for and by the community.</p>
<p>The objectives are therefore to enhance the general software quality of
Device Servers developed by the various sites using Tango. This will
also facilitate the reusability of developments between sites by allowing
finding “reliable off-the-shelves” Tango servers in public repositories.</p>
<p><strong>Last but not least, this document can be freely distributed (under the
Creative Commons license) to subcontractors, students, etc…</strong>.
Our hope is (<em>as all writers</em>) to have as many readers as possible!!</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Throughout the rest of the document, the issued recommendations are specified as below:</p>
<p class="last"><strong>The recommendation is to …</strong></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Important note:</strong> The content of this document is generally
independent of the programming language used. However, there are some
“C++ oriented” recommendations. For Java and Python refer to the relevant
documentation for language specific issues. In the future we hope to add
guidelines for Java and Python too.</p>
</div>
<p>The present document refers to the Tango 8 or higher versions features.</p>
<p><strong>Licence</strong>: This work is licensed under the <strong>Creative Commons
Attribution 4.0 International License</strong>. To view a copy of this license,
see <a class="reference external" href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a>.</p>
</div>
</div>
<div class="section" id="tango-concepts">
<h1>Tango Concepts<a class="headerlink" href="#tango-concepts" title="Permalink to this headline">¶</a></h1>
<p>The following explanations are from the <a class="reference internal" href="../device-server-model.html#deviceservermodel"><span class="std std-ref">Tango Device
Server Model&nbsp;</span></a>.</p>
<div class="section" id="tango-control-system">
<h2>Tango Control system<a class="headerlink" href="#tango-control-system" title="Permalink to this headline">¶</a></h2>
<p>The Tango control system is an abstract concept which represents a set
of “microservices” based on a common technology: Tango. Tango is itself a
control/command oriented specialization of CORBA/ZMQ. CORBA supports the
concept of software bus running over a network interconnected machines.
It provides transparent access to any software object (or microservice)
connected to the bus and abstracts the notions of programming language
(C++, Java, Python…) and operating systems (Linux, Windows…) via a
binary network protocol (based on CORBA and ZMQ).</p>
<p>Tango hides the complexity of the underlying protocols to the
programmer, while adding specific control system features (alarms,
events, logging, data archiving…).</p>
</div>
<div class="section" id="device-concept">
<h2>Device concept<a class="headerlink" href="#device-concept" title="Permalink to this headline">¶</a></h2>
<p>The “device” is the core concept of Tango. This concept can be directly
linked to the notion of microservice: <strong>1 device = 1 microservice</strong></p>
<p>A device can represent:</p>
<ul class="simple">
<li>An equipment (eg: a power supply),</li>
<li>A set of equipments (eg: a set of 4 motors driven by the same controller),</li>
<li>A set of software functions (eg: image processing),</li>
<li>A group of devices representing a subsystem</li>
</ul>
<p>The Tango Device allows making abstraction of the equipment’s nature:
the device hides the implementation specific details from the user who
does not need to care about communication protocols etc. and
provides the user with a model which speaks their languages e.g. physical
or engineering parameters.</p>
</div>
<div class="section" id="hierarchy">
<h2>Hierarchy<a class="headerlink" href="#hierarchy" title="Permalink to this headline">¶</a></h2>
<p>A Tango control system can be hierarchically organized.</p>
<p>At the lower level, we find elementary devices which are associated
with equipments.</p>
<ul class="simple">
<li>e.g.: a vacuum pump, a motor, an I/O card</li>
</ul>
<p>At higher levels, the devices are «&nbsp;logical&nbsp;». These devices, based on
the lower-level devices, manage and represent a subset of the control
system. This is usually a synthetic view of a set of equipments with a
high-level steering (functions can perform sequences of actions on
several basic devices).</p>
<p>For example, a high-level device achieves “complex” features. This
device is usually bound to evolve regardless of the hardware. Therefore,
it is necessary to separate and segregate responsibilities related to
the logic functionality and those related to hardware interfaces.</p>
<p>It is possible to access any other device from every device at every level.</p>
<p>The following diagram illustrates the concept of hierarchy of devices:</p>
<div class="figure" id="id8">
<img alt="../../../_images/image1.png" src="../../../_images/image1.png" />
<p class="caption"><span class="caption-text">The software bus view of devices</span></p>
</div>
<div class="figure" id="id9">
<img alt="../../../_images/image2.png" src="../../../_images/image2.png" />
<p class="caption"><span class="caption-text">Hierarchical view of devices</span></p>
</div>
</div>
<div class="section" id="communication-paradigms">
<h2>Communication paradigms<a class="headerlink" href="#communication-paradigms" title="Permalink to this headline">¶</a></h2>
<p>Tango offers three communication paradigm: synchronous, asynchronous
and publish-subscribe calls.</p>
<p>In the synchronous and asynchronous paradigms
the call is initiated by the client who contacts the server.
The server handles the client’s request and sends
the answer to the client or throws an exception which the client
catches. This paradigm involves two network calls to receive a single answer and
requires the client to be active in initiating the request. The calls
initiated by the client may be done by 2 mechanisms:</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple">
<li>the <strong>synchronous</strong> mechanism where the client waits (and is blocked) for the server to send the answer or until the timeout is reached</li>
<li>the <strong>asynchronous</strong> mechanism where the clients send the request and immediately returns.
It is not blocked. It is free to do whatever it
has to do like updating a graphical user interface. The client has
the choice to retrieve the server answer by checking if the reply is
arrived by calling an API specific call or by requesting that a
call-back method is executed when the client receives the server
answer.</li>
</ol>
</div>
<p>If the client needs to know a value every time it changes
or at regular intervals then he is obliged to poll
the server for an update in a value every time. This is not efficient in
terms of network bandwidth nor in terms of client programming.
For this the publish-subscribe events communication is more efficient.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ol class="last arabic simple" start="3">
<li>the <strong>publish-subscribe</strong> communication paradigm is a more efficient
and natural way of programming. In this paradigm the client registers
his interest once in an event (value). An event can be a change in value,
a regular update at a fixed frequency or an archive event.
After that the server informs  the client every time an event has occurred.
This paradigm avoids the client polling, frees it for doing other things,
is fast and  makes efficient use of the network.</li>
</ol>
</div>
</div>
<div class="section" id="class-device-and-device-server">
<h2>Class, Device and Device Server<a class="headerlink" href="#class-device-and-device-server" title="Permalink to this headline">¶</a></h2>
<div class="section" id="reminders">
<h3>Reminders<a class="headerlink" href="#reminders" title="Permalink to this headline">¶</a></h3>
<p>Sometimes, there are misuses of language regarding the concepts of:
device, device server and Tango class.</p>
<ul class="simple">
<li><strong>DeviceClass</strong> class: a class defining the interface and state machine.</li>
<li><strong>Device</strong> class: a class implementing the device control.</li>
<li><strong>Device</strong>: An instance of a Device class giving access to the services of
the DeviceClass class.</li>
<li><strong>Device Server</strong>: process in which one or more Tango classes are
executed.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">DeviceClass class is only used in C++ device classes</p>
</div>
<p><strong>These four concepts are closely related, and they express very
important concepts of Tango.
Take time to clearly understand them!</strong></p>
<p>The diagrams below illustrate these concepts:</p>
<div class="figure" id="id10">
<img alt="../../../_images/image3.png" src="../../../_images/image3.png" />
<p class="caption"><span class="caption-text">Tango Deployment</span></p>
</div>
<p>A Device Server can host several Device classes, each class can be
instantiated one or more times within the same device server. There are no
specific rules regarding the maximum number of classes or the maximum
number of instances operating within a single Device Server.</p>
<p>In particular cases, due to limitations imposed by the hardware
or software interface, it is not
always possible to run several instances of a Device class within the
same Device Server:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Case of a DLL’s use: some DLLs can’t be used by two threads of the</dt>
<dd>same process.</dd>
</dl>
</li>
</ul>
<p>In other cases, it is useful to have multiple devices running in the
same Device Server:</p>
<ul class="simple">
<li>Case of motors: a single axis controller for 4 motors.</li>
</ul>
</div>
<div class="section" id="device">
<h3>Device<a class="headerlink" href="#device" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is the basic entity of the control system. In the Tango world,
everything is a <strong>Device</strong>.</p>
</div>
<p>A Tango Device must be “self-consistent”. In case it represents a subset
of the control system, it must enable the access to all the associated
features (unless otherwise specified). The limit of its
“responsibilities”, meaning “separation of concerns”, is clearly
defined: 1 Device = 1 microservice = 1 element of the system. The analogy
with object-oriented programming is straightforward.</p>
<p>A Device is a <strong>microservice</strong> made available to any number of unspecified
clients. Its implementation and/or behaviour must not make
<strong>assumptions about the nature and the number of its potential
clients</strong>. In all cases, reactivity must be ensured (i.e. the
response time of the device, must be minimized).</p>
<p>A Device has an interface composed of commands and attributes, which
provides the service of the device. It also has “<em>properties</em>”,
stored in the relational database, which are generally used as
configuration settings. These concepts are explained later in this
document.</p>
</div>
<div class="section" id="device-attributes">
<h3>Device attributes<a class="headerlink" href="#device-attributes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="purpose-of-an-attribute">
<h4>Purpose of an attribute<a class="headerlink" href="#purpose-of-an-attribute" title="Permalink to this headline">¶</a></h4>
<p>Attributes correspond to physical quantities carried by the device. Any
value that you want available on the Tango bus is an attribute. For
example:</p>
<ul class="simple">
<li>A device associated with a motor <strong>has</strong> a <em>position</em> attribute
expressed in mm.</li>
<li>A device associated with a thermocouple <strong>has</strong> a <em>temperature</em>
attribute expressed in Celsius (or any another suitable unit).</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The main purpose of an attribute is to replace getters and
setters.</p>
</div>
<ul class="simple">
<li>For example: the position of a motor will be obtained by reading the
associated attribute (position) and not by running a command like
<em>get_position.</em></li>
<li>The data associated with the Tango attributes are the only values
that can be archived. The Tango <em>archiving system</em> (HDB/TDB) doesn’t
have any functions to archive the result of a command. Similarly,
some mechanisms to store the experimental data (such as those
implemented by the DataRecorder of SOLEIL) are only based on
attributes.</li>
</ul>
</div>
<div class="section" id="attribute-properties">
<h4>Attribute Properties<a class="headerlink" href="#attribute-properties" title="Permalink to this headline">¶</a></h4>
<p>A Tango attribute has a group of settings that describe it.</p>
<p>These configuration parameters are called AttributeProperties. They can
be considered as meta-data to enhance the semantic and describe the
data. They can be used by GUI clients for configuring their viewers in
the best manner and displaying extra information.</p>
<p>Those Attribute properties describe the attribute data and define some
of its behaviour such as alarm limits, units etc…</p>
<p>The first set of <em>Attribute Properties</em> are static metadata. They
describe the kind of data carried by the Tango Attribute. The static
metadata includes properties such as the name, the type, the dimension,
if the attribute is writable or not. These data are hardcoded, defined
for the whole life of the attribute and cannot be modified.</p>
<p>The second set of <em>Attribute Properties</em>, are dynamic. They describe
more precisely the meaning of the data and some behaviour. They are
used by GUI viewers to configure themselves. They can be modified at run
time.</p>
<p>All these metadata are hosted in the class itself and can be set by the
programmer or by a configuration in the Tango database.</p>
</div>
<div class="section" id="static-attribute-properties">
<h4>Static attribute Properties<a class="headerlink" href="#static-attribute-properties" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><strong>name</strong>: the attribute name<ul>
<li>Type: string e.g&nbsp;: OutCurrent, InCurrent…</li>
</ul>
</li>
<li><strong>data_type</strong>: the attribute data type<ul>
<li>Identifier of the Tango numeric type associated to the attribute:
<em>DevBoolean, DevUChar, Dev[U]Short, Dev[U]Long, Dev[U]Long64,
DevFloat, DevDouble, DevString, DevEncoded</em></li>
<li>Note: <em>Tango::DevEncoded</em> is the Tango type that encapsulates
client data.</li>
</ul>
</li>
<li><strong>data_format</strong>: describes the dimension of the data.<ul>
<li>Type: scalar (value), spectrum (1D array), image (2D array)</li>
</ul>
</li>
<li><strong>writable</strong>: defines 4 possible types of access. In practical, we
can say that only 2 are really useful and answer to practically all
the cases.<ul>
<li>READ, The attribute can only be read (e.g. a temperature)</li>
<li>WRITE, The attribute can only be written ( to be used only in very
specific cases. the READ_WRITE is generally more suitable for
real cases)</li>
<li>READ_WRITE, The attribute can be written and read (the most
common case) e.g. The current of a powersupply, The position of an
axis…</li>
<li>READ_WITH_WRITE (deprecated, do not use)</li>
</ul>
</li>
<li><strong>max_dim_x</strong>&nbsp;: this property is valid only for data_format
spectrum or image. It gives the maximum number of element in the
dimension X. e.g. the max length of a spectrum or the maximum number
of rows of an image. This property is used to reserve memory space to
host the data. Nothing prevent to have a real length much shorter
that this maximum.<ul>
<li>e.g. 0 for a scalar, n for a spectrum of max n elements, n for an
image of max n rows</li>
</ul>
</li>
<li><strong>max_dim_y</strong>&nbsp;: this property is valid only for data_format
image. It gives the maximum number of element in the dimension Y.
e.g. the maximum number of columns of an image. This property is used
to reserve memory space to host the data. Nothing prevent to have a
real length much shorter that this maximum.<ul>
<li>0 for a scalar or a spectrum, n for an image of max n columns</li>
</ul>
</li>
<li><strong>display_level</strong>&nbsp;: enables to hide the attribute regarding the
client mode (expert or not)<ul>
<li>Tango::OPERATOR or Tango::EXPERT</li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><em>writable_attr_name</em>: <strong>deprecated since version 8, do not use anymore</strong></p>
</div>
</div>
<div class="section" id="modifiable-attribute-properties">
<h4>Modifiable attribute properties<a class="headerlink" href="#modifiable-attribute-properties" title="Permalink to this headline">¶</a></h4>
<p>These properties carries out information regarding the display of a
value (they are editable while the device is running). Those
properties enhance the meaning of the attribute and should as much
as possible be defined by the device server programmer as default
value when known. For instance, in the general case, the programmer
knows the unit of the data and is able to describe it. Feeling the
attribute property at the development stage will allow all generic
clients to display the data in the best manner</p>
<ul class="simple">
<li><strong>description</strong>: describes the attribute<ul>
<li>Type: string e.g. “The powersupply output current”</li>
</ul>
</li>
<li><strong>label</strong>: label used on the GUIs<ul>
<li>Type: string e.g. “Output Current”, “Input Current”</li>
</ul>
</li>
<li><strong>unit</strong>: attribute unit to be displayed in the client viewer<ul>
<li>Type: string (eg “mA”, “mm”…)</li>
</ul>
</li>
<li><strong>standard_unit</strong>: conversion factor to get attribute value into
S.I (M.K.S.A)_unit. Be careful this information is intended to be
used ONLY by the client (.e.g ATKPanel uses it, but jive-&gt;test device
does not)<ul>
<li>Type: string interpreted as a floating point value E.g. If the
device attribute gives the current in mA, we have to divide by
1000 to obtain it in Amp. Then we will set this property to 1E-03</li>
</ul>
</li>
<li><strong>display_unit</strong>: used by the GUIs to display the attribute into a
unit more appropriate for the user. Be careful this information is
intended to be used ONLY by the client (e.g ATKPanel uses it, but
JiveTest device does not).<ul>
<li>Type: string interpreted as a floating point value If the device
attribute gives a current in mA. If we want to display it in
microA, then we have to multiply by 1000 to obtain it in microAmp.
Then we will set this property to 1000.0.</li>
</ul>
</li>
<li><strong>format</strong>: specifies how a numeric attribute value should be
presented<ul>
<li>Type: string&nbsp;: e.g. «&nbsp;%6.3f&nbsp;»</li>
<li>Note: we use a “printf” like syntax</li>
</ul>
</li>
<li><strong>min_value</strong> and <strong>max_value</strong>: minimum and maximum allowable
value. These properties are automatically checked at each execution
of a write attribute. If the value requested is not between the
min_value and the max_value, an exception will be returned to the
client.<ul>
<li>Type: string interpreted as a floating point value (e.g. 10.1,
1E01, 0.12.)</li>
<li>Note: these properties are valid only for writable attributes</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="attributes-properties-for-alarm-configuration">
<h4>Attributes properties for ALARM configuration<a class="headerlink" href="#attributes-properties-for-alarm-configuration" title="Permalink to this headline">¶</a></h4>
<p>Tango provides an automatic way of defining alarms. An alarm
condition will switch the attribute quality factor to alarm and the
device state will automatically switched to ALARM in certain
conditions.  Four properties are available for alarm purpose.</p>
<ul>
<li><p class="first"><strong>min_alarm</strong> and <strong>max_alarm</strong>: Define the range outside which
the attribute is considered in alarm. If the value of the attribute
is &gt; max_alarm or &lt; min_alarm, then the attribute quality factor
will be switched to ALARM.</p>
</li>
<li><p class="first"><strong>Delta_val</strong> and <strong>delta_t</strong>: (<em>could also be called maximum
noise and time constant</em>) Valid for a writeable attribute. Define a
maximum difference between the set_value and the read_value of an
attribute after a standard time.</p>
<blockquote>
<div><p>e.g. the voltage of a powersupply is set via a DAC and read via an
ADC convertor. Both values are different due to various factors such
as internal resistor or noise on the ADC. Furthermore when setting a
voltage, the powersupply may need a certain time to establish its
output voltage. The <em>delta_val</em> property allows to define the limit
of the acceptable difference between set and read values (noise
threshold) and <em>delta_t</em> defines the time the device needs to
establish the voltage after the writing of the setpoint (time
constant). When writing a new value of the attribute, if the read
value is still not close enough from the set value after the time
constant, the attribute quality factor will be set to ALARM.</p>
<p>If these properties are not set, nothing is done. As soon as one of
these properties is set, then the attribute quality factor is
automatically calculated at each read and is taken into account by
the default State attribute method. Device_Impl.dev_state(); The
programmer should be aware of possible effect of these mechanisms in
the response time of the State method. (Refer to chapter 1.14 of the
present guide).</p>
</div></blockquote>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The behaviour described above is only
correct in the case the device’s method
<em>Tango::Device_[X]Impl::dev_state()</em> is executed<em>.</em> In case of
overwrite of the dev_state() in the device code, it is recommended to
finish the method by calling DeviceImpl::dev_state();</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><strong>min_warning</strong> <em>and</em> <strong>max_warning</strong>&nbsp;: lower and upper bound
for WARNING (deprecated since version 8)</p>
</div>
</div>
<div class="section" id="attributes-properties-related-to-events-configuration">
<h4>Attributes properties related to Events configuration<a class="headerlink" href="#attributes-properties-related-to-events-configuration" title="Permalink to this headline">¶</a></h4>
<p>These settings are used for tuning the events related to the attribute.</p>
<ul class="simple">
<li><em>Rel_change:</em> relative change in the value in percent</li>
<li><em>Abs_change</em>: absolute change in the value in the standard unit.</li>
<li><em>Period</em>: period between two consecutive events</li>
<li><em>Archive_rel_change</em>: relative change in the value</li>
<li><em>Archive_abs_change</em>: absolute change in the value</li>
<li><em>Archive_period</em>: period between two consecutives events.</li>
</ul>
</div>
<div class="section" id="particular-case-of-a-memorized-attribute">
<h4>Particular case of a memorized attribute<a class="headerlink" href="#particular-case-of-a-memorized-attribute" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Memorised attributes are only possible with an attribute with WRITE or READ_WRITE mode and
SCALAR type</p>
</div>
<p>A memorized attribute can store its last written value in the database
(i.e. the last setpoint received by the device for this attribute can
optionally persist into the Tango database).</p>
<p>The stored value will be reloaded into the set value associated with
this attribute at device start-up and (optionally) upon each execution
of the “Init” command. The Tango code generator (Pogo) provides the
interface allowing the developer to select the expected behaviour.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>BE CAREFUL:</strong> this mechanism has the following <strong>behaviour</strong>:</p>
</div>
<ul class="simple">
<li>The writing of the memorized attributes is carried out after the
function “init_device”, executed by the Tango layer, and not by the
Tango DeviceServer code. In case  an error occurs during the
“init_device” it cannot be caught by the Tango DeviceServer
programmer.</li>
<li>If in the init_device method an error occurs that causes a change of
state in which the writing of an attribute is impossible, this error
will prohibit the restoration of the memorized value of the
attribute.</li>
<li>The order of reloading is deterministic but complex (<em>order of
ClassFactory then device definition in database then attribute
definition in Pogo</em>). Therefore relying on this order might have some
side effects particularly in case attributes are modified through
Pogo when attributes values are linked (<em>eg: sampling frequency and
number of samples</em>).</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Performance issues may happen in case the setpoint is written at high
frequency, the static Tango database is requested on each write of
the memorized attribute. Since Tango 9 the database has been optimised
for memorised attributes and it should be possible to update memorised
attributes at 10 Hz without taking a performance hit.</p>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">If this standard Tango behaviour for reloading memorized values doesn’t
fit your need, we recommend to code the reloading of attribute values
yourself. This is especially true for fast (&gt; 10 Hz)
feedback loops which can trigger the writing of attributes at a high frequency.</p>
</div>
</div>
</div>
<div class="section" id="device-commands">
<h3>Device commands<a class="headerlink" href="#device-commands" title="Permalink to this headline">¶</a></h3>
<p><strong>A command is associated with an action. *On, Off, Start, Stop* are
commons examples.</strong></p>
<p>A Tango command has, optionally, ONE input argument and ONE output
argument.</p>
<p>The different types of data compatible for input and output are:</p>
<ul class="simple">
<li>void, boolean, short, long, long64, float, double, string, unsigned
short, unsigned long, unsigned long64</li>
<li><em>1D array of the followings types :</em> char, short, long, long64,
float, double, unsigned short, unsigned long, unsigned long64, string</li>
<li>State: enumeration, representing the different states described in
the section on <a class="reference internal" href="#device-state"><span class="std std-ref">Device State</span></a>.</li>
<li>2 particular types: longstringarray and doublestringarray. These are
structures including one array of long/double and one array of
string.</li>
</ul>
<p>The list of data types is fixed. If you need to add your
own data type then use the DevEncoded type and encode your own
data type. Or you can use the DevPipe communication channel (avaliable
since Tango 9).</p>
<p>For each command to implement, it is essential to generate exceptions
depending on possible errors. The error handling is described more
in details below.</p>
</div>
<div class="section" id="device-state">
<span id="id1"></span><h3>Device State<a class="headerlink" href="#device-state" title="Permalink to this headline">¶</a></h3>
<div class="section" id="state-transitions">
<h4>State transitions<a class="headerlink" href="#state-transitions" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Every Tango device has a state implemented by <em>finite state machine</em>.</p>
</div>
<p>The device state is a key element in its integration into the control
system. Therefore, <strong>you should be very careful in the management of
state transitions</strong> in the device implementation.</p>
<p><strong>The device state must, at any time, reflect the internal state of the
system it represents. The state should represent any change made by a
client’s request.</strong></p>
<p>This is crucial information. Indeed, the “clients” will primarily, or
only, use this information to determine the internal state of a system.</p>
<p>The available states are limited to:</p>
<ul class="simple">
<li>ON, OFF, CLOSE, OPEN, INSERT, EXTRACT, MOVING, STANDBY, FAULT, INIT,
RUNNING, ALARM, DISABLE, UNKNOWN</li>
</ul>
<p>The main thing is to ensure a predictable behaviour of the device
regarding the state transitions.</p>
<p>For example:</p>
<ul>
<li><p class="first">Consider the case of a motor system. The client knows the motor state
(<em>STANDBY, MOVING, FAULT,)</em> with a <em>polling</em> mechanism (periodic
reading of the state attribute of the motor – instead of using the
Tango event system).</p>
<blockquote>
<div><p>In such cases, this can easily lead to inconsistent behaviour due to
inappropriate management of the state.</p>
<p>A typical example is to launch an axis movement through the writing
of the position attribute then the client is pending on the MOVING
state (the motor is supposed to make a transition <em>STANDBY MOVING</em>).
Such a method will only work if the writing of the position
attribute switches the device state to MOVING <em>before</em> the return of
the writing request of the position attribute. Otherwise, the client
can read (non-zero probability) the STANDBY state, and interpret it
as “movement ended” while this one had not even started!</p>
<p>This behaviour is described in figure 4 below.</p>
</div></blockquote>
</li>
</ul>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The developer has to guarantee the clients the same behaviour regardless
the type of state monitoring (polling or events). This relates to the
above rule: <strong>Do not make assumptions about the nature of the clients!</strong></p>
</div>
<p>The state transitions and the “associated guarantees” must be
documented. In the previous example, rereading the STANDBY state after
performing any movement must ensure that the required movement is
completed (and not that it has not yet been started!!).</p>
<div class="figure" id="id11">
<img alt="../../../_images/image4.png" src="../../../_images/image4.png" />
<p class="caption"><span class="caption-text">Example of State transitions</span></p>
</div>
</div>
</div>
<div class="section" id="properties">
<h3>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h3>
<div class="section" id="concepts">
<h4>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h4>
<p>By default Tango is based on a relational database (MySQL) to store
configuration information for devices namely the <em>properties</em>.</p>
<p>The properties are used to configure a device without changing the
Tango class code. Taking an axis controller as example, the controller
must be configured for the motor mechanics according to the
characteristics of the actuator and the movements to achieve.</p>
<p>Configuration properties are available on different levels:</p>
<ol class="arabic simple">
<li><strong>The device level:</strong> These are properties to configure the device
itself and its attributes. The device properties configure the device
with the necessary set-up information during initialisation.
Attribute properties are used to configure alarms or specify the way
the attribute value is displayed to the user (Label, Format,
Unit…).</li>
<li><strong>The class level:</strong> Device or attribute properties configured at the
class level are valid for all instances of a class. A property
defined on the class level will be overwritten by a property of the
same name on the device level.</li>
<li><strong>Free properties:</strong> These are configuration values which are not
attached to any device or class and can be freely used by
programmers.</li>
</ol>
<p>Class level and device level properties are automatically loaded during
device initialisation when starting-up a device server or calling the
“Init” command. The reading and writing of free properties must be
handled by the programmer.</p>
<p>Configuration properties can have the following data types:</p>
<ul class="simple">
<li>boolean, short, long, float, double, unsigned short, unsigned long,
string</li>
<li>array of: short, long, float, double, string</li>
</ul>
<p>On top of those basic concepts, device and class level properties can be
initialised with default values which are entered, for example, with
<a class="reference internal" href="../../../tools-and-extensions/pogo/index.html#pogo-manual"><span class="std std-ref">Pogo</span></a> at the interface creation time.
Default values are stored in the
device server code and are overwritten when another value is found in
the configuration database.</p>
<p>It is necessary to assign a default value for every property. This value
will be used when the property is not defined in the Tango database. If
a default value for a device property does not make sense, the property
should be declared as mandatory.
A mandatory property has to have a value configured in the Tango
database. If no value is configured, the device initialisation will
stop with an exception on the missing property value.</p>
</div>
<div class="section" id="device-property-vs-memorized-attributes">
<h4>Device property vs memorized attributes<a class="headerlink" href="#device-property-vs-memorized-attributes" title="Permalink to this headline">¶</a></h4>
<p>In some cases, you could be tempted to use a property for a memorized
attribute and vice-versa. It is important to distinguish the function of
each, and use them wisely.</p>
<ul>
<li><p class="first">The use of a property must be limited to configuration data which
value doesn’t change at runtime (the IP address of equipment for
example).</p>
</li>
<li><p class="first">The memorized attributes are reserved for physical quantities subject
to change at runtime (<em>attribute read/write</em>) for which you want to
retain (store) the value from one execution to the other.</p>
<blockquote>
<div><p>e.g. speed or acceleration on a motor.</p>
</div></blockquote>
</li>
</ul>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">In the case you want to manually manage the memorization of the
attribute set points, you should use an attribute property called
<em>__value</em> (as natively done by Tango).</p>
</div>
</div>
<div class="section" id="how-to-configure-a-new-device">
<h4>How to configure a new device<a class="headerlink" href="#how-to-configure-a-new-device" title="Permalink to this headline">¶</a></h4>
<p>To set-up a new device you need to know about all the device properties
and their values which must be configured to make the device work. You
need to have a description on the property which should indicate clearly
its use. Also you need to know about a specified default value.</p>
<p>When creating the device interface with Pogo a description and a default
value can be entered for every device property. This information is used
by the device installation wizard (available with Jive) to guide you
through the configuration.</p>
<p>When creating a new server start the wizard from the Tools menu -&gt;
Server Wizard. It allows you to create a new device and to initialise it
property by property. For every property the description is displayed
and the default value can be viewed. To use the wizard on an already
existing device you can right click on the device and choose Device
Wizard. You will be guided again through all the properties of the
device. At the end the device can be re-started when necessary. Because
the wizard is part of Jive, you can test the device configuration
immediately.</p>
</div>
</div>
</div>
</div>
<div class="section" id="tango-device-design">
<h1>Tango Device Design<a class="headerlink" href="#tango-device-design" title="Permalink to this headline">¶</a></h1>
<div class="section" id="elements-of-general-design">
<h2>Elements of general design<a class="headerlink" href="#elements-of-general-design" title="Permalink to this headline">¶</a></h2>
<div class="section" id="reusability">
<h3>Reusability<a class="headerlink" href="#reusability" title="Permalink to this headline">¶</a></h3>
<p>In a Tango control system, each device is a software component
potentially reusable.</p>
<p>It is necessary to:</p>
<ul>
<li><p class="first">Systematically evaluate prior the coding of a device, the
possibility of reusing a device available in the code
repositories (Tango community, local repository), in order to
avoid several implementations of the same equipment.</p>
</li>
<li><p class="first">Design the device as reusable/extensible as possible because it may
interest the others developers in the community.</p>
<blockquote>
<div><p>As such, the device must be:</p>
</div></blockquote>
</li>
<li><p class="first">Configurable: (e.g.: no port number “hard coded”, but use of a
parameter via a property),</p>
</li>
<li><p class="first">Self-supporting: the device must be usable outside the private
programming environment (eg: all the necessary elements to use the
device (compile, link) must be provided to the community). The use of
the GPL should be considered, and the use of proprietary libraries
should be avoided if possible</p>
</li>
<li><p class="first">Portable: the device code must be (as much as possible) independent
of the target platform unless it depends on platform specific
drivers,</p>
</li>
<li><p class="first">Documentation in English</p>
</li>
</ul>
</div>
<div class="section" id="generic-interface-programming">
<h3>Generic interface programming<a class="headerlink" href="#generic-interface-programming" title="Permalink to this headline">¶</a></h3>
<p>The device must be as generic as possible which means the definition of
its interface should</p>
<ul class="simple">
<li>Reflect the service rather its underlying implementation. For
example, a command named “WriteRead” reflects the communication
service of a bus (type: message exchange), while a command named
“NI488_Send” reflects a specific implementation of the supplier.</li>
<li>Show the general characteristics (attributes and commands) of a
common type of equipment that it represents. For example, a command
”On” reflects the action of powering on a PowerSupply , while a
command named “BruckerPSON” reflects a specific implementation which
must be avoided.</li>
</ul>
<p>The device interface must be service oriented, and not implementation
oriented.</p>
</div>
<div class="section" id="abstract-interfaces">
<h3>Abstract interfaces<a class="headerlink" href="#abstract-interfaces" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="singleton-device">
<h3>Singleton device<a class="headerlink" href="#singleton-device" title="Permalink to this headline">¶</a></h3>
<p>Tango allows a device server to host several devices which are
instantiations of the same Tango class.</p>
<p>However, in particular case some technical constraints may forbid it.
In this case, the Device Server programmer must anticipate
it in the device design phase (add for example a static variable
counting device instances or other) to detect this misconfiguration. For
example, it can authorize the creation of a second instance (within the
meaning of the device creation) but systematically put the state to
FAULT (in the method init_device) and indicate the problem in the
Status.</p>
<p>In the case where technical constraints prohibit the deployment of
multiple instances of a Tango device within the same device server, the
developer has to ensure that only one instance can be created and
inform the user with a clear message in case more than one
device is configured in the database.</p>
</div>
<div class="section" id="device-states">
<h3>Device states<a class="headerlink" href="#device-states" title="Permalink to this headline">¶</a></h3>
<p>When designing the device, you should clearly define the state machine
that will reflect the different states in which the device can be, and
also the associated transitions.</p>
<p>The state machine must follow these rules:</p>
<ul class="simple">
<li>At any time, the device state must reflect the internal state of the
system it represents.</li>
<li>The state should represent any change made by a client’s request.</li>
<li>The device behaviour is specified and documented.</li>
</ul>
</div>
</div>
<div class="section" id="device-interface-definition">
<h2>Device interface definition<a class="headerlink" href="#device-interface-definition" title="Permalink to this headline">¶</a></h2>
<p>The first step in designing a device is to define the commands and the
attributes via Pogo (use Pogo to define the Tango interface).</p>
<p>Except in (very) particular cases, always use an attribute to expose the
data produced by the device. The command concept exists
(see <a class="reference internal" href="#id4"><span class="std std-ref">Device Commands</span></a>)
but its use as an attribute substitute is prohibited. Example: a motor
must be moved writing its associated ‘position’ attribute instead of
using a ‘GotoPosition’ command.</p>
<p>The choice will be made following these rules:</p>
<ul class="simple">
<li>Attribute: for all values to be presented to the “client”. <strong>It is
imperative to use the attributes and to not use Tango commands that
would act like a get/set couple.</strong></li>
<li>Command: for every action, of void-void type in most cases.</li>
</ul>
<p>Any deviation from these rules must be justified in the description of
the attribute or command particular case.</p>
</div>
<div class="section" id="service-availability">
<h2>Service availability<a class="headerlink" href="#service-availability" title="Permalink to this headline">¶</a></h2>
<p>From the operator perspective, the “<strong>response time</strong>” or
“<strong>reactivity</strong>” (i.e. the device is always responsive) is <strong>the</strong> reference
metric to describe the performance of a device. Ideally, the device
implementation must ensure the service availability regardless of the
external client load or the internal load. For the end user, it is
always very unpleasant to suffer a Tango timeout and receive an
exception instead of the expected response.</p>
<p>The response time of the device should be minimised and in any case
lower than the default Tango timeout of 3 seconds.</p>
<p>If the action to be performed takes longer than that, execution should
be done asynchronously in the Tango class: its progress being reported
in the state/status.</p>
<p>Several technical solutions are available to the device developer to
ensure service availability:</p>
<ul class="simple">
<li>Use the Tango polling mechanism,</li>
<li>Use a threading mechanism, managed by the developer.</li>
</ul>
<div class="section" id="tango-polling-mechanism">
<h3>Tango polling mechanism<a class="headerlink" href="#tango-polling-mechanism" title="Permalink to this headline">¶</a></h3>
<div class="section" id="polling-interest">
<h4>Polling interest<a class="headerlink" href="#polling-interest" title="Permalink to this headline">¶</a></h4>
<p>The polling mechanism is detailed in the Tango documentation
<a class="reference internal" href="../device-polling.html#device-polling"><span class="std std-ref">Device Polling</span></a>.</p>
<p>Tango implements a mechanism called <em>polling</em> which alleviates the
problem of equipment response time (which is usually the weak point in
terms of performance). The response time of a GPIB link or a RS-232 link
is usually one to two orders of magnitude higher than the performance of
the Tango code executed by a client request.</p>
</div>
<div class="section" id="polling-limitations">
<h4>Polling limitations<a class="headerlink" href="#polling-limitations" title="Permalink to this headline">¶</a></h4>
<p>From the perspective of the device activity, the polling is in direct
competition with client requests. The client load is therefore competing
with the polling activity.</p>
<p>This means that polling activity has to be tuned in order to keep some
free time for the device to answer client requests. Do not try to poll a device
object with a polling period of let say 200 mS if the object access time
is 300 mS (<em>even if Tango implements some algorithm to minimize the bad
behavior of such badly tuned polling</em>).</p>
<p>For polled Tango device objects (attribute or command), client reading
does not generate any activity on the device whatever the client number.
The data are returned from the so-called polling buffer instead of
coming from the device itself. Therefore, an obvious rule is to poll the
key device object (state attribute, pressure attribute for a vacuum
valve…)</p>
<p>The recommendation for device polling tuning is to keep the device free
40% of time.</p>
<p>Let’s take an example: for a power supply device, you want to poll the
device state and its current attribute which for such a device are the
device key objects.</p>
<ul class="simple">
<li>State access needs 100 mS while current attribute reading needs 50
mS.</li>
<li>Because, you want to poll these two objects, time required on the
device by the polling mechanism will be 150 mS (100 + 50).</li>
<li>In order to keep the 40% ratio, tune the polling period for this
device to 250 mS.</li>
<li>The device is then occupied by the polling mechanism during 150 mS
(60 %) but free for other client activity during 100 mS (40 %).</li>
</ul>
<p>Device polling is easily tunable at run time using Jive and/or Astor
Tango tools.</p>
</div>
</div>
<div class="section" id="threading-mechanism">
<h3>Threading mechanism<a class="headerlink" href="#threading-mechanism" title="Permalink to this headline">¶</a></h3>
<p><em>Threading</em> is a possible solution for the load problem: a thread
(managed by the device developer) supports communication with the
material (<em>polling</em> or other) and the data obtained are put in the
“cache”. You can now produce the “last known value” to the client at any
time and optimize the response time. This approach, however, has a limit
where it is necessary to reread the hardware to assure clients that the
returned value is the system “current state”.</p>
<p>For a C++ device, the implementation of a threading mechanism can be
done via the <em>DeviceTask</em> class from the <em>Yat4Tango library</em>. This class
owns a thread associated with a FIFO message list. Processing messages
can be synchronous or asynchronous.</p>
<p>See the complete example in the appendix for the implementation
details.</p>
<p>When the design of the Tango class requires threading:</p>
<ul class="simple">
<li>in case of simple thread usage, in C++ the recommendation is to use a C++11 thread</li>
<li>In case of acquisition thread with messages exchange in C++ the recommendation is to
use Yat4Tango::DeviceTask class.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="tango-device-implementation">
<h1>Tango device implementation<a class="headerlink" href="#tango-device-implementation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="general-rules">
<h2>General rules<a class="headerlink" href="#general-rules" title="Permalink to this headline">¶</a></h2>
<div class="section" id="language">
<h3>Language<a class="headerlink" href="#language" title="Permalink to this headline">¶</a></h3>
<p>The Tango community is international and the developments could be
shared with the community, so it is recommended to use English for documenting a
device development.</p>
<p>English will be used for:</p>
<ul class="simple">
<li>The interfaces definition (attributes and commands),</li>
<li>The device documentation (online help for command usage and
attributes description),</li>
<li>The comments inserted in the code by the developer,</li>
<li>The error messages,</li>
<li>The name of variables and internal methods added by the developer.</li>
</ul>
<p>The choice of the language used for the user’s documentation of the
device server (“Device Server User’s Guide”) is left free, to focus on
the editorial quality. In the case of a joint development with another
institute, English will be used.</p>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>The types used for the device interface definition are Tango types
(Tango::DevDouble, Tango::DevFloat …). These types are presented by Pogo
and are not modifiable.</p>
<p>The types used by the developer in its own code are left free to choose,
as long as they are not platform specific. Standard types of the
language used (Boolean, int, double …), Tango types or types from a
common library (Yat, Yat4Tango for C++) can potentially be used.</p>
<p>Direct conversions from the C++ type long to Tango::DevLong are only
supported on 32-bit platforms and should be avoided.</p>
</div>
<div class="section" id="generated-code">
<h3>Generated code<a class="headerlink" href="#generated-code" title="Permalink to this headline">¶</a></h3>
<p>The automatically generated code by Pogo must not be modified by the
developer.</p>
<p>The developer must include its own code in the “PROTECTED REGION”
specified parts.</p>
</div>
</div>
<div class="section" id="device-interface">
<h2>Device interface<a class="headerlink" href="#device-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="naming-rules">
<span id="id2"></span><h3>Naming rules<a class="headerlink" href="#naming-rules" title="Permalink to this headline">¶</a></h3>
<p>Having homogeneous conventions for naming attributes, commands and
properties is a good way to promote DeviceServers reuse inside the Tango
collaboration.</p>
<p>In fact it makes the development done by another institute easier to
understand and integrate in another Control System.</p>
<div class="section" id="class-name">
<h4>Class name<a class="headerlink" href="#class-name" title="Permalink to this headline">¶</a></h4>
<p>The Tango class name is obtained by concatenating the fields that
compose it – each field beginning with a capital letter:</p>
<p>Eg : MyDeviceClass</p>
</div>
<div class="section" id="id3">
<h4>Device attributes<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>The device command and attributes names must be explicit and should
enable to quickly understand the nature of the attribute or the command.</p>
<ul class="simple">
<li>Eg: for a power supply, you will have an attribute “outputCurrent”
(not OC1) or a command “ActivateOutput1” (not ActO1).</li>
</ul>
<p>The nomenclature recommendations are in the section <a class="reference internal" href="#naming-rules"><span class="std std-ref">Naming Rules</span></a>.</p>
<p><strong>The attribute naming recommendations are</strong>:</p>
<ul class="simple">
<li>Name composed of at least two characters,</li>
<li>Only alphanumeric characters are allowed (no underscore, no dashes),</li>
<li>Start with a <strong>lowercase</strong> letter,</li>
<li>In case of a composite name, each sub-words must be capitalized
(except the first letter),</li>
<li>Prohibit any use of vague terms (eg: readValue).</li>
</ul>
</div>
<div class="section" id="id4">
<span id="id5"></span><h4>Device Commands<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>The recommendations are the same as those proposed for an attribute, except for the first letter of the name.</p>
<p><strong>The command naming recommendations are:</strong></p>
<ul class="simple">
<li>Name composed of at least two characters,</li>
<li>Only alphanumeric characters are allowed (no underscore, no dashes),</li>
<li>Start with a <strong>uppercase</strong> letter,</li>
<li>In case of a composite name, each sub-words must be capitalized,</li>
<li>Prohibit any use of vague terms (eg: Control).</li>
</ul>
</div>
<div class="section" id="device-properties">
<h4>Device properties<a class="headerlink" href="#device-properties" title="Permalink to this headline">¶</a></h4>
<p>The recommendations are the same as those proposed for a command.</p>
<p><strong>The property naming recommendations are:</strong></p>
<ul class="simple">
<li>Name composed of at least two characters,</li>
<li>Only alphanumeric characters are allowed (no underscore, no dashes),</li>
<li>Start with a <strong>uppercase</strong> letter,</li>
<li>In case of a composite name, each sub-words must be capitalized,</li>
<li>Prohibit any use of vague terms (eg: Prop1).</li>
</ul>
</div>
</div>
<div class="section" id="device-attributes-nomenclature">
<h3>Device attributes nomenclature<a class="headerlink" href="#device-attributes-nomenclature" title="Permalink to this headline">¶</a></h3>
<p>It is a good practice that a particular signal type is always named in a
similar way in various DeviceServers.</p>
<p>For example the intensity of a current should always be name
“<strong>*intensity*</strong>” (and not “<strong>*intens*</strong>”,
“<strong>*intensity*</strong>”, “<strong>*current*</strong>”,”<strong>*I*</strong>” depending on
the DeviceServers).</p>
<p>This allow the user to quickly make the link between the software
information and the physical sensor and reciprocally.</p>
</div>
<div class="section" id="data-types-choice">
<h3>Data types choice<a class="headerlink" href="#data-types-choice" title="Permalink to this headline">¶</a></h3>
<p>Always use data types consistent with the underlying information</p>
<ul class="simple">
<li>Unsigned integer must be used for the physical quantities that are
suitable.<ul>
<li>Eg: A number of samples numSamples, where negative values have no
meaning, will be a Tango::DevULong (unsigned integer 32 bits) and
not a Tango::DevLong (signed integer 32 bits).</li>
<li>Similarly, in such a case, the use of a floating point number is
to be prohibited, non-integer values having no meaning.</li>
</ul>
</li>
<li>This rule is applicable to input/output arguments of commands.</li>
</ul>
</div>
<div class="section" id="interface-level-choice">
<h3>Interface level choice<a class="headerlink" href="#interface-level-choice" title="Permalink to this headline">¶</a></h3>
<p>The choice between the <em>Expert</em> or the <em>Operator</em> level for an interface
must be thoughtful.</p>
<p>Only necessary and sufficient commands for a nominal control of the
equipment must be accessible to the <em>Operator</em> level. The commands for
fine control of the equipment (eg: metrology, maintenance, unit test)
must only be accessible to the <em>Expert</em> level.</p>
</div>
</div>
<div class="section" id="pogo-use">
<h2>Pogo use<a class="headerlink" href="#pogo-use" title="Permalink to this headline">¶</a></h2>
<div class="section" id="device-generation">
<h3>Device generation<a class="headerlink" href="#device-generation" title="Permalink to this headline">¶</a></h3>
<p>The use of Pogo is mandatory for creating or modifying the device
interface.</p>
<p>Tango is constantly evolving, this tool will support all or part of the
porting, associated to the kernel and their consequences on the IDL
interface.</p>
<p>In addition, it simplifies maintenance / development operations.</p>
<p>Every command, attribute, property or device state must be fully
documented; this documentation is done via the Pogo tool.</p>
<p>Specifically, when creating an attribute with Pogo, the entire
configuration of the attribute must be fully filled in by the developer
(maximum possible) to avoid ambiguities.</p>
<p>Similarly, the states and their transitions must be described with
precision and clarity.</p>
<p>In fact:</p>
<ul>
<li><p class="first">In operation, this documentation will be the reference for
understanding the device behaviour. Remember that the operator will
have this information with the generic tools (like “<em>Test
Device</em>” from “<em>Jive</em>”).</p>
</li>
<li><p class="first">The html documentations generated by Pogo can also be accessed from a
local server (peculiar to the institute).</p>
</li>
<li><p class="first">Consider also filling in the alarm values.</p>
<ul class="simple">
<li>Eg: set the alarm values according to the specifications of a
power supply, ie, 0V-24V for the voltage, or 0A-3A for the output
current.</li>
</ul>
<blockquote>
<div><p>Example for a temperature reading:</p>
</div></blockquote>
</li>
</ul>
<div class="figure">
<img alt="../../../_images/image9.png" src="../../../_images/image9.png" />
</div>
</div>
<div class="section" id="attributes-generation-in-c">
<h3>Attributes generation in C++<a class="headerlink" href="#attributes-generation-in-c" title="Permalink to this headline">¶</a></h3>
<p>In C++, Pogo automatically generates <strong>pointers</strong> to the data associated
with the attributes values (ie a pointer is generated for the read
part). The use of these pointers is not mandatory. The developer is free
to use his own data structure in the attribute value affectation.</p>
</div>
</div>
<div class="section" id="internal-device-implementation">
<h2>Internal device implementation<a class="headerlink" href="#internal-device-implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="separation-between-the-tango-interface-and-the-internal-system-function">
<h3>Separation between the Tango interface and the internal system function<a class="headerlink" href="#separation-between-the-tango-interface-and-the-internal-system-function" title="Permalink to this headline">¶</a></h3>
<p>Don’t forget that the Tango interface is only a means to insert a microservice
in a control system. Therefore, it is necessary to think the device
internal design like any other application and just add the Tango as an
interface on top of it.</p>
<p>As a rule of thumb if the code implemented within the Pogo markers is
too long, a good practice is to move it to another class. Then Pogo
generated methods will be only a few lines of code long.</p>
<p>In practice, it is necessary to avoid mixing the generated code by Pogo
and the developer’s one.</p>
<p>The Tango sub-class inherited from <em>Tango::DeviceImpl[_X]</em> instantiates
a class derived from the model object implementing the system, and
ensure the replacement between the external requests (clients) and the
implementation class(es).</p>
<p>In the choice of data structures, we are talking about those of the
developer’s object model, we will consider the technical constraints
imposed by Tango and/or the underlying layers (CORBA/ZMQ). The idea here is
to avoid copy and/or reorganization of the data when transferred to the
client. For this, the developer needs to know/master the underlying
memory management mechanism (especially in C++). The Tango documentation
contains a dedicated chapter “<em>Exchanging data between client and server”</em>.</p>
</div>
<div class="section" id="details-on-method-for-accessing-the-hardware-always-executed-hook-versus-read-attr-hardware">
<h3>Details on method for accessing the hardware: always_executed_hook versus read_attr_hardware<a class="headerlink" href="#details-on-method-for-accessing-the-hardware-always-executed-hook-versus-read-attr-hardware" title="Permalink to this headline">¶</a></h3>
<p>It is essential to master the concepts implemented by these two methods
(common methods for all Tango devices).</p>
<p>It is also necessary to clearly identify, in the design phase, the
possible consequences of implementing these two methods on the device
behaviour (remember that they are initially just empty shells generated
by Pogo).</p>
<ul class="simple">
<li><em>Always_executed_hook()</em> method is called before each command
execution or each reading/writing of an attribute (<em>but it is called
only once when reading several attributes: see calling sequence
below</em>)</li>
<li><em>Read_attr_hardware()</em> is called before each reading of
attribute(s)( <em>but it is called only once when reading several
attributes: see calling sequence below)</em>. This method aims to
optimize (minimize) the equipment access in case of simultaneous
reading of multiple attributes in the same request.</li>
</ul>
<p>Reminder about the calling sequence of these methods:</p>
<ul class="simple">
<li><em>Command execution</em><ul>
<li>1 – always_executed_hook()</li>
<li>2 – is_MyCmd_allowed()</li>
<li>3 – MyCmd()</li>
</ul>
</li>
<li><em>Attribute reading</em><ul>
<li>1 – always_executed_hook()</li>
<li>2 – read_attr_hardware()</li>
<li>3 – is_MyAttr_allowed()</li>
<li>4 – read_MyAttr()</li>
</ul>
</li>
<li><em>Attribute writing</em><ul>
<li>1 – always_executed_hook()</li>
<li>2 – is_MyAttr_allowed()</li>
<li>3 – write_MyAttr()</li>
</ul>
</li>
<li><em>Attributes reading</em><ul>
<li>1 – always_executed_hook()</li>
<li>2 – read_attr_hardware()</li>
<li>3 – is_MyAttr_allowed()</li>
<li>4 – read_MyAttr()</li>
</ul>
</li>
<li><em>Attributes writing</em><ul>
<li>1 – always_executed_hook()</li>
<li>2 – is_MyAttr_allowed()</li>
<li>3 – write_MyAttr()</li>
</ul>
</li>
</ul>
<p>When reading the sequence above, we understand why the mastery of these
concepts is important. Particularly, having “slow code” in the
<em>MyDevice::always_executed_hook</em> method can have serious consequences
on the device performance.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>There is no obligation to use the <em>read_attr_hardware</em>
method; it depends on the equipment to drive and its communication
channel (Ethernet, GPIB, DLL). You can have a call to the equipment in
the code of each attribute reading method.</p>
<blockquote class="last">
<div>Example: For an attribute “temperature”, of READ type, we can insert
the call to the equipment in the generated attribute reading method
“<em>read_Temperature</em>” instead of “<em>read_attr_hardware</em>”.</div></blockquote>
</div>
</div>
<div class="section" id="static-database-as-persistent-data-storage">
<h3>Static database as persistent data storage<a class="headerlink" href="#static-database-as-persistent-data-storage" title="Permalink to this headline">¶</a></h3>
<p>As noted above the Tango database can (in some cases) be
used to ensure persistence of set values, to store the value as a property
(of device or attribute).</p>
<p>However, this practice should be reserved for special cases that don’t
require writing at high frequency. An over-solicitation of the Tango
database will penalize the entire control system.</p>
<p>It is therefore recommended to use a property for storage only for
methods that are performed rarely, compared to other functions.</p>
<p>For example: storage of calibration operations results</p>
<p>In the general case, we recommend to:</p>
<ul class="simple">
<li>Use a property to store configuration data,</li>
<li>Use a memorized attribute to store values changing during the
execution,</li>
<li>Use a memorized attribute to store values that you want to re-inject
during a new execution of the device.</li>
</ul>
</div>
</div>
<div class="section" id="device-state-management">
<h2>Device state management<a class="headerlink" href="#device-state-management" title="Permalink to this headline">¶</a></h2>
<div class="section" id="states-choice">
<h3>States choice<a class="headerlink" href="#states-choice" title="Permalink to this headline">¶</a></h3>
<p>In Tango, as already said, the state is seen as an enumerated type with a
fix number of values. These states have an implicit default meaning and
are not equivalent. Furthermore a color code is associated to each state
and is used in the main GUI tools to have a unified manner of
representing the state of equipment.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="19%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">State</th>
<th class="head">Colour</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>UNKNOWN</td>
<td>grey</td>
<td><div class="first last line-block">
<div class="line">The device cannot retrieve its state. It is the case when there is a</div>
<div class="line">communication problem to the hardware (network cut, broken cable etc…).</div>
<div class="line">It could also represent an incoherent situation</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>INIT</td>
<td>beige</td>
<td><div class="first last line-block">
<div class="line">This state is reserved to the starting phase of the device server.</div>
<div class="line">It means that the software is not fully operational and that the user</div>
<div class="line">must wait</div>
</div>
</td>
</tr>
<tr class="row-even"><td>FAULT</td>
<td>red</td>
<td><div class="first last line-block">
<div class="line">The device has a major failure that prevents it to work. For instance,</div>
<div class="line">A powersupply has stopped due to over temperature A motor cannot move</div>
<div class="line">because it has fault conditions. Usually we cannot get out from this</div>
<div class="line">state without an intervention on the hardware or a reset command.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>DISABLE</td>
<td>magenta</td>
<td><div class="first last line-block">
<div class="line">The device cannot be switched ON for an external reason. e.g. the</div>
<div class="line">powersupply has it’s door open, the safety conditions are not</div>
<div class="line">satisfactory to allow the device to operate</div>
</div>
</td>
</tr>
<tr class="row-even"><td>OFF</td>
<td>white</td>
<td><div class="first last line-block">
<div class="line">The device is in normal condition but is not active. e.g the</div>
<div class="line">powersupply main circuit breaker is open; the RF transmitter has no</div>
<div class="line">power etc…</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>STANDBY</td>
<td>yellow</td>
<td><div class="first last line-block">
<div class="line">The device is not fully active but is ready to operate. This state does</div>
<div class="line">not exist in many devices but may be useful when the device has an</div>
<div class="line">intermediate state between OFF and ON. E.g the main circuit breaker is</div>
<div class="line">closed but there is no output current. Usually Standby is used when it</div>
<div class="line">can be immediately switched ON. While OFF is used when a certain time</div>
<div class="line">is necessary before switching ON.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>MOVING</td>
<td>light blue</td>
<td><div class="first last line-block">
<div class="line">The device is in a transitory state. It is the case of a device moving</div>
<div class="line">from one state to another.( E.g a motor moving from one position to</div>
<div class="line">another, a big instrument is executing a sequence of operation, a</div>
<div class="line">macro command is being executed.)</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>ON</td>
<td>green</td>
<td><div class="first last line-block">
<div class="line">This state could have been called OK or OPERATIONAL. It means that the</div>
<div class="line">device is in its operational state. (E.g. the powersupply is giving its</div>
<div class="line">nominal current, the motor is ON and ready to move, the instrument is</div>
<div class="line">operating). This state is modified by the Attribute alarm checking of</div>
<div class="line">the DeviceImpl:dev_state method. i.e if the state is ON and one</div>
<div class="line">attribute has it’s quality factor to ALARM, then the state is modified</div>
<div class="line">to ALARM</div>
</div>
</td>
</tr>
<tr class="row-even"><td>ALARM</td>
<td>orange</td>
<td><div class="first last line-block">
<div class="line">The device is operating but one of this attribute is out of range.</div>
<div class="line">It can be linked to alarm conditions set by attribute properties or a</div>
<div class="line">specific case. (E.g. temperature alarm on a stepper motor, end switch</div>
<div class="line">pressed on a steppermotor, up water level in a tank, etc…) In alarm,</div>
<div class="line">usually the device does it’s job but the operator has to perform an</div>
<div class="line">action to avoid a bigger problem that may switch the state to FAULT.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>RUNNING</td>
<td>dark green</td>
<td><div class="first last line-block">
<div class="line">This state does not exist in many devices but may be useful when the</div>
<div class="line">device has a specific state above the ON state. (E.g. the detector</div>
<div class="line">system is acquiring data, An automatic job is being executed).</div>
<div class="line">Note that this state is different from the MOVING state. It is not a</div>
<div class="line">transitory situation and may be a normal operating state above the ON</div>
<div class="line">state.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>OPEN</td>
<td>green</td>
<td><div class="first last line-block">
<div class="line">Synonym of ON state. Can be used when ON is not adequate for the device</div>
<div class="line">e.g case of a valve, a door, a relay, a switch.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>CLOSE</td>
<td>white</td>
<td><div class="first last line-block">
<div class="line">Synonym of OFF state. Can be used when OFF is not adequate for the</div>
<div class="line">device e.g case of a valve, a door, a relay, a switch.</div>
</div>
</td>
</tr>
<tr class="row-even"><td>EXTRACT</td>
<td>green</td>
<td><div class="first last line-block">
<div class="line">Synonym of ON state. Can be used when ON is not adequate for the device</div>
<div class="line">Case of insertable/extractable equipment, absorbers, etc…</div>
<div class="line"><br /></div>
<div class="line">This state is here for compatibility reason we recommend to use ON or</div>
<div class="line">OPEN when possible.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>INSERT</td>
<td>white</td>
<td><div class="first last line-block">
<div class="line">Synonym of OFF state. Can be used when OFF is not adequate for the</div>
<div class="line">device. Case of insertable/extractable equipment, absorbers, etc…</div>
<div class="line"><br /></div>
<div class="line">This state is here for compatibility reason we recommend to use OFF or</div>
<div class="line">CLOSE when possible.</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>Unless strictly specified, the developer is free to use the Tango
state she considers appropriate to the situation, with all the
subjectivity involved.</p>
<p>The only practice that ensures overall consistency is to use a limited
number of Tango states, especially for a family of equipment.</p>
<p>It is recommended for an equipment of type motor, slit, monochromator
and more generally for any equipment that can change his position, to
use the “MOVING” state when the equipment is in “movement” toward his
set point.</p>
</div>
<div class="section" id="semantics-of-non-nominal-states">
<h3>Semantics of non-nominal states<a class="headerlink" href="#semantics-of-non-nominal-states" title="Permalink to this headline">¶</a></h3>
<p>Although the developer is free to choose the device states, we must
define a common error state for all the devices.</p>
<p>In general, any dysfunction is associated with the state <em>Tango::FAULT</em>.</p>
<p>The use of the <em>Tango::ALARM</em> state should be reserved for very special
cases where it is necessary to define an intermediate state between
normal operation and fault. Its use must be documented via Pogo in order
to define the semantics.</p>
<p>In the case of a problem occurring at initialization, it is recommended
to set the device state to FAULT.</p>
<p>For the init_device method, we recommend:</p>
<ul class="simple">
<li>If the initialization method is long, thread it.</li>
<li>The device state INIT must be used only in the start-up of the device.</li>
</ul>
<p>The device states changes when the init execution is over.</p>
<p>Semantics recommended for FAULT and ALARM states is as follows:</p>
<ul class="simple">
<li>UNKNOWN (grey): communication problem with the equipment or the “sub”-devices which prevents the device to really know his real state</li>
<li>FAULT (red): A problem which prevents the normal functioning (including during the initialization). Getting out from a FAULT state is possible only by repairing the cause of the problem and/or executing a Reset command.</li>
<li>ALARM (orange): the device is functional but one element is out of range (bad parameters but not preventing the functioning, limit switch of a motor). An attribute is out of range.</li>
</ul>
</div>
<div class="section" id="state-machine-management">
<h3>State machine management<a class="headerlink" href="#state-machine-management" title="Permalink to this headline">¶</a></h3>
<div class="section" id="pogo-or-developer-code">
<h4>Pogo or developer code<a class="headerlink" href="#pogo-or-developer-code" title="Permalink to this headline">¶</a></h4>
<p>Tango has a basic management of its state machine. <em>Is_allowed</em> methods
filter the external request depending on the current device state. The
developer must define the device behaviour (regarding its internal
state) via Pogo.</p>
<p>By default, any request (reading, writing, or command execution) is
authorized whatever the current device state is.</p>
<p>The example below illustrates two ways for the state machine management
of a device (here NITC01) in C++:</p>
<ul class="simple">
<li>Managing the “On” command via Pogo</li>
<li>Managing the reading of the attribute “temperature” directly in the
code</li>
</ul>
<div class="figure">
<img alt="../../../_images/image10.png" src="../../../_images/image10.png" />
</div>
<div class="figure">
<img alt="../../../_images/image11.png" src="../../../_images/image11.png" />
</div>
<p>However, the Pogo implementation is “basic”. If, for example, the
execution of the “On” command on a power supply is prohibited when the
current state is “<em>Tango::ON</em>”, then the Tango layer, generated by
Pogo, will systematically trigger an exception to the client. From the
operator perspective, this may surprise.</p>
<p>In such a case, it is recommended to authorize the command but to ignore
it</p>
</div>
<div class="section" id="particular-case-fault-state">
<h4>Particular case&nbsp;: FAULT state<a class="headerlink" href="#particular-case-fault-state" title="Permalink to this headline">¶</a></h4>
<p><strong>The *Tango::FAULT* state shouldn’t prohibit everything.</strong> The
attributes and/or commands that are valid and/or allows the device to
get out of the <em>Tango::FAULT</em> state must remain accessible.</p>
<p>For example, in some cases, when a device used several elementary
devices, its state is a combination of the elementary devices states. If
one of them is in “FAULT”, we must be able to execute commands on others
elementary devices, and, in all cases, have a command to get out of this
state.</p>
<p>The transition to a “FAULT” state needs reflection and a clear
definition of the device management in this state and the output
conditions of this state.</p>
</div>
<div class="section" id="init-and-error-acknowledgement">
<h4>Init and error acknowledgement<a class="headerlink" href="#init-and-error-acknowledgement" title="Permalink to this headline">¶</a></h4>
<p>A common mistake is to associate the generic command MyDevice::Init to
an acknowledgement mechanism for the current defect.</p>
<p><strong>The execution of the *Init* command must be reserved to the device
re-initialization</strong> (hardware reconnection after a reboot or
reconfiguration following a property modification).</p>
<p>Any device that requires an acknowledgement mechanism must have a
dedicated command (like <em>Reset</em> or <em>AcknowledgeError</em>).</p>
</div>
<div class="section" id="other-implementations">
<h4>Other implementations<a class="headerlink" href="#other-implementations" title="Permalink to this headline">¶</a></h4>
<p>You can also create a specific state machine, without using Tango types,
in the interface class with the device. Thus, we use this state machine
to determine the Tango state of the device. The aims here is to define
an internal state machine (with a design pattern “state” for example)
then do a mapping with the existing Tango states to determine the device
state.</p>
<p>The developer also has the ability to override the <em>State</em> and <em>Status</em>
methods in order to centralize, in a unique method, the management of
the internal device state, which simplifies the update of this
fundamental information.</p>
</div>
</div>
</div>
<div class="section" id="logging-management">
<h2>Logging management<a class="headerlink" href="#logging-management" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-importance-of-rigorous-logging-management">
<h3>The importance of rigorous logging management<a class="headerlink" href="#the-importance-of-rigorous-logging-management" title="Permalink to this headline">¶</a></h3>
<p>The introduction of logging in the device code enables easy development,
bug research and the user understanding of the device operations.</p>
<p>The device developer must always use the facilities offered by the
<em>Tango Logging Service</em> to produce “Runtime” messages, facilitating the
understanding of the device operations. Implementations classes can
inherit <em>Tango::LogAdaptater</em> to redirect the logs to the common
service.</p>
<p>The rules to follow are:</p>
<ul class="simple">
<li>Logs to the console are prohibited. The developer must use the logging
stream proposed by Tango (there is a stream for every logging level, the
levels being inclusive in the order specified below). :
<em>DEBUG_STREAM, INFO_STREAM, WARN_STREAM, ERROR_STREAM, FATAL_STREAM</em></li>
<li>It is important to use the right level of <em>logging</em> : on a higher
level than DEBUG, the device should be a little wordy. Beyond the
INFO level, it should produce only critical logs.</li>
</ul>
<p>Recommendations of use:</p>
<ul class="simple">
<li>DEBUG_STREAM&nbsp;: developer information (route trace)</li>
<li>INFO_STREAM&nbsp;: user information (measure, start/stop of a process)</li>
<li>WARN_STREAM&nbsp;: warning (eg deprecated operation)</li>
<li>ERROR_STREAM&nbsp;: general error</li>
<li>FATAL_STREAM&nbsp;: fatal error, shutdown</li>
</ul>
<p>It is important to use these <em>streams</em> early in the development. They
allow an easier debugging.</p>
<p><strong>You shouldn’t have to modify the code to add traces.</strong></p>
<ul class="simple">
<li>Eg: use a debug_stream level for the input parameters, the display
of a conversion result, the return code from a DLL function…</li>
</ul>
<p>It is also recommended to adopt a unified formalism for logs, for
example:</p>
<ul>
<li><p class="first">“&lt;class_name&gt;::&lt;method_name&gt;() - &lt;text trace with parameter
(eventually)&gt;”</p>
<blockquote>
<div><p>Example of using different logs levels in C++:</p>
</div></blockquote>
</li>
</ul>
<div class="figure">
<img alt="../../../_images/image12.png" src="../../../_images/image12.png" />
</div>
<p>It is also possible to redirect the stream to a file (via Jive). This
can be useful in the case of “random” bugs, for which a long log is
required.</p>
</div>
<div class="section" id="implementation">
<h3>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h3>
<p>It is not mandatory, but highly recommended to add an attribute named
“log” in the device interface, strings spectrum type, which tracks all
the internal activity of the device (as defined in Tango Logging).</p>
<ul class="simple">
<li>In C++, the class <em>Yat4Tango::InnerAppender</em> implements this
functionality based on a dynamic attribute (no need to use Pogo).</li>
<li>This system facilitates the recovery of errors and therefore the
problems diagnosis. Problem solving will be faster and optimized.</li>
<li>This feature is in particular very interesting for devices that
manage automatic processes (like doing scans,..) which involve other
devices. The operator has then an easy access through this “log”
attribute to the behaviour and decisions taken by the device.</li>
</ul>
<p>Example of using C++ (look at the YAT documentation for further
explanations:</p>
<blockquote>
<div>In the header file of the device</div></blockquote>
<ul class="simple">
<li>Declaration of the service to use</li>
</ul>
<div class="figure">
<img alt="../../../_images/image13.png" src="../../../_images/image13.png" />
</div>
<p>In the source code of the device</p>
<ul class="simple">
<li>init_device&nbsp;method: initialization of the “innerAppender”</li>
<li>delete_device&nbsp;method: deletion of the “innerAppender”</li>
</ul>
<div class="figure">
<img alt="../../../_images/image14.png" src="../../../_images/image14.png" />
</div>
<div class="figure">
<img alt="../../../_images/image15.png" src="../../../_images/image15.png" />
</div>
</div>
</div>
<div class="section" id="error-handling">
<h2>Error handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-importance-of-rigorous-error-handling">
<h3>The importance of rigorous error handling<a class="headerlink" href="#the-importance-of-rigorous-error-handling" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this paragraph is based on a statement on the Tango
developers practice. Indeed, the error handling is often overlooked. A
good error handling means easier debugging and maintenance.</p>
<p><strong>This part is important</strong>, it is essential for the coding quality.
These concepts are detailed in the Tango documentation referenced
<em>“Reporting Error”</em>.</p>
<p>Typical cases to avoid:</p>
<ul class="simple">
<li>A device doesn’t behave as expected but there is no indication why.</li>
<li>The device is in FAULT state but the <em>Status</em> (the attribute) gives
no indication on the problem nature, or worse, a bad indication (thus
guiding the users in a wrong trail, with a loss of time and energy).</li>
<li>The error messages are written in the jargon of the developer or the
system expert.</li>
</ul>
<p>The developer has to ensure:</p>
<ul class="simple">
<li>That any exception is caught, completed (Tango allows it) and spread
(use of the rethrow_exception method),</li>
<li>If an error occur it must be logged using the Tango Logging Service</li>
<li>That the return code of a function is always analyzed,</li>
<li>That the device <em>Status</em> is always coherent with the <em>State,</em></li>
<li>That the error messages are understandable for the final user and
that they are supplemented by <em>logs</em> (<em>ERROR level, use of the
error_stream macro</em>). The <em>Status</em> is the indicator that will help
the user to find the error reason.</li>
<li><strong>Ignore the “ideal situation”:</strong> In operation, the ideal setting is
often jeopardized.<ul>
<li>Eg: use of communication sockets: anticipate all the common
communication problems: cable not connected, equipment off,
sub-devices not started or in FAULT.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id6">
<h3>Implementation<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>On a more technical view, the Tango exceptions don’t provide numerical
identifier for discriminating exceptions. In the code, it isn’t possible
to distinguish two exceptions without having knowledge of the text (as
string) conveyed by the said exception.</p>
<p>All exceptions are of type <em>Tango::DevFailed</em>. A DevFailed exception
consists of these fields:</p>
<ul class="simple">
<li>Reason: string, defining the error type<ul>
<li>Aim: refer the <strong>operator</strong> to the root cause</li>
</ul>
</li>
<li>Description: string, giving a more precise description<ul>
<li>Aim: refer the <strong>expert</strong> of this system to the root cause.</li>
</ul>
</li>
<li>Origin: string, method where the exception was thrown<ul>
<li>Aim&nbsp;: refer the <strong>computer scientist</strong> on the location of the
failure in its code</li>
</ul>
</li>
<li>Severity: enumeration (rarely uses)</li>
<li>To easily distinguish exceptions, it is recommended to use a finite
list of error types for the Reason field, specify in capital letters:</li>
</ul>
</div>
<div class="section" id="standardized-name-for-error-types">
<h3>Standardized name for error types<a class="headerlink" href="#standardized-name-for-error-types" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="100%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Standardized name for the error types</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>OUT_OF_MEMORY</td>
</tr>
<tr class="row-odd"><td>HARDWARE_FAILURE</td>
</tr>
<tr class="row-even"><td>SOFTWARE_FAILURE</td>
</tr>
<tr class="row-odd"><td>HDB_FAILURE</td>
</tr>
<tr class="row-even"><td>DATA_OUT_OF_RANGE</td>
</tr>
<tr class="row-odd"><td>COMMUNICATION_BROKEN</td>
</tr>
<tr class="row-even"><td>OPERATION_NOT_ALLOWED</td>
</tr>
<tr class="row-odd"><td>DRIVER_FAILURE</td>
</tr>
<tr class="row-even"><td>UNKNOW_ERROR</td>
</tr>
<tr class="row-odd"><td>CORBA_TIMEOUT</td>
</tr>
<tr class="row-even"><td>Tango_CONNECTION_FAILED</td>
</tr>
<tr class="row-odd"><td>Tango_COMMUNICATION_ERROR</td>
</tr>
<tr class="row-even"><td>Tango_WRONG_NAME_SYNTAX_ERROR</td>
</tr>
<tr class="row-odd"><td>Tango_NON_DB_DEVICE_ERROR</td>
</tr>
<tr class="row-even"><td>Tango_WRONG_DATA_ERROR</td>
</tr>
<tr class="row-odd"><td>Tango_NON_SUPPORTED_FEATURE_ERROR</td>
</tr>
<tr class="row-even"><td>Tango_ASYNC_CALL_ERROR</td>
</tr>
<tr class="row-odd"><td>Tango_ASYNC_REPLY_NOT_ARRIVED_ERROR</td>
</tr>
<tr class="row-even"><td>Tango_EVENT_ERROR</td>
</tr>
<tr class="row-odd"><td>Tango_DEVICE_ERROR</td>
</tr>
<tr class="row-even"><td>CONFIGURATION_ERROR</td>
</tr>
<tr class="row-odd"><td>DEPENDENCY_ERROR</td>
</tr>
<tr class="row-even"><td>NO_DEPENDENCY</td>
</tr>
</tbody>
</table>
<p>Table 2 : List of standardized error types for an exception</p>
<p>Example of an exception message:</p>
<blockquote>
<div><p><strong>Reason</strong>: DATA_OUT_OF_RANGE</p>
<p><strong>Description</strong>: AxisMotionAccuracy must be at least of 1 motor
step!</p>
<p><strong>Origin</strong>: GalilAxis::write_attr_hardware</p>
</div></blockquote>
<p>The exception hierarchy defined by Tango has been thought only for
internal use (Tango core), the developer can’t inherit and define its
own inherited exceptions classes. This strong constraint is related to
the underlying CORBA IDL.</p>
<p><strong>Always keep the original exception.</strong> It must be the first visible
item in the device status.</p>
<p>If there is a succession of exceptions, the logic dictates that the
first exception has possibly generated all the others. By resolving the
first exception, the others can disappear.</p>
<p><strong>Exception handling in init_device method:</strong></p>
<ul class="simple">
<li>no exceptions should be propagated from the method <em>MyDevice::init_device</em><strong>.</strong> Otherwise, <strong>the device quits.</strong> The device should be kept alive regardless of any failure.</li>
<li>The code for this method must contain a try / catch block, which guarantees that no exception is propagated in this context</li>
<li>If an exception is thrown, the developer must set the device state to FAULT and update the Status to indicate the error nature. (<em>The goal is to understand easily why the device failed to initialize properly, while still allowing the operator to adjust this or these problems</em>)</li>
</ul>
<p><strong>Examples of error handling in C++:</strong></p>
<ul class="simple">
<li>If an error occurs, always log it</li>
<li>Always update <em>State</em> <strong>AND</strong> <em>Status</em></li>
<li>Manage the return code for function that have one</li>
<li>Manage the exceptions for methods which can throw some</li>
</ul>
<div class="figure">
<img alt="../../../_images/image16.png" src="../../../_images/image16.png" />
</div>
</div>
<div class="section" id="details-for-an-attribute">
<h3>Details for an attribute<a class="headerlink" href="#details-for-an-attribute" title="Permalink to this headline">¶</a></h3>
<p>Although Tango supports the notion of quality on an attribute value
(<em>Tango::VALID</em>, <em>Tango::INVALID</em>, …), only few clients use this
information to judge the validity of the data returned (which is a
shame). So it is best to not make assumptions on the use that would be
made (client side) to report an invalid value to the client. In other
words, <strong>forcing the attribute quality to *Tango::INVALID* is necessary
but not sufficient.</strong></p>
<p>For float values, it is possible to set the value to “NaN”, but there is
no equivalent for an integer. To avoid the handling of special cases, it
is recommended to throw an exception to indicate the data invalidity.</p>
<p>It is recommended to throw an exception for all invalid values,
regardless of their type. There is, however, two exceptions to this
rule: State and Status. For these two attributes, always return a value.</p>
<p>This solution has the disadvantage to show a pop-up on the client side,
but this is the most effective method to indicate that the attribute
reading has failed.</p>
</div>
<div class="section" id="details-for-the-properties">
<h3>Details for the properties<a class="headerlink" href="#details-for-the-properties" title="Permalink to this headline">¶</a></h3>
<div class="section" id="properties-reading-during-device-initialization">
<h4>Properties reading during device initialization<a class="headerlink" href="#properties-reading-during-device-initialization" title="Permalink to this headline">¶</a></h4>
<p>As it stands, the code generated by Pogo doesn’t wrap in a try / catch
block the method which ensures the properties reading in the Tango
database (see <em>MyDevice::init_device</em>). However, it may fail and cause
the generation of an exception. As mentioned above, the developer must
ensure that any exception thrown in the <em>init_device</em> method (or a
method called from it) is catch and not spread.</p>
<p>In case of Tango exception on the <em>properties</em> reading, the developer
should systematically:</p>
<ol class="arabic simple">
<li>detect the error (catch).</li>
<li>log it with level ERROR.</li>
<li>set the device to the FAULT state.</li>
<li>update the Status indicating the problem origin.</li>
</ol>
<p>Example in C++ :</p>
<div class="figure">
<img alt="../../../_images/image17.png" src="../../../_images/image17.png" />
</div>
<p>As a reminder, the default value for a property is defined with Pogo,
the value is stored in the database via the <em>put_property()</em> method.</p>
</div>
<div class="section" id="properties-without-default-values">
<h4>Properties without default values<a class="headerlink" href="#properties-without-default-values" title="Permalink to this headline">¶</a></h4>
<p>Pogo allows defining a default value for a <em>property</em> not present in the
Tango database.</p>
<blockquote>
<div>For mandatory properties that have no default values, the developer
should systematically:</div></blockquote>
<ul class="simple">
<li>detect the absence of the value in the database.</li>
<li>log the problem explicitly with the level ERROR ( indicate the
missing property).</li>
<li>set the device to the FAULT state.</li>
<li>update the Status indicating the problem origin.</li>
</ul>
</div>
</div>
</div>
</div>
<div class="section" id="appendices">
<h1>Appendices<a class="headerlink" href="#appendices" title="Permalink to this headline">¶</a></h1>
<div class="section" id="appendix-1-code-quality-checklist">
<h2>Appendix 1 –Code Quality Checklist<a class="headerlink" href="#appendix-1-code-quality-checklist" title="Permalink to this headline">¶</a></h2>
<p>The following checklist defines the conformity level of a source code
for a Tango device development with the recommendations detailed in this
document.</p>
</div>
<div class="section" id="appendix-2-full-code-samples">
<h2>Appendix 2 – Full code samples<a class="headerlink" href="#appendix-2-full-code-samples" title="Permalink to this headline">¶</a></h2>
<p>Example C++ «&nbsp;AttributeSequenceWriter&nbsp;»&nbsp;:</p>
<p>Example C++ «&nbsp;NITC01&nbsp;»&nbsp;:</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><a class="reference external" href="http://www.Tango-controls.org">http://www.Tango-controls.org</a></td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../device-server-model.html" class="btn btn-neutral float-right" title="The TANGO device server model" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="TANGO Device Server Guidelines" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Tango Community, Creative Commons Attribution 4.0 International (CC BY 4.0).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'9.2.5',
            LANGUAGE:'en',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>